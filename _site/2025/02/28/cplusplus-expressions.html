<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Expressions: type and value category | shanweiqiang’s blog</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="Expressions: type and value category" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="According to my experience, the most difficult part in understanding C++ is however the most basic one: the expression. Only by having a comprehensive understanding of expression, one can further have a clear understanding about lvalue, rvalue, type deduction, auto keyword, universal reference, decltype, move semantics,etc. As you can see, above-mentioned concepts are at the core of C++ 11 and afterwards." />
<meta property="og:description" content="According to my experience, the most difficult part in understanding C++ is however the most basic one: the expression. Only by having a comprehensive understanding of expression, one can further have a clear understanding about lvalue, rvalue, type deduction, auto keyword, universal reference, decltype, move semantics,etc. As you can see, above-mentioned concepts are at the core of C++ 11 and afterwards." />
<link rel="canonical" href="http://localhost:4000/2025/02/28/cplusplus-expressions.html" />
<meta property="og:url" content="http://localhost:4000/2025/02/28/cplusplus-expressions.html" />
<meta property="og:site_name" content="shanweiqiang’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-02-28T09:22:46+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Expressions: type and value category" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-02-28T09:22:46+08:00","datePublished":"2025-02-28T09:22:46+08:00","description":"According to my experience, the most difficult part in understanding C++ is however the most basic one: the expression. Only by having a comprehensive understanding of expression, one can further have a clear understanding about lvalue, rvalue, type deduction, auto keyword, universal reference, decltype, move semantics,etc. As you can see, above-mentioned concepts are at the core of C++ 11 and afterwards.","headline":"Expressions: type and value category","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2025/02/28/cplusplus-expressions.html"},"url":"http://localhost:4000/2025/02/28/cplusplus-expressions.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="shanweiqiang&apos;s blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">shanweiqiang&#39;s blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/tags/">tags</a><a class="page-link" href="/about/">about</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Expressions: type and value category</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2025-02-28T09:22:46+08:00" itemprop="datePublished">Feb 28, 2025
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>According to my experience, the most difficult part in understanding C++ is however the most basic one: the <code class="language-plaintext highlighter-rouge">expression</code>. Only by having a comprehensive understanding of <code class="language-plaintext highlighter-rouge">expression</code>, one can further have a clear understanding about lvalue, rvalue, type deduction, <code class="language-plaintext highlighter-rouge">auto</code> keyword, universal reference, <code class="language-plaintext highlighter-rouge">decltype</code>, move semantics,etc. As you can see, above-mentioned concepts are at the core of C++ 11 and afterwards.</p>

<p>This blog summarize information, concepts, references around <code class="language-plaintext highlighter-rouge">expression</code>. It does not provide additional knowledge, but act as a understanding note.</p>

<ul id="markdown-toc">
  <li><a href="#expressions" id="markdown-toc-expressions">Expressions</a>    <ul>
      <li><a href="#type" id="markdown-toc-type">Type</a></li>
      <li><a href="#value-category" id="markdown-toc-value-category">Value Category</a></li>
      <li><a href="#type-vs-valuecategory" id="markdown-toc-type-vs-valuecategory">Type vs ValueCategory</a></li>
    </ul>
  </li>
  <li><a href="#type-deduction" id="markdown-toc-type-deduction">Type Deduction</a>    <ul>
      <li><a href="#deduction-context" id="markdown-toc-deduction-context">Deduction context</a></li>
      <li><a href="#function-template-parameter-type-deduction" id="markdown-toc-function-template-parameter-type-deduction">Function template parameter type deduction</a></li>
      <li><a href="#auto-deduction" id="markdown-toc-auto-deduction">auto deduction</a></li>
      <li><a href="#more-about-universal-reference" id="markdown-toc-more-about-universal-reference">More about Universal Reference</a>        <ul>
          <li><a href="#reference-collapsing-rules" id="markdown-toc-reference-collapsing-rules">Reference Collapsing Rules</a></li>
          <li><a href="#key-points--golden-rules" id="markdown-toc-key-points--golden-rules">Key Points &amp; Golden Rules</a></li>
          <li><a href="#stdforward-explained" id="markdown-toc-stdforward-explained">std::forward explained</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#named-variables" id="markdown-toc-named-variables">Named Variables</a></li>
  <li><a href="#decltype" id="markdown-toc-decltype">decltype</a>    <ul>
      <li><a href="#print-valueness" id="markdown-toc-print-valueness">Print valueness</a></li>
    </ul>
  </li>
  <li><a href="#static_cast-vs-decltype" id="markdown-toc-static_cast-vs-decltype">static_cast vs decltype</a></li>
  <li><a href="#declval" id="markdown-toc-declval">declval</a></li>
</ul>

<h1 id="expressions">Expressions</h1>

<p><a href="https://en.cppreference.com/w/cpp/language/expressions">C++ expressions</a></p>

<p>Each C++ expression (an operator with its operands, a literal, a variable name, etc.) is characterized by two independent properties: a type and a value category. Each expression has some non-reference type, and each expression belongs to exactly one of the three primary value categories: <em>prvalue</em>, <em>xvalue</em>, and <em>lvalue</em>.</p>

<h2 id="type">Type</h2>

<p>An expression can have basic type, user-defined type, const/non-const, reference/non-reference types. However, <strong>If an expression initially has the type “reference to T” (8.3.2, 8.5.3), the type is adjusted to T prior to any further analysis.</strong>, which indicates that expression can have reference types. <a href="https://scottmeyers.blogspot.com/2015/02/expressions-can-have-reference-type.html">Expressions can have Reference Type</a>:</p>

<blockquote>
  <p>Today I got email about some information in <em>Effective Modern C++</em>. The email included the statement, “An expression never has reference type.” This is easily shown to be incorrect, but people assert it to me often enough that I’m writing this blog entry so that I can refer people to it in the future.</p>

  <p>Section 5/5 of the Standard is quite clear (I’ve put the relevant text in bold):</p>

  <blockquote>
    <p><strong>If an expression initially has the type “reference to T”</strong> (8.3.2, 8.5.3), the type is adjusted to T prior to any further analysis. The expression designates the object or function denoted by the reference, and the expression is an lvalue or an xvalue, depending on the expression.</p>
  </blockquote>

  <p>There’d clearly be no need for this part of the Standard if expressions couldn’t have reference type.</p>

  <p>If that’s not enough to settle the matter, consider the type of an expression that consists of a function call. For example:</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        int&amp; f();                // f returns int&amp;
        auto x = f();            // a call to f
        
</code></pre></div>  </div>

  <p>What is the type of the expression “f()”, i.e., the type of the expression consisting of a call to f? It’s hard to imagine anybody arguing that it’s not int&amp;, i.e., a reference type. But what does the Standard say? Per 5.2.2/3 (where I’ve again put the relevant text in bold and where I’m grateful to Marcel Wid for correcting the error I had in an earlier version of this post that referred to 5.2.2/10):</p>

  <blockquote>
    <p>If the <em>postfix-expression</em> designates a destructor (12.4), the type of the function call expression is void; otherwise, <strong>the type of the function call expression is the return type of the statically chosen function</strong> (i.e., ignoring the virtual keyword), even if the type of the function actually called is different. This return type shall be an object type, <strong>a reference type</strong> or cv void.</p>
  </blockquote>

  <p>It’s very clear that expressions can have reference type. Section 5/5 takes those expressions and strips the reference-ness off of them before doing anything else, but that’s not the same as the reference-ness never being present in the first place.</p>
</blockquote>

<h2 id="value-category">Value Category</h2>

<p><a href="https://en.cppreference.com/w/cpp/language/value_category">C++ value_category</a></p>

<blockquote>
  <p>With the introduction of move semantics in C++11, value categories were redefined to characterize two independent properties of expressions[<a href="https://en.cppreference.com/w/cpp/language/value_category#cite_note-5">5]</a>:</p>

  <ul>
    <li><em>has identity</em>: it’s possible to determine whether the expression refers to the same entity as another expression, such as by comparing addresses of the objects or the functions they identify (obtained directly or indirectly);</li>
    <li><em>can be moved from</em>: <a href="https://en.cppreference.com/w/cpp/language/move_constructor">move constructor</a>, <a href="https://en.cppreference.com/w/cpp/language/move_assignment">move assignment operator</a>, or another function overload that implements move semantics can bind to the expression.</li>
  </ul>

  <p>In C++11, expressions that:</p>

  <ul>
    <li>have identity and cannot be moved from are called <em>lvalue</em> expressions;</li>
    <li>have identity and can be moved from are called <em>xvalue</em> expressions;</li>
    <li>do not have identity and can be moved from are called <em>prvalue</em> (“pure rvalue”) expressions;</li>
    <li>do not have identity and cannot be moved from are not used[<a href="https://en.cppreference.com/w/cpp/language/value_category#cite_note-6">6]</a>.</li>
  </ul>

  <p>The expressions that have identity are called “glvalue expressions” (glvalue stands for “generalized lvalue”). Both lvalues and xvalues are glvalue expressions.</p>

  <p>The expressions that can be moved from are called “rvalue expressions”. Both prvalues and xvalues are rvalue expressions.</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   ______ ______

  /      X      \

 /      / \      \

|   l  | x |  pr  |

 \      \ /      /

  \______X______/

​      gl    r
</code></pre></div></div>

<p>Above diagram describes the general relationship between <em>lvalue</em>(l), <em>xvalue</em>(x), <em>prvalue</em>(pr), <em>glvalue</em>(gl), <em>rvalue</em>(r)</p>

<h2 id="type-vs-valuecategory">Type vs ValueCategory</h2>

<p>Lvalueness or rvalueness of an expression is independent of its type, it’s possible to have lvalues whose type is rvalue reference, and it’s also possible to have rvalues of the type rvalue reference. See examples from <a href="https://github.com/shan-weiqiang/cplusplus/blob/main/expression/universal-references-and-reference-collapsing-scott-meyers.pdf">Universal References in C++11, Scott Meyers</a>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Widget</span> <span class="nf">makeWidget</span><span class="p">();</span>
 <span class="c1">// factory function for Widget</span>
<span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">var1</span> <span class="o">=</span> <span class="n">makeWidget</span><span class="p">()</span>
 <span class="c1">// var1 is an lvalue, but</span>
 <span class="c1">// its type is rvalue reference (to Widget)</span>
<span class="n">Widget</span> <span class="n">var2</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">var1</span><span class="p">);</span>
 <span class="c1">// the cast expression yields an rvalue, but</span>
 <span class="c1">// its type is rvalue reference (to Widget)</span>
</code></pre></div></div>

<p>Note that the valueness of expression <code class="language-plaintext highlighter-rouge">static_cast</code> is decided by <a href="https://en.cppreference.com/w/cpp/language/static_cast"><code class="language-plaintext highlighter-rouge">static_cast</code></a> itself:</p>

<blockquote>
  <p>As with all cast expressions, the result is:</p>

  <ul>
    <li>An lvalue if target-type is an lvalue reference type or an rvalue reference to function type(since C++11);</li>
    <li>A xvalue if target-type is an rvalue reference to object type; [swq: how <code class="language-plaintext highlighter-rouge">std::move</code> is implemented] (since C++11)</li>
    <li>A prvalue otherwise.</li>
  </ul>
</blockquote>

<h1 id="type-deduction">Type Deduction</h1>

<h2 id="deduction-context">Deduction context</h2>

<p>We consider two occasions where type deduction happens:</p>

<ul>
  <li><a href="(https://en.cppreference.com/w/cpp/language/template_argument_deduction).">Function template parameter type deduction</a></li>
  <li><code class="language-plaintext highlighter-rouge">auto</code></li>
</ul>

<p>Additionally, a special kind of type deduction, universal reference is considered.</p>

<p>During compile time compiler has mainly two ways to deduce template parameter types: from user and auto deduction. In the case of user input, whatever user specifies, compiler will use them. If user specified reference, reference collapsing rules apply. Also in C++ 17, class template parameter type can also be deduced: <a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">Class template argument deduction (CTAD) (since C++17)</a>.</p>

<h2 id="function-template-parameter-type-deduction">Function template parameter type deduction</h2>

<p>Note: Most content of this paragraph comes from the book: <em>Effective Modern C++, Scott Meyers</em>. I only copies them here to make this artical complete.</p>

<p>Take:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">ParamType</span> <span class="n">param</span><span class="p">);</span>
<span class="n">f</span><span class="p">(</span><span class="n">expr</span><span class="p">);</span> <span class="c1">// deduce T and ParamType from expr</span>

<span class="c1">// Above pseudo code can represent most cases, since reference, const are not allowed insdie parameter list: template&lt;typename const T&gt; and template&lt;typename T&amp;&gt; and template&lt;typename T&amp;&amp;&gt; are both not valid. However, when user specify T, const and reference types can be used and reference collapsing rules apply.</span>
</code></pre></div></div>

<p>Note: <code class="language-plaintext highlighter-rouge">typename</code> can only be <code class="language-plaintext highlighter-rouge">class</code>, or <code class="language-plaintext highlighter-rouge">typename</code>, no additional qualifiers are possible: <a href="https://en.cppreference.com/w/cpp/language/template_parameters">type-parameter-key	-either typename or class</a></p>

<ul>
  <li>Case 1: ParamType is a Reference or Pointer, but not a Universal Reference
    <ul>
      <li>If expr’s type is a reference, ignore the reference part</li>
      <li>Then pattern-match expr’s type against ParamType to determine T.</li>
    </ul>
  </li>
  <li>Case 2: ParamType is a Universal Reference
    <ul>
      <li>If expr is an lvalue, both T and ParamType are deduced to be lvalue references. That’s doubly unusual. First, it’s the only situation in  template type deduction where T is deduced to be a reference. Second, although ParamType is declared using the syntax for an rvalue reference, its deduced type is an lvalue reference.</li>
      <li>If expr is an rvalue, the “normal” (i.e., Case 1) rules apply.</li>
    </ul>
  </li>
  <li>Case 3: ParamType is Neither a Pointer nor a Reference
    <ul>
      <li>As before, if expr’s type is a reference, ignore the reference part</li>
      <li>If, after ignoring expr’s reference-ness, expr is const, ignore that, too. If it’s volatile, also ignore that.</li>
    </ul>
  </li>
</ul>

<h2 id="auto-deduction">auto deduction</h2>

<p>It’s essentially the same as function template parameter type deduction like above, the mappings relationships are:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">auto</code> –&gt; <code class="language-plaintext highlighter-rouge">T</code></li>
  <li>Expression before <code class="language-plaintext highlighter-rouge">=</code> –&gt; <code class="language-plaintext highlighter-rouge">ParamType</code></li>
  <li>Expression after <code class="language-plaintext highlighter-rouge">=</code> –&gt; <code class="language-plaintext highlighter-rouge">expr</code></li>
</ul>

<p>For example:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span> <span class="c1">// case 3 (x is neither ptr nor reference)</span>
<span class="k">const</span> <span class="k">auto</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// case 3 (cx isn't either)</span>
<span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// case 1 (rx is a non-universal ref.)</span>
<span class="c1">// T --&gt; auto; const auto&amp; --&gt; ParamType; x --&gt; expr</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">auto</code> can also be used in lamda and support universal reference:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="c1">// Default constructor</span>
  <span class="n">A</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Default constructor called</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Destructor</span>
  <span class="o">~</span><span class="n">A</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Destructor called</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Copy constructor</span>
  <span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Copy constructor called</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Move constructor</span>
  <span class="n">A</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Move constructor called</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Copy assignment operator</span>
  <span class="n">A</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Copy assignment operator called</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Move assignment operator</span>
  <span class="n">A</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Move assignment operator called</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
                <span class="c1">// e is of lvalue, copy contructor called</span>
                <span class="c1">// Note: e is not expression here, decltype get the real type of</span>
                <span class="c1">// e, for universal reference, it's either non-reference type or</span>
                <span class="c1">// lvalue reference type</span>
                <span class="p">[](</span><span class="k">auto</span> <span class="o">&amp;&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">);</span> <span class="p">});</span>

  <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_move_iterator</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">()),</span>
                <span class="n">std</span><span class="o">::</span><span class="n">make_move_iterator</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">()),</span>
                <span class="c1">// e is of xvalue, move contructor called</span>
                <span class="c1">// Note: e is not expression here, decltype get the real type of</span>
                <span class="c1">// e, for universal reference, it's either non-reference type or</span>
                <span class="c1">// lvalue reference type</span>
                <span class="p">[](</span><span class="k">auto</span> <span class="o">&amp;&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">);</span> <span class="p">});</span>
<span class="p">}</span>

</code></pre></div></div>

<h2 id="more-about-universal-reference">More about Universal Reference</h2>

<p><a href="https://github.com/shan-weiqiang/cplusplus/blob/main/expression/universal-references-and-reference-collapsing-scott-meyers.pdf">Universal References in C++11, Scott Meyers</a></p>

<h3 id="reference-collapsing-rules">Reference Collapsing Rules</h3>

<p><a href="https://en.cppreference.com/w/cpp/language/reference">C++ Reference</a></p>

<ul>
  <li>An rvalue reference to an rvalue reference becomes (‘collapses into’) an rvalue reference.</li>
  <li>All other references to references (i.e., all combinations involving an lvalue reference) collapse into an lvalue reference.</li>
</ul>

<h3 id="key-points--golden-rules">Key Points &amp; Golden Rules</h3>

<ul>
  <li>Remember that “&amp;&amp;” indicates a universal reference only where type deduction takes place.  Where there’s no type deduction, there’s no universal reference.  In such cases, “&amp;&amp;” in type declarations always means rvalue reference.</li>
  <li>Apply std::move to rvalue references and std::forward to universal references</li>
  <li>Only use std::forward with universal references</li>
  <li><strong>Universal reference type deduction is the only situation a template parameter is deduced as reference(when passed type is of lvalue).</strong></li>
</ul>

<h3 id="stdforward-explained">std::forward explained</h3>

<p><a href="https://en.cppreference.com/w/cpp/utility/forward">std::forward</a></p>

<ul>
  <li>Only use <code class="language-plaintext highlighter-rouge">std::forward</code> with universal reference. So the template argument for it should always be deduced, instead of specified.
    <ul>
      <li>This implies that the deduced type T is either non-reference type or a lvalue reference.</li>
      <li>Always use universal reference template paramter <code class="language-plaintext highlighter-rouge">T</code> <strong>directly</strong> for <code class="language-plaintext highlighter-rouge">std::forward</code>’s template paramters, do not manually add additional const/reference to it. Note that <code class="language-plaintext highlighter-rouge">T</code> can be decorated: like <code class="language-plaintext highlighter-rouge">forward&lt;decltype(forward&lt;T&gt;(arg).get())&gt;</code>, as long as <code class="language-plaintext highlighter-rouge">T</code> itself is the same as the universal reference.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">std::forward</code> is an <em>expression</em> and <em>function</em>, it’s value category conform to normal C++ expression rules. It always return <em>reference</em>:
    <ul>
      <li>When return lvalue reference, its value category is lvalue</li>
      <li>When return rvalue reference, its value category is rvalue(xvalue or prvalue)</li>
      <li>Above behavior is due to the fact that when cast to rvalue reference, the result of <code class="language-plaintext highlighter-rouge">static_cast</code> is of xvalue; when cast to non-reference, the result is of prvalue; when cast to lvalue reference, the result is of lvalue.</li>
    </ul>
  </li>
  <li>The type and valueness is decided by <code class="language-plaintext highlighter-rouge">static_cast</code>, which is the internal implementation of <code class="language-plaintext highlighter-rouge">std::forward</code></li>
</ul>

<p>The standard implements <code class="language-plaintext highlighter-rouge">std::forward</code>:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cm">/**
   *  @brief  Forward an lvalue.
   *  @return The parameter cast to the specified type.
   *
   *  This function is used to implement "perfect forwarding".
   */</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Tp</span><span class="p">&gt;</span>
    <span class="k">constexpr</span> <span class="n">_Tp</span><span class="o">&amp;&amp;</span>
    <span class="n">forward</span><span class="p">(</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;</span> <span class="n">__t</span><span class="p">)</span> <span class="k">noexcept</span>
    <span class="p">{</span> <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">__t</span><span class="p">);</span> <span class="p">}</span>

  <span class="cm">/**
   *  @brief  Forward an rvalue.
   *  @return The parameter cast to the specified type.
   *
   *  This function is used to implement "perfect forwarding".
   */</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Tp</span><span class="p">&gt;</span>
    <span class="k">constexpr</span> <span class="n">_Tp</span><span class="o">&amp;&amp;</span>
    <span class="n">forward</span><span class="p">(</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;&amp;</span> <span class="n">__t</span><span class="p">)</span> <span class="k">noexcept</span>
    <span class="p">{</span>
      <span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_lvalue_reference</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="s">"template argument"</span>
		    <span class="s">" substituting _Tp is an lvalue reference type"</span><span class="p">);</span>
      <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">__t</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">_Tp</code> is the type deduced from universal references, which might be non-reference type or lvalue reference type. <code class="language-plaintext highlighter-rouge">__t</code> is the parameter passed to <code class="language-plaintext highlighter-rouge">std::forward</code>, which is of lvalue category, since inside function, parameters are passed always as lvalues. The aim of <code class="language-plaintext highlighter-rouge">std::forward</code> is to restore the value category of the passed parameter:</p>

<ul>
  <li>When <code class="language-plaintext highlighter-rouge">_Tp</code> is of non-reference type, which means the universal reference is deduced based on passed rvalue parameter:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">__t</code> is of <code class="language-plaintext highlighter-rouge">_Tp&amp;&amp;</code> type, the second overload is used, <code class="language-plaintext highlighter-rouge">std::forward</code> return rvalue category, rvalue reference type object</li>
    </ul>
  </li>
  <li>When <code class="language-plaintext highlighter-rouge">_Tp</code> is of lvalue reference type, which means the universal reference is deduced based on passed lvalue parameter:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">__t</code> is of <code class="language-plaintext highlighter-rouge">_Tp&amp;</code> type, the first overload is used, <code class="language-plaintext highlighter-rouge">std::forward</code> return lvalue category, lvalue reference type object</li>
    </ul>
  </li>
</ul>

<p>Note: <strong>Type is not changed when parameters are passed down to nested function calls, only value category are changed. This is how <code class="language-plaintext highlighter-rouge">std:forward</code> do overload based on types</strong></p>

<p>Usage1: Forwards lvalues as either lvalues or as rvalues, depending on T:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// arg is always lvalue</span>
    <span class="n">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg</span><span class="p">));</span> <span class="c1">// Forward as lvalue or as rvalue, depending on T</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>When T is deduced to non-reference type,the expression <code class="language-plaintext highlighter-rouge">std::forward</code> is of:
    <ul>
      <li>type: rvalue reference to T</li>
      <li>value category: rvalue</li>
    </ul>
  </li>
  <li>When T is deduced to lvalue reference type, the expression <code class="language-plaintext highlighter-rouge">std::forward</code> is of:
    <ul>
      <li>type: lvalue reference to T</li>
      <li>value category: lvalue</li>
    </ul>
  </li>
</ul>

<p>Note: <strong>This usage is to restore the value category of the passed parameter, whose valueness, due to the nested argument passing, is all treated as lvalue category.</strong></p>

<p>Usage2: Forwards rvalues as rvalues and prohibits forwarding of rvalues as lvalues.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Arg</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span>  <span class="n">get</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// call to this overload is rvalue</span>
    <span class="kt">int</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="o">&amp;</span>  <span class="p">{</span> <span class="k">return</span> <span class="n">i</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// call to this overload is lvalue</span>
<span class="p">};</span>
<span class="c1">// transforming wrapper</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">foo</span><span class="p">(</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg</span><span class="p">).</span><span class="n">get</span><span class="p">())</span><span class="o">&gt;</span><span class="p">(</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg</span><span class="p">).</span><span class="n">get</span><span class="p">()));</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">decltype(forward&lt;T&gt;(arg).get())</code> evalues the type:
    <ul>
      <li>If T is deduced to non-reference type, the expression <code class="language-plaintext highlighter-rouge">forward&lt;T&gt;(arg).get()</code> will have type <code class="language-plaintext highlighter-rouge">int</code> and have xvalueness. <code class="language-plaintext highlighter-rouge">decltype</code> will result in type <code class="language-plaintext highlighter-rouge">int&amp;&amp;</code></li>
      <li>If T is deduced to lvalue reference type, the expression <code class="language-plaintext highlighter-rouge">forward&lt;T&gt;(arg).get()</code> will have type <code class="language-plaintext highlighter-rouge">int&amp;</code> and have lvalueness. <code class="language-plaintext highlighter-rouge">decltype</code> will result int type <code class="language-plaintext highlighter-rouge">int&amp;</code></li>
    </ul>
  </li>
  <li>The second appearance of <code class="language-plaintext highlighter-rouge">forward&lt;T&gt;(arg).get()</code> just call proper implementation of <code class="language-plaintext highlighter-rouge">get()</code></li>
</ul>

<p>Note: when using <code class="language-plaintext highlighter-rouge">decltype</code> as parameter argument to <code class="language-plaintext highlighter-rouge">std::forward</code>, we only need to care about whether the expression in <code class="language-plaintext highlighter-rouge">decltype</code> is lvalue or rvalue, no need to care about the type(only need to know the non-reference type of T). Since if the expression is lvalue, <code class="language-plaintext highlighter-rouge">decltype</code> will result in lvalue reference type, which result in lvalue reference type(lvalueness) for the <code class="language-plaintext highlighter-rouge">std::forward</code>. Otherwise, if the expression inside <code class="language-plaintext highlighter-rouge">decltype</code> is of xvalue or prvalue, <code class="language-plaintext highlighter-rouge">decltype</code> results in non-reference type or rvalue reference type, which both result in a rvalue reference type(rvalueness) for the <code class="language-plaintext highlighter-rouge">std::forward</code> expression. <code class="language-plaintext highlighter-rouge">decltype</code> and <code class="language-plaintext highlighter-rouge">std::forward</code> together to pass the valueness down to nested function calls.</p>

<p>Note: If we use <code class="language-plaintext highlighter-rouge">foo(forward&lt;int&amp;&gt;(forward&lt;T&gt;(arg).get()));</code> and pass a rvalue of <code class="language-plaintext highlighter-rouge">Arg</code> instance to <code class="language-plaintext highlighter-rouge">wrapper</code>, there will be compile time error, since we try to forward rvalue as lvalue(the valueness of the return of <code class="language-plaintext highlighter-rouge">std::forward</code>).</p>

<p><code class="language-plaintext highlighter-rouge">std::forward</code> can be used together with <code class="language-plaintext highlighter-rouge">auto&amp;&amp;</code> in lambdas, which needs the help of <code class="language-plaintext highlighter-rouge">decltype</code> to infer the correct type:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="p">{</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"b"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">};</span>

  <span class="c1">//   This is totally generic</span>
  <span class="k">auto</span> <span class="n">forwarder</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span> <span class="o">&amp;&amp;</span><span class="n">container</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// If container is of lvalue, it's type is lvalue reference type, decltype</span>
    <span class="c1">// return lvalue reference.</span>
    <span class="c1">// If container is of rvalue, it's type is rvalue reference type, decltype</span>
    <span class="c1">// return rvalue reference</span>
    <span class="k">auto</span> <span class="n">dest</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">container</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="n">forwarder</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">source</span><span class="p">));</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">source</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">source2</span> <span class="o">=</span> <span class="p">{</span><span class="s">"x"</span><span class="p">,</span> <span class="s">"y"</span><span class="p">,</span> <span class="s">"z"</span><span class="p">};</span>
  <span class="n">forwarder</span><span class="p">(</span><span class="n">source2</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">source2</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>

<p>However, using of <code class="language-plaintext highlighter-rouge">std::forward</code> in range-based for loop with <code class="language-plaintext highlighter-rouge">auto&amp;&amp;</code> will not work as expected:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="p">{</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"b"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">};</span>

  <span class="c1">//   item is std::string&amp; type, even with std::move</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;&amp;</span><span class="n">item</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">source</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// After std::forward the return  type is still std::string&amp;</span>
    <span class="k">auto</span> <span class="n">dst</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>

<p>In above code snippet, <code class="language-plaintext highlighter-rouge">std::move(source)</code> will not trigger move operation for <code class="language-plaintext highlighter-rouge">source</code> and <code class="language-plaintext highlighter-rouge">item</code> is of lvalue category and lvalue reference type. This behavior can be explained by looking at the internal <a href="https://en.cppreference.com/w/cpp/language/range-for">implementation of range-based for</a> in C++:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="p">{</span>

<span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="cm">/* range */</span> <span class="o">=</span> <span class="n">range</span><span class="o">-</span><span class="n">initializer</span><span class="err"> ﻿</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="cm">/* begin */</span> <span class="o">=</span> <span class="cm">/* begin-expr */</span><span class="p">,</span> <span class="cm">/* end */</span> <span class="o">=</span> <span class="cm">/* end-expr */</span><span class="p">;</span>
<span class="cm">/* begin */</span> <span class="o">!=</span> <span class="cm">/* end */</span><span class="p">;</span> <span class="o">++</span><span class="cm">/* begin */</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">item</span><span class="o">-</span><span class="n">declaration</span> <span class="o">=</span> <span class="err">*/</span><span class="o">*</span> <span class="n">begin</span> <span class="err">*/</span><span class="p">;</span>
<span class="n">statement</span>
<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>First the <code class="language-plaintext highlighter-rouge">auto&amp;&amp;</code> universal reference is used to create a local variable, which is itself a lvalue</li>
  <li>Then use iterator to iterate over this lvalue and dereference this lvalue and create a local variable using <code class="language-plaintext highlighter-rouge">item-declaration</code>, which is the user specified <code class="language-plaintext highlighter-rouge">auto &amp;&amp;item</code></li>
  <li><code class="language-plaintext highlighter-rouge">auto &amp;&amp;item</code> will always be deduced as lvalue reference</li>
  <li>If <code class="language-plaintext highlighter-rouge">auto item</code> is used, <code class="language-plaintext highlighter-rouge">item</code> will be a copy, and the original <code class="language-plaintext highlighter-rouge">const</code> qualifier will be removed</li>
</ul>

<p>To iterate and move element out of a container, move iterators can be used:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="p">{</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"b"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">};</span>

  <span class="c1">//   This will move the element</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_move_iterator</span><span class="p">(</span><span class="n">source</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
       <span class="n">it</span> <span class="o">!=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_move_iterator</span><span class="p">(</span><span class="n">source</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">dst</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>

<h1 id="named-variables">Named Variables</h1>

<p>Named variables and parameters of rvalue reference type are lvalues. Also from <a href="https://github.com/shan-weiqiang/cplusplus/blob/main/expression/universal-references-and-reference-collapsing-scott-meyers.pdf">Universal References in C++11, Scott Meyers</a>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
 <span class="p">...</span>
 <span class="n">Widget</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">);</span>
 <span class="c1">// rhs's type is rvalue reference, but rhs</span>
 <span class="c1">// itself is an lvalue</span>
 <span class="p">...</span>
<span class="p">};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T1</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Gadget</span> <span class="p">{</span>
 <span class="p">...</span>
 <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T2</span><span class="p">&gt;</span>
 <span class="n">Gadget</span><span class="p">(</span><span class="n">T2</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">);</span>
 <span class="c1">// rhs is a universal reference whose type will</span>
 <span class="c1">// eventually become an rvalue reference or an</span>
 <span class="c1">// lvalue reference, but rhs itself is an lvalue</span>
 <span class="p">...</span>
<span class="p">};</span>
</code></pre></div></div>

<p>To create rvalue, <code class="language-plaintext highlighter-rouge">std::move</code>, <code class="language-plaintext highlighter-rouge">std::forward</code>, <code class="language-plaintext highlighter-rouge">static_cast</code> specifier has to be used:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="c1">// Default constructor</span>
  <span class="n">A</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Default constructor called</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Destructor</span>
  <span class="o">~</span><span class="n">A</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Destructor called</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Copy constructor</span>
  <span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Copy constructor called</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Move constructor</span>
  <span class="n">A</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Move constructor called</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Copy assignment operator</span>
  <span class="n">A</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Copy assignment operator called</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Move assignment operator</span>
  <span class="n">A</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Move assignment operator called</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

  <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">A</span> <span class="o">&amp;&amp;</span><span class="n">b</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>

  <span class="c1">// ! This will call copy constructor, NOT move constructor, even b is rvalue</span>
  <span class="c1">// reference type, but it's lvalue</span>
  <span class="n">A</span> <span class="n">c</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

  <span class="c1">// ! This will call move constructor</span>
  <span class="n">A</span> <span class="n">d</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="decltype">decltype</h1>

<p><a href="https://en.cppreference.com/w/cpp/language/decltype">C++ decltype</a></p>

<p>Inspects the declared type of an entity or the type and value category of an expression.
This implies two funtionality of decltype:</p>

<ol>
  <li>When used as decltype ( entity ), where entity is unparenthesized id-expression or class memeber expression, it yields
the type of entity</li>
  <li>When used as decltype ( expression ), where expression is any other expression, it inspects the expression’s
value type(eg,T) and value category and yields following types accordingly:</li>
</ol>

<ul>
  <li>if value category of expression is xvalue, it yields T&amp;&amp;</li>
  <li>if value category of expression is lvalue, it yields T&amp;</li>
  <li>if value category of expression is prvalue, it yields T</li>
</ul>

<p>Note: if variable id-expression or class memeber access expression is parenthesized, it is treated as ordinary lvalue
expression(which is reasonable, because named variables are always lvalue expressions)</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{};</span>
<span class="n">Widget</span> <span class="nf">makeWidget</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Widget</span><span class="p">();</span> <span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

  <span class="n">Widget</span> <span class="o">&amp;&amp;</span><span class="n">var1</span> <span class="o">=</span> <span class="n">makeWidget</span><span class="p">();</span>
  <span class="c1">// var1 is an lvalue, but</span>
  <span class="c1">// its type is rvalue reference (to Widget)</span>
  <span class="n">Widget</span> <span class="n">var2</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Widget</span> <span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">var1</span><span class="p">);</span>
  <span class="c1">// the cast expression yields an rvalue, but</span>
  <span class="c1">// its type is rvalue reference (to Widget)</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Widget</span> <span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">var1</span><span class="p">))</span> <span class="n">var3</span> <span class="o">=</span> <span class="n">makeWidget</span><span class="p">();</span>
  <span class="c1">//   expression type is Widget &amp;&amp;, value category of expression is xvalue,</span>
  <span class="c1">//   first get the non-reference type Widget, so var3 is of Widget&amp;&amp; type.</span>
  <span class="n">Widget</span> <span class="o">&amp;</span><span class="n">var4</span> <span class="o">=</span> <span class="n">var2</span><span class="p">;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">var4</span><span class="p">))</span> <span class="n">var5</span> <span class="o">=</span> <span class="n">makeWidget</span><span class="p">();</span>
  <span class="c1">// expression type is Widget &amp;, value category of expression is xvalue; first</span>
  <span class="c1">// get the non-reference type Widget, so var5 is of Widget &amp;&amp; type</span>

  <span class="k">decltype</span><span class="p">((</span><span class="n">var4</span><span class="p">))</span> <span class="n">var6</span> <span class="o">=</span> <span class="n">var2</span><span class="p">;</span>
  <span class="c1">// expression type is Widget &amp;, value category of expression is lvalue; first</span>
  <span class="c1">// get the non-reference type Widget, so var6 is of Widget &amp; type</span>

  <span class="k">decltype</span><span class="p">(</span><span class="n">makeWidget</span><span class="p">())</span> <span class="n">var7</span> <span class="o">=</span> <span class="n">makeWidget</span><span class="p">();</span>
  <span class="c1">// expression type is Widget , value category of expression is prvalue; first</span>
  <span class="c1">// get the non-reference type Widget, so var6 is of Widget  type</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note: When doing all deduction the expression type <code class="language-plaintext highlighter-rouge">T</code> will use the non-reference version, since as the standard says:</p>

<blockquote>
  <p>If an expression initially has the type “reference to T” (8.3.2, 8.5.3), the type is adjusted to T prior to any further analysis.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">decltype</code> links valueness of an expression to type.</strong></p>

<h2 id="print-valueness">Print valueness</h2>

<p>First approach, we can check whether the yield type of decltype(expression) is lvalue or rvalue reference, if rvalue
reference, the expression is xvalue; if lvalue reference, the expression is lvalue; otherwise, the expression is prvalue</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="c1"> // for std::move</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Widget</span> <span class="p">{};</span>
<span class="n">Widget</span> <span class="nf">makeWidget</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Widget</span><span class="p">();</span> <span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">value_category</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s">"prvalue"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">value_category</span><span class="o">&lt;</span><span class="n">T</span> <span class="o">&amp;&gt;</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s">"lvalue"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">value_category</span><span class="o">&lt;</span><span class="n">T</span> <span class="o">&amp;&amp;&gt;</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s">"xvalue"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Macro to check the value category of an expression</span>
<span class="cp">#define PRINT_VALUE_CATEGORY(expr)                                             \
  std::cout &lt;&lt; "The expression '" #expr "' is a "                              \
            &lt;&lt; value_category&lt;decltype((expr))&gt;::str() &lt;&lt; std::endl;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Widget</span> <span class="o">&amp;&amp;</span><span class="n">var1</span> <span class="o">=</span> <span class="n">makeWidget</span><span class="p">();</span>
  <span class="n">Widget</span> <span class="n">var2</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Widget</span> <span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">var1</span><span class="p">);</span>
  <span class="n">Widget</span> <span class="o">&amp;</span><span class="n">var4</span> <span class="o">=</span> <span class="n">var2</span><span class="p">;</span>

  <span class="n">PRINT_VALUE_CATEGORY</span><span class="p">(</span><span class="n">var1</span><span class="p">);</span>                         <span class="c1">// lvalue</span>
  <span class="n">PRINT_VALUE_CATEGORY</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Widget</span> <span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">var1</span><span class="p">));</span> <span class="c1">// xvalue</span>
  <span class="n">PRINT_VALUE_CATEGORY</span><span class="p">(</span><span class="n">var4</span><span class="p">);</span>                         <span class="c1">// lvalue</span>
  <span class="n">PRINT_VALUE_CATEGORY</span><span class="p">((</span><span class="n">var4</span><span class="p">));</span>                       <span class="c1">// lvalue</span>
  <span class="n">PRINT_VALUE_CATEGORY</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">var4</span><span class="p">));</span>              <span class="c1">// xvalue</span>
  <span class="n">PRINT_VALUE_CATEGORY</span><span class="p">(</span><span class="n">makeWidget</span><span class="p">());</span>                 <span class="c1">// prvalue</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="static_cast-vs-decltype">static_cast vs decltype</h1>

<p>Let’s compare <code class="language-plaintext highlighter-rouge">static_cast</code> and <code class="language-plaintext highlighter-rouge">decltype</code>:</p>

<p>With <code class="language-plaintext highlighter-rouge">static_cast</code>:</p>

<blockquote>
  <p>As with all cast expressions, the result is:</p>

  <ul>
    <li>An lvalue if target-type is an lvalue reference type or an rvalue reference to function type(since C++11);</li>
    <li>A xvalue if target-type is an rvalue reference to object type; [swq: how <code class="language-plaintext highlighter-rouge">std::move</code> is implemented] (since C++11)</li>
    <li>A prvalue otherwise.(non-reference type)</li>
  </ul>
</blockquote>

<p>With <code class="language-plaintext highlighter-rouge">decltype</code>:</p>

<blockquote>
  <ul>
    <li>if value category of expression is xvalue, it yields T&amp;&amp;</li>
    <li>if value category of expression is lvalue, it yields T&amp;</li>
    <li>if value category of expression is prvalue, it yields T</li>
  </ul>
</blockquote>

<p>They do reverse operations:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">static_cast</code> sets the type/value category (via the target type).</li>
  <li><code class="language-plaintext highlighter-rouge">decltype</code> infers the type/value category (from the expression).</li>
</ul>

<h1 id="declval">declval</h1>

<p><a href="https://en.cppreference.com/w/cpp/utility/declval">C++ declval</a></p>

<p><code class="language-plaintext highlighter-rouge">declval</code> can return a reference to a type, <strong>without going through actual construction</strong>.</p>

<p>Implementation:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">add_rvalue_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span> <span class="nf">declval</span><span class="p">()</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="nb">false</span><span class="p">,</span> <span class="s">"declval not allowed in an evaluated context"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>What <code class="language-plaintext highlighter-rouge">declval</code> does is simply add rvalue reference to type <code class="language-plaintext highlighter-rouge">T</code></li>
  <li>The <code class="language-plaintext highlighter-rouge">static_cast</code> statement make sure that it can only be used in <code class="language-plaintext highlighter-rouge">unevaluated</code> context, like inside <code class="language-plaintext highlighter-rouge">decltype</code></li>
</ul>

<p><a href="https://stackoverflow.com/questions/20303250/is-there-a-reason-declval-returns-add-rvalue-reference-instead-of-add-lvalue-ref/20303350#20303350">Why add rvalue reference, instead of lvalue reference?</a></p>

<p>The reason is related to reference collapsing rules: only by adding rvalue reference, <code class="language-plaintext highlighter-rouge">declval</code> might have the possibility return a rvalue reference, so as to have more possibility to call methods, such as methods that can only be called by rvalue.</p>


  </div><a class="u-url" href="/2025/02/28/cplusplus-expressions.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">shanweiqiang&#39;s blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">shanweiqiang&#39;s blog</li><li><a class="u-email" href="mailto:schmessi@163.com">schmessi@163.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/shan-weiqiang"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">shan-weiqiang</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
