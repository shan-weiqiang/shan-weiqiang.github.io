<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Programmer‘s guide to Rust | shanweiqiang’s blog</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="Programmer‘s guide to Rust" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This is my reading note of The Book of Rust. To learn Rust it’s best to compare it with one language that I am experienced with. For me it’s C++. Following are some key differences between Rust and C++, organized the same as the book’s chapter." />
<meta property="og:description" content="This is my reading note of The Book of Rust. To learn Rust it’s best to compare it with one language that I am experienced with. For me it’s C++. Following are some key differences between Rust and C++, organized the same as the book’s chapter." />
<link rel="canonical" href="http://localhost:4000/2023/08/12/C++-programmer's-guide-to-Rust.html" />
<meta property="og:url" content="http://localhost:4000/2023/08/12/C++-programmer's-guide-to-Rust.html" />
<meta property="og:site_name" content="shanweiqiang’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-08-12T19:22:46+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Programmer‘s guide to Rust" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-08-12T19:22:46+08:00","datePublished":"2023-08-12T19:22:46+08:00","description":"This is my reading note of The Book of Rust. To learn Rust it’s best to compare it with one language that I am experienced with. For me it’s C++. Following are some key differences between Rust and C++, organized the same as the book’s chapter.","headline":"Programmer‘s guide to Rust","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2023/08/12/C++-programmer's-guide-to-Rust.html"},"url":"http://localhost:4000/2023/08/12/C++-programmer's-guide-to-Rust.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="shanweiqiang&apos;s blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">shanweiqiang&#39;s blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/tags/">tags</a><a class="page-link" href="/about/">about</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Programmer‘s guide to Rust</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2023-08-12T19:22:46+08:00" itemprop="datePublished">Aug 12, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>This is my reading note of <em><a href="https://doc.rust-lang.org/book/title-page.html">The Book</a></em> of Rust. To learn Rust it’s best to compare it with one language that I am experienced with. For me it’s C++. Following are some key differences between Rust and C++, organized the same as the book’s chapter.</p>

<ul id="markdown-toc">
  <li><a href="#3-common-programming-concepts" id="markdown-toc-3-common-programming-concepts">3. Common Programming Concepts</a>    <ul>
      <li><a href="#31-variables-and-mutability" id="markdown-toc-31-variables-and-mutability">3.1 Variables and Mutability</a></li>
      <li><a href="#32-data-types" id="markdown-toc-32-data-types">3.2 Data Types</a></li>
      <li><a href="#33-functions" id="markdown-toc-33-functions">3.3 Functions</a></li>
      <li><a href="#35-control-flow" id="markdown-toc-35-control-flow">3.5 Control Flow</a></li>
    </ul>
  </li>
  <li><a href="#4--understanding-ownership" id="markdown-toc-4--understanding-ownership">4.  <strong>Understanding Ownership</strong></a>    <ul>
      <li><a href="#41-what-is-ownership" id="markdown-toc-41-what-is-ownership">4.1 <strong>What Is Ownership?</strong></a></li>
      <li><a href="#42-references-and-borrowing" id="markdown-toc-42-references-and-borrowing">4.2 <strong>References and Borrowing</strong></a></li>
      <li><a href="#43-the-slice-type" id="markdown-toc-43-the-slice-type">4.3 <strong>The Slice Type</strong></a></li>
    </ul>
  </li>
  <li><a href="#5-using-structs-to-structure-related-data" id="markdown-toc-5-using-structs-to-structure-related-data">5. <strong>Using Structs to Structure Related Data</strong></a>    <ul>
      <li><a href="#52-an-example-program-using-structs" id="markdown-toc-52-an-example-program-using-structs">5.2 <strong>An Example Program Using Structs</strong></a></li>
      <li><a href="#53-method-syntax" id="markdown-toc-53-method-syntax">5.3 Method Syntax</a></li>
    </ul>
  </li>
  <li><a href="#6-enums-and-pattern-matching" id="markdown-toc-6-enums-and-pattern-matching">6. <strong>Enums and Pattern Matching</strong></a>    <ul>
      <li><a href="#61-defining-an-enum" id="markdown-toc-61-defining-an-enum">6.1 <strong>Defining an Enum</strong></a></li>
      <li><a href="#62-thematchcontrol-flow-construct" id="markdown-toc-62-thematchcontrol-flow-construct">6.2 <strong>The <code class="language-plaintext highlighter-rouge">match</code> Control Flow Construct</strong></a></li>
      <li><a href="#63-concise-control-flow-withif-let" id="markdown-toc-63-concise-control-flow-withif-let">6.3 <strong>Concise Control Flow with <code class="language-plaintext highlighter-rouge">if let</code></strong></a></li>
    </ul>
  </li>
  <li><a href="#7-managing-growing-projects-with-packages-crates-and-modules" id="markdown-toc-7-managing-growing-projects-with-packages-crates-and-modules">7. <strong>Managing Growing Projects with Packages, Crates, and Modules</strong></a></li>
  <li><a href="#8-common-collections" id="markdown-toc-8-common-collections">8. <strong>Common Collections</strong></a>    <ul>
      <li><a href="#81-storing-lists-of-values-with-vectors" id="markdown-toc-81-storing-lists-of-values-with-vectors">8.1 <strong>Storing Lists of Values with Vectors</strong></a></li>
      <li><a href="#82-storing-utf-8-encoded-text-with-strings" id="markdown-toc-82-storing-utf-8-encoded-text-with-strings">8.2 <strong>Storing UTF-8 Encoded Text with Strings</strong></a></li>
      <li><a href="#83-storing-keys-with-associated-values-in-hash-maps" id="markdown-toc-83-storing-keys-with-associated-values-in-hash-maps">8.3 <strong>Storing Keys with Associated Values in Hash Maps</strong></a></li>
    </ul>
  </li>
  <li><a href="#9-error-handling" id="markdown-toc-9-error-handling">9. <strong>Error Handling</strong></a>    <ul>
      <li><a href="#91-unrecoverable-errors-withpanic" id="markdown-toc-91-unrecoverable-errors-withpanic">9.1 <strong>Unrecoverable Errors with <code class="language-plaintext highlighter-rouge">panic!</code></strong></a></li>
      <li><a href="#92-recoverable-errors-withresult" id="markdown-toc-92-recoverable-errors-withresult">9.2 <strong>Recoverable Errors with <code class="language-plaintext highlighter-rouge">Result</code></strong></a></li>
    </ul>
  </li>
  <li><a href="#10-generic-types-traits-and-lifetimes" id="markdown-toc-10-generic-types-traits-and-lifetimes">10. <strong>Generic Types, Traits, and Lifetimes</strong></a>    <ul>
      <li><a href="#101-generic-data-types" id="markdown-toc-101-generic-data-types">10.1 <strong>Generic Data Types</strong></a></li>
      <li><a href="#102-traits-defining-shared-behavior" id="markdown-toc-102-traits-defining-shared-behavior">10.2 <strong>Traits: Defining Shared Behavior</strong></a></li>
      <li><a href="#103-validating-references-with-lifetimes" id="markdown-toc-103-validating-references-with-lifetimes">10.3 <strong>Validating References with Lifetimes</strong></a></li>
    </ul>
  </li>
  <li><a href="#11-writing-automated-tests" id="markdown-toc-11-writing-automated-tests">11. <strong>Writing Automated Tests</strong></a>    <ul>
      <li><a href="#111-how-to-write-tests" id="markdown-toc-111-how-to-write-tests">11.1 <strong>How to Write Tests</strong></a></li>
      <li><a href="#113-test-organization" id="markdown-toc-113-test-organization">11.3 <strong>Test Organization</strong></a></li>
    </ul>
  </li>
  <li><a href="#13-functional-language-features-iterators-and-closures" id="markdown-toc-13-functional-language-features-iterators-and-closures">13. <strong>Functional Language Features: Iterators and Closures</strong></a>    <ul>
      <li><a href="#131-closures-anonymous-functions-that-capture-their-environment" id="markdown-toc-131-closures-anonymous-functions-that-capture-their-environment">13.1 <strong>Closures: Anonymous Functions that Capture Their Environment</strong></a></li>
      <li><a href="#132-processing-a-series-of-items-with-iterators" id="markdown-toc-132-processing-a-series-of-items-with-iterators">13.2 <strong>Processing a Series of Items with Iterators</strong></a></li>
    </ul>
  </li>
  <li><a href="#14-more-about-cargo-and-cratesio" id="markdown-toc-14-more-about-cargo-and-cratesio">14. <strong>More About Cargo and Crates.io</strong></a>    <ul>
      <li><a href="#143-cargo-workspaces" id="markdown-toc-143-cargo-workspaces">14.3 <strong>Cargo Workspaces</strong></a></li>
    </ul>
  </li>
  <li><a href="#15-smart-pointers" id="markdown-toc-15-smart-pointers">15. <strong>Smart Pointers</strong></a>    <ul>
      <li><a href="#151-usingboxtto-point-to-data-on-the-heap" id="markdown-toc-151-usingboxtto-point-to-data-on-the-heap">15.1 <strong>Using <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> to Point to Data on the Heap</strong></a></li>
      <li><a href="#152-treating-smart-pointers-like-regular-references-with-thedereftrait" id="markdown-toc-152-treating-smart-pointers-like-regular-references-with-thedereftrait">15.2 <strong>Treating Smart Pointers Like Regular References with the <code class="language-plaintext highlighter-rouge">Deref</code> Trait</strong></a></li>
      <li><a href="#153-running-code-on-cleanup-with-thedroptrait" id="markdown-toc-153-running-code-on-cleanup-with-thedroptrait">15.3 <strong>Running Code on Cleanup with the <code class="language-plaintext highlighter-rouge">Drop</code> Trait</strong></a></li>
      <li><a href="#154-rct-the-reference-counted-smart-pointerhttpsdocrust-langorgbookch15-04-rchtmlrct-the-reference-counted-smart-pointer" id="markdown-toc-154-rct-the-reference-counted-smart-pointerhttpsdocrust-langorgbookch15-04-rchtmlrct-the-reference-counted-smart-pointer">15.4 <strong><code class="language-plaintext highlighter-rouge">[Rc&lt;T&gt;</code>, the Reference Counted Smart Pointer](https://doc.rust-lang.org/book/ch15-04-rc.html#rct-the-reference-counted-smart-pointer)</strong></a></li>
      <li><a href="#155-refcelltand-the-interior-mutability-patternhttpsdocrust-langorgbookch15-05-interior-mutabilityhtmlrefcellt-and-the-interior-mutability-pattern" id="markdown-toc-155-refcelltand-the-interior-mutability-patternhttpsdocrust-langorgbookch15-05-interior-mutabilityhtmlrefcellt-and-the-interior-mutability-pattern">15.5 <strong><code class="language-plaintext highlighter-rouge">[RefCell&lt;T&gt;</code> and the Interior Mutability Pattern](https://doc.rust-lang.org/book/ch15-05-interior-mutability.html#refcellt-and-the-interior-mutability-pattern)</strong></a></li>
    </ul>
  </li>
  <li><a href="#16-fearless-concurrency" id="markdown-toc-16-fearless-concurrency">16. <strong>Fearless Concurrency</strong></a>    <ul>
      <li><a href="#161-using-threads-to-run-code-simultaneously" id="markdown-toc-161-using-threads-to-run-code-simultaneously">16.1 <strong>Using Threads to Run Code Simultaneously</strong></a></li>
      <li><a href="#162-using-message-passing-to-transfer-data-between-threads" id="markdown-toc-162-using-message-passing-to-transfer-data-between-threads">16.2 <strong>Using Message Passing to Transfer Data Between Threads</strong></a></li>
      <li><a href="#163-shared-state-concurrency" id="markdown-toc-163-shared-state-concurrency">16.3 <strong>Shared-State Concurrency</strong></a></li>
    </ul>
  </li>
  <li><a href="#17-object-oriented-programming-features-of-rust" id="markdown-toc-17-object-oriented-programming-features-of-rust">17. <strong>Object-Oriented Programming Features of Rust</strong></a>    <ul>
      <li><a href="#172-using-trait-objects-that-allow-for-values-of-different-types" id="markdown-toc-172-using-trait-objects-that-allow-for-values-of-different-types">17.2 <strong>Using Trait Objects That Allow for Values of Different Types</strong></a></li>
    </ul>
  </li>
  <li><a href="#19-advanced-features" id="markdown-toc-19-advanced-features">19. <strong>Advanced Features</strong></a>    <ul>
      <li><a href="#192-unsafe-rust" id="markdown-toc-192-unsafe-rust">19.2 <strong>Unsafe Rust</strong></a></li>
      <li><a href="#192-advanced-traits" id="markdown-toc-192-advanced-traits">19.2 <strong>Advanced Traits</strong></a></li>
      <li><a href="#193-advanced-types" id="markdown-toc-193-advanced-types">19.3 <strong>Advanced Types</strong></a></li>
      <li><a href="#194-advanced-functions-and-closures" id="markdown-toc-194-advanced-functions-and-closures">19.4 <strong>Advanced Functions and Closures</strong></a></li>
    </ul>
  </li>
</ul>

<h1 id="3-common-programming-concepts">3. Common Programming Concepts</h1>

<h2 id="31-variables-and-mutability">3.1 Variables and Mutability</h2>

<ul>
  <li>By default, all variables are immutable, which means that once they are initialized, they can not be changed</li>
  <li>Mutable variables must be explicitly declared:</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"The value of x is: {x}"</span><span class="p">);</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"The value of x is: {x}"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">const</code> and immutable differences:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">const</code> variable must be initialized at compile time, not at runtime
        <ul>
          <li>This is different from C++, in which const variables can be initialized at runtime</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Shadowing:
    <ul>
      <li>We can declare the same named variable again using <code class="language-plaintext highlighter-rouge">let</code> keyword, this variable will replace previous declaration, this is called shadowing</li>
      <li>Shadowing is not the same as variable reassignment:
        <ul>
          <li>Reassignment does not change the type of the variable, only change the value</li>
          <li>Shadowing can change the type of the variable, after shadowing, they are two different variables</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Initial value of x is: {x}"</span><span class="p">);</span>

    <span class="n">x</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Value after reassignment is: {x}"</span><span class="p">);</span>

    <span class="c1">// shadowing can chage the type</span>
    <span class="k">let</span> <span class="n">x</span><span class="p">:</span> <span class="nb">char</span> <span class="o">=</span> <span class="sc">'h'</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Value after shadowing, with char type is: {x}"</span><span class="p">);</span>

    <span class="p">{</span>
        <span class="c1">// shadowing in inner scope</span>
        <span class="k">let</span> <span class="n">x</span><span class="p">:</span> <span class="nb">char</span> <span class="o">=</span> <span class="sc">'c'</span><span class="p">;</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"The value of x in the inner scope is: {x}"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// inner scope shadowing does not influence outer scope</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"The value of x is: {x}"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="32-data-types">3.2 Data Types</h2>

<p>Most of the types are very similar with C/C++, following are some key differences:</p>

<ul>
  <li>Rust has integer type <code class="language-plaintext highlighter-rouge">isize</code> and <code class="language-plaintext highlighter-rouge">usize</code>, which is architecture dependent, for example 32 bits and 64bits system</li>
  <li>Numbers can be concatenated using <code class="language-plaintext highlighter-rouge">_</code> , such as <code class="language-plaintext highlighter-rouge">23_12</code></li>
  <li>Tuple type can contain different types and can be accessed using dot attribute</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">f64</span><span class="p">,</span> <span class="nb">u8</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="mf">6.4</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">five_hundred</span> <span class="o">=</span> <span class="n">x</span><span class="na">.0</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">six_point_four</span> <span class="o">=</span> <span class="n">x</span><span class="na">.1</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">one</span> <span class="o">=</span> <span class="n">x</span><span class="na">.2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Array type has bounds check at runtime, in C++ this is undefined behavior</li>
</ul>

<h2 id="33-functions">3.3 Functions</h2>

<ul>
  <li>Rust functions do not require first declaration, then use like C++, only require that function names can be accessed in the same name scope</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello, world!"</span><span class="p">);</span>

    <span class="nf">another_function</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">another_function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Another function."</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><em>statement</em> and <em>expression</em>
    <ul>
      <li><em>statement</em>: do not return a value, ends with comma <code class="language-plaintext highlighter-rouge">;</code></li>
      <li><em>expression</em>: return a value, do not ends with comma <code class="language-plaintext highlighter-rouge">;</code>
        <ul>
          <li>A new scope block created with curly brackets is an expression:</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// do not ends with ;</span>
    <span class="p">};</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"The value of y is: {y}"</span><span class="p">);</span> <span class="c1">// 4</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Most functions return the last expression <em>implicitly</em></li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">five</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="mi">5</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nf">five</span><span class="p">();</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"The value of x is: {x}"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="35-control-flow">3.5 Control Flow</h2>

<ul>
  <li>Rust do not do <em>implic</em>i<em>t</em> conversion to <em>bool</em> type like in C++; Conditions in Rust must be explicitly <em>bool</em> type</li>
  <li><code class="language-plaintext highlighter-rouge">if</code> <em>expression</em>:</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>

    <span class="k">if</span> <span class="n">number</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"number is divisible by 4"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">number</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"number is divisible by 3"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">number</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"number is divisible by 2"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"number is not divisible by 4, 3, or 2"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Because <code class="language-plaintext highlighter-rouge">if</code> is <em>expression</em>, it returns value, it can be used on the right side to assign some value to variables; Note: every condtion <em>must</em> return the same <em>type</em></li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">condition</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">number</span> <span class="o">=</span> <span class="k">if</span> <span class="n">condition</span> <span class="p">{</span> <span class="mi">5</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="mi">6</span> <span class="p">};</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"The value of number is: {number}"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">loop</code> <em>expression</em>:
    <ul>
      <li>Return value after <code class="language-plaintext highlighter-rouge">break</code></li>
      <li><code class="language-plaintext highlighter-rouge">loop</code> label to break any <em>labeled</em> loop</li>
    </ul>
  </li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nv">'counting_up</span><span class="p">:</span> <span class="k">loop</span> <span class="p">{</span> <span class="c1">// here is counting_up label, starts with '</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"count = {count}"</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">remaining</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

        <span class="k">loop</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"remaining = {remaining}"</span><span class="p">);</span>
            <span class="k">if</span> <span class="n">remaining</span> <span class="o">==</span> <span class="mi">9</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
                <span class="k">break</span> <span class="nv">'counting_up</span><span class="p">;</span> <span class="c1">// here from inner loop breaks outer loop</span>
            <span class="p">}</span>
            <span class="n">remaining</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"End count = {count}"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="k">loop</span> <span class="p">{</span>
        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">if</span> <span class="n">counter</span> <span class="o">==</span> <span class="mi">10</span> <span class="p">{</span>
            <span class="k">break</span> <span class="n">counter</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"The result is {result}"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">loop</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"again!"</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span> <span class="c1">// used to exit loop</span>
				<span class="k">continue</span><span class="p">;</span> <span class="c1">// used to skip one loop</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">while</code> <em>expression</em></li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

    <span class="k">while</span> <span class="n">number</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{number}!"</span><span class="p">);</span>

        <span class="n">number</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"LIFTOFF!!!"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">for</code> <em>expression</em></li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">];</span>

    <span class="k">for</span> <span class="n">element</span> <span class="k">in</span> <span class="n">a</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"the value is: {element}"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="4--understanding-ownership">4.  <strong><a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html#understanding-ownership">Understanding Ownership</a></strong></h1>

<h2 id="41-what-is-ownership">4.1 <strong><a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#what-is-ownership">What Is Ownership?</a></strong></h2>

<p>Compared with C++:</p>

<ul>
  <li>Every <em>variable</em> have one and only <strong><em>owner</em></strong>, when <em>the owner</em> goes out of scope, the <em>variable</em> is <em>dropped</em> (<em>desctructed</em> in C++)</li>
  <li><em>Owner</em> can be transfered, it’s like <em>move</em> semantics in C++(but not the same)</li>
  <li>By default, assignment, function parameter passing, function return are all action of tranfer of <em>owner</em></li>
  <li>It can be over simply summarized as:
    <ul>
      <li>By default, C++ use <em>copy</em> for assignment, function parameter passing and function return, except to specifically using <em>rvalue reference</em></li>
      <li>By default, Rust use <em>move</em> for assignment, function paramete passing and function return, except to specifically implementing <em>copy</em> in the variable. Scalar types like integers, floats, chars are copied</li>
    </ul>
  </li>
  <li>The Rust compiler will check the <em>owner</em> of every variable, when it goes out of scope, the variable is <em>dropped</em></li>
</ul>

<p><em>Ownership</em> in Rust is NOT the same with <em>move</em> in C++:</p>

<ul>
  <li>When variables are <em>moved</em> in C++, the variable is in <em>valid but unspecified</em> state. Destructor will still be called when the variable goes out of scope. Programmer need to take care of this.
    <ul>
      <li><em>move</em> will not change scope of a variable</li>
    </ul>
  </li>
  <li>When <em>ownership</em> of variable in Rust is taken, the scope of the variable is changed, which means the time for calling the <em>drop</em> method is changed
    <ul>
      <li>Even on the stack the <em>ownership</em> is important since it decides when the variable is <em>dropped</em></li>
      <li><strong>If the variable is totally on stack, even it’s memory is still valid, it can not be used, since the <em>drop</em> method might change it’s value</strong></li>
    </ul>
  </li>
</ul>

<p>Both C++ and Rust can <em>destruct</em> variables on <em>heap</em> or <em>stack:</em></p>

<ul>
  <li><em>heap</em> memroies are returned to OS</li>
  <li><em>stack</em> memories might be still valid, but the value might be changed. So it still matters when to destruct the variable and what can be done on this stack memory</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">MyStruct</span> <span class="p">{</span>
    <span class="n">_a</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">_b</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">MyStruct</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"droped, _a = {}"</span><span class="p">,</span> <span class="k">self</span><span class="py">._a</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="n">MyStruct</span> <span class="p">{</span> <span class="n">_a</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="n">_b</span><span class="p">:</span> <span class="mi">20</span> <span class="p">};</span>
    <span class="c1">// add some variables on stack</span>
    <span class="k">let</span> <span class="n">_s</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">_t</span> <span class="o">=</span> <span class="mf">2.13</span><span class="p">;</span>

    <span class="p">{</span>
        <span class="c1">// _b take ownership of _a</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">_b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">_b</span><span class="py">._a</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
    <span class="p">}</span> <span class="c1">// call drop</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"end of main program"</span><span class="p">);</span>
    <span class="c1">// there will no more calling of drop anymore</span>
<span class="p">}</span>

<span class="c1">// output:</span>

<span class="c1">// droped, _a = 20</span>
<span class="c1">// end of main program</span>
</code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">MyStruct</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

  <span class="o">~</span><span class="n">MyStruct</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"dtor: "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">";"</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">MyStruct</span><span class="p">(</span><span class="n">MyStruct</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">b</span><span class="p">;</span>
    <span class="n">other</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
    <span class="n">other</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"being moved: "</span> <span class="o">&lt;&lt;</span> <span class="n">other</span><span class="p">.</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">";"</span> <span class="o">&lt;&lt;</span> <span class="n">other</span><span class="p">.</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">MyStruct</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">MyStruct</span> <span class="n">m</span><span class="p">;</span>
  <span class="c1">/// some other variables on the stack</span>
  <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="mf">2.3</span><span class="p">;</span>
  <span class="c1">// even though m is moved, it's destructor will still be called when</span>
  <span class="c1">// m goes out of scope</span>
  <span class="n">MyStruct</span> <span class="n">i</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// output:</span>

<span class="c1">// being moved: 30;30 # first being moved</span>
<span class="c1">// dtor : 10;20  # destructor of i</span>
<span class="c1">// dtor : 30;30  # destructor of m</span>
</code></pre></div></div>

<h2 id="42-references-and-borrowing">4.2 <strong><a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#references-and-borrowing">References and Borrowing</a></strong></h2>

<p>Compared with C++:</p>

<ul>
  <li>By default, a reference in C++ is <em>mutable</em>, user can use it to change the value it points to, except that explicitly specify that it is <em>const reference</em>I</li>
  <li>By default, a reference in Rust is <em>immutable</em>, user can not use it to change the value it points to, except explicitly specify that it is a <em>mut reference</em></li>
  <li>In C++, there is no <em>reference to reference</em>, but have <em>rvalue reference</em>; In Rust, there is no <em>rvalue reference</em>, but one can refer to reference like <code class="language-plaintext highlighter-rouge">&amp;&amp;&amp;&amp;a</code>, which is parsed in following rule:
    <ul>
      <li><strong>It will deref as many times as possible (<code class="language-plaintext highlighter-rouge">&amp;&amp;String</code> -&gt; <code class="language-plaintext highlighter-rouge">&amp;String</code> -&gt; <code class="language-plaintext highlighter-rouge">String</code> -&gt; <code class="language-plaintext highlighter-rouge">str</code>) and then reference at max once (<code class="language-plaintext highlighter-rouge">str</code> -&gt; <code class="language-plaintext highlighter-rouge">&amp;str</code>).</strong></li>
    </ul>
  </li>
</ul>

<p>To avoid data race, Rust compiler assure:</p>

<ul>
  <li>One and only one <em>mutable reference</em> is pointed to one variable, or</li>
  <li>Multi <em>immutable reference</em> are pointed to one variable</li>
</ul>

<h2 id="43-the-slice-type">4.3 <strong><a href="https://doc.rust-lang.org/book/ch04-03-slices.html#the-slice-type">The Slice Type</a></strong></h2>

<ul>
  <li><em>slice</em> is used to <em>reference</em> to a contiguous sequence of elements in a collection rather than the whole collection</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">strin</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Hello World"</span><span class="p">);</span>
    <span class="c1">// string slice</span>
    <span class="k">let</span> <span class="n">slic</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">strin</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">2</span><span class="p">];</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">slic</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">arr</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
    <span class="c1">// vector slice</span>
    <span class="k">let</span> <span class="n">arr_slic</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">i32</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">];</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{},{}"</span><span class="p">,</span> <span class="n">arr_slic</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arr_slic</span><span class="nf">.len</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>It’s better to use <em>slice</em> instead of the original collection type as function parameters, since <em>slice</em> type can accept both <em>slice</em> and original collection type. When original collection type is passed, it is <em>coerced</em> to <em>slice</em> type, it is called <em>deref coercions</em></li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">strin</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Hello World"</span><span class="p">);</span>
    <span class="c1">// string slice</span>
    <span class="k">let</span> <span class="n">slic</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">strin</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">2</span><span class="p">];</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">slic</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">arr</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
    <span class="c1">// vector slice</span>
    <span class="k">let</span> <span class="n">arr_slic</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">i32</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">];</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{},{}"</span><span class="p">,</span> <span class="n">arr_slic</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arr_slic</span><span class="nf">.len</span><span class="p">());</span>

    <span class="c1">// p_slice can accept both &amp;String type and &amp;str type</span>
    <span class="c1">// Note that &amp;strin is reference to strin</span>
    <span class="nf">p_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">strin</span><span class="p">);</span>
    <span class="nf">p_slice</span><span class="p">(</span><span class="n">slic</span><span class="p">);</span>

    <span class="nf">p_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">strin</span><span class="p">);</span>
    <span class="c1">// following code do not compile</span>
    <span class="c1">// p_str(slic);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">p_slice</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">fn</span> <span class="nf">p_str</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="5-using-structs-to-structure-related-data">5. <strong><a href="https://doc.rust-lang.org/book/ch05-00-structs.html#using-structs-to-structure-related-data">Using Structs to Structure Related Data</a></strong></h1>

<p>Compared with C++, except for difference in code format, the idea is basically the same for data encapulation.</p>

<h2 id="52-an-example-program-using-structs">5.2 <strong><a href="https://doc.rust-lang.org/book/ch05-02-example-structs.html#an-example-program-using-structs">An Example Program Using Structs</a></strong></h2>

<ul>
  <li>Debug printing, add <em>attribute</em> to struct</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">Rectangle</span><span class="p">{</span>
    <span class="n">width</span><span class="p">:</span><span class="nb">u32</span><span class="p">,</span>
    <span class="n">height</span><span class="p">:</span><span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">rect</span><span class="o">=</span><span class="n">Rectangle</span><span class="p">{</span>
        <span class="n">width</span><span class="p">:</span><span class="nd">dbg!</span><span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="mi">30</span><span class="p">),</span>
        <span class="n">height</span><span class="p">:</span><span class="mi">50</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="k">let</span> <span class="n">w</span><span class="o">=</span><span class="n">rect</span><span class="py">.width</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">h</span><span class="o">=</span><span class="n">rect</span><span class="py">.height</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Rectangle is {:#?}, {}, {}"</span><span class="p">,</span> <span class="n">rect</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="53-method-syntax">5.3 Method Syntax</h2>

<p>Compared with C++, Rust does object orinented programming using <code class="language-plaintext highlighter-rouge">impl</code> keyword to implement <em>method</em> of <em>object</em>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">Rectangle</span><span class="p">{</span>
    <span class="n">width</span><span class="p">:</span><span class="nb">u32</span><span class="p">,</span>
    <span class="n">height</span><span class="p">:</span><span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Rectangle</span><span class="p">{</span>
    <span class="k">fn</span> <span class="nf">area</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span><span class="k">-&gt;</span><span class="nb">u32</span><span class="p">{</span>
        <span class="k">self</span><span class="py">.width</span> <span class="o">*</span> <span class="k">self</span><span class="py">.height</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">rect</span><span class="o">=</span><span class="n">Rectangle</span><span class="p">{</span>
        <span class="n">width</span><span class="p">:</span><span class="nd">dbg!</span><span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="mi">30</span><span class="p">),</span>
        <span class="n">height</span><span class="p">:</span><span class="mi">50</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"Area of Rectangle is {}"</span><span class="p">,</span> <span class="n">rect</span><span class="nf">.area</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">&amp;self</code> is equivalent to <code class="language-plaintext highlighter-rouge">self: &amp;Self</code> where <code class="language-plaintext highlighter-rouge">Self</code> is an alias for the type that the <code class="language-plaintext highlighter-rouge">impl</code> block is for.</li>
  <li>Methods can take ownership of <code class="language-plaintext highlighter-rouge">self</code>, borrow <code class="language-plaintext highlighter-rouge">self</code> immutably, as we’ve done here, or borrow <code class="language-plaintext highlighter-rouge">self</code> mutably, just as they can any other parameter.</li>
  <li>All functions defined within an <code class="language-plaintext highlighter-rouge">impl</code> block are called <em>associated functions</em> because they’re associated with the type named after the <code class="language-plaintext highlighter-rouge">impl</code>.
    <ul>
      <li>If <code class="language-plaintext highlighter-rouge">self</code> as first parameter, this function is called <em>method</em></li>
      <li>Otherwise, it is not <em>method</em>, just <em>associate functions</em>, it can normally be used to:
        <ul>
          <li>Constructors that are used to return a new instance of the struct</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">Rectangle</span><span class="p">{</span>
    <span class="n">width</span><span class="p">:</span><span class="nb">u32</span><span class="p">,</span>
    <span class="n">height</span><span class="p">:</span><span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Rectangle</span><span class="p">{</span>
    <span class="c1">// This is method</span>
    <span class="k">fn</span> <span class="nf">area</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span><span class="k">-&gt;</span><span class="nb">u32</span><span class="p">{</span>
        <span class="k">self</span><span class="py">.width</span> <span class="o">*</span> <span class="k">self</span><span class="py">.height</span>
    <span class="p">}</span>

    <span class="c1">// This is not method</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">size</span><span class="p">:</span><span class="nb">u32</span><span class="p">)</span><span class="k">-&gt;Self</span><span class="p">{</span>
        <span class="k">Self</span><span class="p">{</span>
            <span class="n">width</span><span class="p">:</span><span class="n">size</span><span class="p">,</span>
            <span class="n">height</span><span class="p">:</span><span class="n">size</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">rect</span><span class="o">=</span><span class="n">Rectangle</span><span class="p">{</span>
        <span class="n">width</span><span class="p">:</span><span class="nd">dbg!</span><span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="mi">30</span><span class="p">),</span>
        <span class="n">height</span><span class="p">:</span><span class="mi">50</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"Area of Rectangle is {}"</span><span class="p">,</span> <span class="n">rect</span><span class="nf">.area</span><span class="p">());</span>

    <span class="k">let</span> <span class="n">rec</span><span class="o">=</span><span class="nn">Rectangle</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Area of Rectangle is {}"</span><span class="p">,</span> <span class="n">rec</span><span class="nf">.area</span><span class="p">());</span>

<span class="p">}</span>
</code></pre></div></div>

<h1 id="6-enums-and-pattern-matching">6. <strong><a href="https://doc.rust-lang.org/book/ch06-00-enums.html#enums-and-pattern-matching">Enums and Pattern Matching</a></strong></h1>

<h2 id="61-defining-an-enum">6.1 <strong><a href="https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html#defining-an-enum">Defining an Enum</a></strong></h2>

<p>Compared with C++, Rust in enum is more powerfull:</p>

<ul>
  <li>Every enum item can have associate values</li>
  <li>One or more associate values for each enum item and they can be different types</li>
  <li><em>Methods</em> can be defined for enums like <em>struct</em></li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Message</span> <span class="p">{</span>
    <span class="n">Quit</span><span class="p">,</span>
    <span class="n">Move</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">i32</span> <span class="p">},</span>
    <span class="nf">Write</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
    <span class="nf">ChangeColor</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Message</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// method body would be defined here</span>
        <span class="p">}</span>
    <span class="p">}</span>

 <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="nn">Message</span><span class="p">::</span><span class="nf">Write</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">));</span>
 <span class="n">m</span><span class="nf">.call</span><span class="p">();</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code> is essential for Rust language, which is an enum that stores <code class="language-plaintext highlighter-rouge">None</code> if value not exist and <code class="language-plaintext highlighter-rouge">Some&lt;T&gt;</code> if value exist:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nb">None</span><span class="p">,</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">T</span><span class="p">),</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code> enum is so useful that it’s even included in the prelude; you don’t need to bring it into scope explicitly.</li>
  <li>Its variants are also included in the prelude: you can use <code class="language-plaintext highlighter-rouge">Some</code> and <code class="language-plaintext highlighter-rouge">None</code> directly without the <code class="language-plaintext highlighter-rouge">Option::</code> prefix.</li>
  <li>Why it is better than just a <code class="language-plaintext highlighter-rouge">null</code> in C++:</li>
  <li>In short, because <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code> and <code class="language-plaintext highlighter-rouge">T</code> (where <code class="language-plaintext highlighter-rouge">T</code> can be any type) are different types, the compiler won’t let us use an <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code> value as if it were definitely a valid value. So every time <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code> is used, compiler requires programmer <em>explicitly</em> check the existence of the potentially stored value</li>
</ul>

<h2 id="62-thematchcontrol-flow-construct">6.2 <strong><a href="https://doc.rust-lang.org/book/ch06-02-match.html#the-match-control-flow-construct">The <code class="language-plaintext highlighter-rouge">match</code> Control Flow Construct</a></strong></h2>

<ul>
  <li>When binding values in <code class="language-plaintext highlighter-rouge">enum</code>, it depends on the <em>matched</em> instance whether the binding is <em>reference</em> or <em>move</em>
    <ul>
      <li>If the <em>matched</em> instance is <em>reference</em>, the bind is <em>reference</em></li>
      <li>If the <em>matched</em> instance is not <em>reference</em>, the bind is <em>move</em></li>
    </ul>
  </li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug)]</span>
<span class="k">enum</span> <span class="n">Fruit</span> <span class="p">{</span>
    <span class="n">Apple</span><span class="p">,</span>
    <span class="n">Orange</span><span class="p">,</span>
    <span class="n">Grape</span><span class="p">,</span>
    <span class="nf">Watermelom</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">have_fruit</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Fruit</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Fruit</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// No matter what return a Apple</span>
    <span class="k">match</span> <span class="n">f</span> <span class="p">{</span>
        <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Fruit</span><span class="p">::</span><span class="n">Apple</span><span class="p">),</span>
        <span class="nf">Some</span><span class="p">(</span><span class="n">fruit</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Fruit</span><span class="p">::</span><span class="n">Apple</span><span class="p">),</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">f</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Fruit</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">Option</span><span class="p">::</span><span class="nf">Some</span><span class="p">(</span><span class="nn">Fruit</span><span class="p">::</span><span class="n">Grape</span><span class="p">);</span>
    <span class="nd">dbg!</span><span class="p">(</span><span class="nf">have_fruit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug)]</span>
<span class="k">enum</span> <span class="n">Fruit</span> <span class="p">{</span>
    <span class="n">Apple</span><span class="p">,</span>
    <span class="n">Orange</span><span class="p">,</span>
    <span class="n">Grape</span><span class="p">,</span>
    <span class="nf">Watermelom</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">define_fruit</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Fruit</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u8</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">f</span> <span class="p">{</span>
        <span class="nn">Fruit</span><span class="p">::</span><span class="n">Apple</span> <span class="k">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nn">Fruit</span><span class="p">::</span><span class="n">Orange</span> <span class="k">=&gt;</span> <span class="mi">2</span><span class="p">,</span>
        <span class="c1">// value of Watermelom is bind to str, by reference, since f is reference</span>
        <span class="nn">Fruit</span><span class="p">::</span><span class="nf">Watermelom</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"qinline is watermelon, {}!"</span><span class="p">,</span> <span class="nb">str</span><span class="p">);</span>
            <span class="mi">4</span>
        <span class="p">}</span> <span class="c1">// , is optional</span>
        <span class="c1">// _ matchs anything else; _=&gt;() means do nothing</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"not important"</span><span class="p">);</span>
            <span class="mi">0</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">qinlin</span> <span class="o">=</span> <span class="nn">Fruit</span><span class="p">::</span><span class="nf">Watermelom</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Sweet!"</span><span class="p">));</span>
    <span class="nf">define_fruit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qinlin</span><span class="p">);</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:#?}"</span><span class="p">,</span> <span class="n">qinlin</span><span class="p">);</span>
    <span class="nd">dbg!</span><span class="p">(</span><span class="n">qinlin</span><span class="p">);</span>
    <span class="c1">// since dbg!() takes ownership of qinlin, following line will be an error</span>
    <span class="c1">// dbg!(qinlin);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="63-concise-control-flow-withif-let">6.3 <strong><a href="https://doc.rust-lang.org/book/ch06-03-if-let.html#concise-control-flow-with-if-let">Concise Control Flow with <code class="language-plaintext highlighter-rouge">if let</code></a></strong></h2>

<p><code class="language-plaintext highlighter-rouge">if let</code> is more concise version of <code class="language-plaintext highlighter-rouge">match</code> if we only care about one item and want to neglect the other options:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Fruit</span> <span class="p">{</span>
    <span class="n">Apple</span><span class="p">,</span>
    <span class="n">Orange</span><span class="p">,</span>
    <span class="nf">Pear</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">favorite</span><span class="p">:</span> <span class="n">Fruit</span> <span class="o">=</span> <span class="nn">Fruit</span><span class="p">::</span><span class="nf">Pear</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Delicious"</span><span class="p">));</span>

    <span class="c1">// Here we use ref key word to specify bind by reference, otherwise</span>
    <span class="c1">// it will bind by move, since favorite variable is not reference</span>
    <span class="k">match</span> <span class="n">favorite</span> <span class="p">{</span>
        <span class="nn">Fruit</span><span class="p">::</span><span class="nf">Pear</span><span class="p">(</span><span class="k">ref</span> <span class="n">var</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Pear is {}"</span><span class="p">,</span> <span class="n">var</span><span class="p">),</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"It is not pear"</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="c1">// if let version for same functionality above</span>
    <span class="c1">// Note that here we do not use ref, it is bind by move</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nn">Fruit</span><span class="p">::</span><span class="nf">Pear</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="o">=</span> <span class="n">favorite</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Pear is {}"</span><span class="p">,</span> <span class="n">var</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"It's not pear"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="7-managing-growing-projects-with-packages-crates-and-modules">7. <strong><a href="https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html#managing-growing-projects-with-packages-crates-and-modules">Managing Growing Projects with Packages, Crates, and Modules</a></strong></h1>

<p>Following are concept comparisons with C++:</p>

<ul>
  <li><em>crates</em>: The smallest amount of code that the rust compiler considers at a time
    <ul>
      <li>This is NOT like C++, in C++, the smallest amount of code that compiler considers is one translation unit, aka, a single source file</li>
      <li><em>create</em> can be compared to <em>library</em> or <em>executable</em> in C++, which might be compiled from multi cpp source files</li>
      <li>Rust do not use <em>include</em> to manage individual files, it requires files organized according to <em>module</em> and must be put under specific locations, while in C++ one can put file in anywhere as long as specify include path during compile time</li>
      <li>There are two kinds of <em>crate</em>: <em>library crate</em> and <em>binary crate</em>
        <ul>
          <li>binary crate has <em>main</em> function while <em>library crate</em> not</li>
        </ul>
      </li>
      <li>The <em>crate root</em> is a source file that the Rust compiler starts from</li>
    </ul>
  </li>
  <li><em>packages</em>:
    <ul>
      <li>A <em>package</em> is a bundle of one or more crates that provides a set of functionality</li>
      <li>A package can contain as many binary crates as you like, but at most only one library crate. By default:
        <ul>
          <li><em>src/main.rs</em> is the crate root of a binary crate with the same name as the package</li>
          <li>Package contains a library crate with the same name as the package, and <em>src/lib.rs</em> is its crate root</li>
        </ul>
      </li>
      <li>Use <em>cargo new</em> command to create a <em>package</em></li>
    </ul>
  </li>
  <li><em>module</em>:
    <ul>
      <li><em>module</em> can be compared with <em>namespace</em> in C++, except that:
        <ul>
          <li><em>module</em> in Rust determine where Rust compiler find the file that contains the <em>module</em></li>
        </ul>
      </li>
      <li>Note that the <code class="language-plaintext highlighter-rouge">mod</code> keyword <em>declare</em> module name, module tree is constructed through the <code class="language-plaintext highlighter-rouge">mod</code> keywords, while the <code class="language-plaintext highlighter-rouge">use</code> keyword <em>bring</em> module name into current crate name space</li>
      <li>For modules declared inside current crate, it’s absolute path starts with <code class="language-plaintext highlighter-rouge">crate::</code></li>
      <li>For external modules, it’s absolute path starts with it’s package name</li>
    </ul>
  </li>
</ul>

<p>Exmaple, for following file structure:</p>

<p><img src="/assets/images/Screenshot_2023-08-19_at_09.19.03.jpg" alt="Screenshot 2023-08-19 at 09.19.03.png" /></p>

<p>File <em>module/src/animal.rs</em></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">Dog</span><span class="p">{</span>
    <span class="k">pub</span> <span class="n">name</span><span class="p">:</span><span class="nb">String</span>
<span class="p">}</span>
</code></pre></div></div>

<p>File <em>module/src/lib.rs</em></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// declaration, compiler search animal.rs</span>
<span class="k">pub</span> <span class="k">mod</span> <span class="n">animal</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">f</span><span class="p">(){</span>
    <span class="k">let</span> <span class="n">d</span><span class="o">=</span><span class="nn">animal</span><span class="p">::</span><span class="n">Dog</span><span class="p">{</span>
        <span class="n">name</span><span class="p">:</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"nihao"</span><span class="p">)</span>
    <span class="p">};</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">d</span><span class="py">.name</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>File <em>module/src/main.rs</em></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// declaration, compiler search animal.rs</span>
<span class="k">pub</span> <span class="k">mod</span> <span class="n">animal</span><span class="p">;</span>

<span class="c1">// the name `animal` is defined multiple times</span>
<span class="c1">// use module::animal;</span>

<span class="c1">// ok</span>
<span class="c1">// use module::animal as another_animal;</span>
<span class="k">use</span> <span class="nn">module</span><span class="p">::</span><span class="n">f</span><span class="p">;</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// modules inside the same crate, moudle starts with 'crate'</span>
    <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="k">crate</span><span class="p">::</span><span class="nn">animal</span><span class="p">::</span><span class="n">Dog</span> <span class="p">{</span>
        <span class="n">name</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"husky"</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="c1">// modules in external create, module starts with the package name</span>
    <span class="c1">// here the package name is 'module'</span>
    <span class="c1">// note that even though crate::animal::Dog and module::animal::Dog</span>
    <span class="c1">// points to the same Dog in animal.rs, they are considered</span>
    <span class="c1">// different Dogs inside current crate</span>
    <span class="k">let</span> <span class="n">another_dog</span> <span class="o">=</span> <span class="nn">module</span><span class="p">::</span><span class="nn">animal</span><span class="p">::</span><span class="n">Dog</span> <span class="p">{</span>
        <span class="n">name</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"teddy"</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="nf">f</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{},{}"</span><span class="p">,</span> <span class="n">d</span><span class="py">.name</span><span class="p">,</span> <span class="n">another_dog</span><span class="py">.name</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="8-common-collections">8. <strong><a href="https://doc.rust-lang.org/book/ch08-00-common-collections.html#common-collections">Common Collections</a></strong></h1>

<h2 id="81-storing-lists-of-values-with-vectors">8.1 <strong><a href="https://doc.rust-lang.org/book/ch08-01-vectors.html#storing-lists-of-values-with-vectors">Storing Lists of Values with Vectors</a></strong></h2>

<p>Rust’s <em>vector</em> is very similar with that of C++, in following aspects:</p>

<ul>
  <li>They both use type parameter, in C++ it’s <em>template</em>, in Rust it’s <em>generic</em></li>
  <li>Their APIs are very similar, both support indexing with <code class="language-plaintext highlighter-rouge">[]</code> or method</li>
</ul>

<p>The key differences are:</p>

<ul>
  <li>When use <code class="language-plaintext highlighter-rouge">[]</code> operator, if happens out of bound access, Rust will crash</li>
  <li>Whne use <code class="language-plaintext highlighter-rouge">get()</code> API to access element, Rust reutrn <code class="language-plaintext highlighter-rouge">Option&lt;&amp;T&gt;</code> , so user can use <code class="language-plaintext highlighter-rouge">match</code> to handle the result</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">arr</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>

    <span class="c1">// This will cause runtime crash</span>
    <span class="c1">// let r = v[100];</span>
    <span class="c1">// This will not cause runtime crash</span>
    <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="n">v</span><span class="nf">.get</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

    <span class="c1">// Here we can use var or &amp;var,</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="o">=</span> <span class="n">m</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"var is {}"</span><span class="p">,</span> <span class="n">var</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"index out of bound"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><em>Vec</em> in Rust also obey <em>ownership</em> rule:
    <ul>
      <li>At any time there can be multi immutable reference to any element, or</li>
      <li>At any time there can be only one mutable reference to only one of the elements</li>
    </ul>
  </li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">v</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
    <span class="c1">// Following lines are the same, i and j are both reference to i32</span>
    <span class="k">let</span> <span class="n">_i</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">let</span> <span class="o">&amp;</span><span class="n">_j</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

    <span class="n">v</span><span class="nf">.push</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

    <span class="c1">// Here panic because during the lifetime of bowrrow, mutable reference happens</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"_i is {}"</span><span class="p">,</span> <span class="n">_i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Iteration is similar with C++</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">v</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="o">&amp;</span><span class="n">v</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">v</span> <span class="p">{</span>
        <span class="c1">//Note the dereference *</span>
        <span class="o">*</span><span class="n">i</span> <span class="o">+=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Because of Rust have more powerful <em>enum</em>, which has a associate type for each item, <em>vector</em> in Rust can used to store different types indirectly with the help of <em>enum</em>:</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">DiffTypes</span> <span class="p">{</span>
    <span class="nf">Type1</span><span class="p">(</span><span class="nb">i8</span><span class="p">),</span>
    <span class="nf">Type2</span><span class="p">(</span><span class="nb">i16</span><span class="p">),</span>
    <span class="nf">Type3</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
<span class="p">}</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span>
        <span class="nn">DiffTypes</span><span class="p">::</span><span class="nf">Type1</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
        <span class="nn">DiffTypes</span><span class="p">::</span><span class="nf">Type2</span><span class="p">(</span><span class="mi">12345</span><span class="p">),</span>
        <span class="nn">DiffTypes</span><span class="p">::</span><span class="nf">Type3</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Hello World！"</span><span class="p">)),</span>
    <span class="p">];</span>

    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="o">&amp;</span><span class="n">v</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">i</span> <span class="p">{</span>
            <span class="nn">DiffTypes</span><span class="p">::</span><span class="nf">Type1</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">var</span><span class="p">),</span>
            <span class="nn">DiffTypes</span><span class="p">::</span><span class="nf">Type2</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">var</span><span class="p">),</span>
            <span class="nn">DiffTypes</span><span class="p">::</span><span class="nf">Type3</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">var</span><span class="p">),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="82-storing-utf-8-encoded-text-with-strings">8.2 <strong><a href="https://doc.rust-lang.org/book/ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">Storing UTF-8 Encoded Text with Strings</a></strong></h2>

<ul>
  <li>In Rust, <em>string</em> can refer to <em>&amp;str</em> string slice type, which is built in type at the core of the language, or it can refer to <em>String</em> type which is a type implemented in std library and is implemented as <em>vector</em> of <em>bytes</em></li>
  <li>Concatenate strings:</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">h</span> <span class="o">=</span> <span class="s">"hello"</span><span class="nf">.to_string</span><span class="p">();</span>
    <span class="c1">// sigature of push_str: push_str(&amp;mut self, string: &amp;str)</span>
    <span class="n">h</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"world"</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
    <span class="c1">// signature of push: push(&amp;mut self, ch: char)</span>
    <span class="n">h</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'!'</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">s1</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">s2</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"World"</span><span class="p">);</span>

    <span class="c1">// + operator take ownership of the first operand: fn add(self, s: &amp;str) -&gt; String {</span>
    <span class="k">let</span> <span class="n">s3</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="s">"nihao"</span><span class="p">;</span>
    <span class="c1">// do not compile since s1 has been moved in + operation</span>
    <span class="c1">// println!("{}", s1);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">s3</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">s1</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"universe"</span><span class="p">);</span>
    <span class="c1">// use format!() macro to not take ownership to concatenate strings</span>
    <span class="k">let</span> <span class="n">s4</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{s1}_{s2}_{s3}"</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">s4</span><span class="p">);</span>
    <span class="c1">// s1 still available</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">s1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>string <strong>can not</strong> be indexed using <code class="language-plaintext highlighter-rouge">[]</code>in Rust, such as <code class="language-plaintext highlighter-rouge">s1[0]</code>, but can be <em>sliced</em> like <code class="language-plaintext highlighter-rouge">s1[0..1]</code></li>
  <li>Two kinds of iteration:
    <ul>
      <li>Iterate over <em>char: <code class="language-plaintext highlighter-rouge">for c in "Зд".chars()</code></em></li>
      <li>Iterate over <em>bytes</em>: <code class="language-plaintext highlighter-rouge">for b in "Зд".bytes()</code></li>
      <li>Note that Rust might store one <em>char</em> in different amount of bytes</li>
    </ul>
  </li>
</ul>

<h2 id="83-storing-keys-with-associated-values-in-hash-maps">8.3 <strong><a href="https://doc.rust-lang.org/book/ch08-03-hash-maps.html#storing-keys-with-associated-values-in-hash-maps">Storing Keys with Associated Values in Hash Maps</a></strong></h2>

<ul>
  <li>Create, access and iterate HashMap
    <ul>
      <li><code class="language-plaintext highlighter-rouge">insert</code> take ownership of it’s parameters</li>
      <li><code class="language-plaintext highlighter-rouge">get</code> takes <em>reference</em> and return *Option<reference>*</reference></li>
    </ul>
  </li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="p">;</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">hp</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nb">i32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">s</span><span class="o">=</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Moved"</span><span class="p">);</span>

    <span class="c1">// Note insert takes ownership of the parameter</span>
    <span class="n">hp</span><span class="nf">.insert</span><span class="p">(</span><span class="s">"Tom"</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="mi">10</span><span class="p">);</span>
    <span class="n">hp</span><span class="nf">.insert</span><span class="p">(</span><span class="s">"Jerry"</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="mi">20</span><span class="p">);</span>

    <span class="c1">// get takes any borrowed form of the map's key type and returns Option&lt;&amp;V&gt;</span>
    <span class="c1">// copied() method of Option turns Option&lt;&amp;V&gt; to Option&lt;V&gt;</span>
    <span class="c1">// unwrap_or function of Option return value if None</span>
    <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="n">hp</span><span class="nf">.get</span><span class="p">(</span><span class="s">"Harray"</span><span class="p">)</span><span class="nf">.copied</span><span class="p">()</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>

    <span class="c1">// iterate over has map, note the &amp; sign, this means we use reference to print the value, without this sign, key and value will be moved</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">in</span> <span class="o">&amp;</span><span class="n">hp</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}:{}"</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Update key value:</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="p">;</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">scores</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="n">scores</span><span class="nf">.insert</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Blue"</span><span class="p">),</span> <span class="mi">10</span><span class="p">);</span>

    <span class="c1">// entry method: Gets the given key's corresponding entry in the map for in-place manipulation.</span>
    <span class="c1">// or_insert method: Ensures a value is in the entry by inserting the default if empty, and returns a mutable reference to the value in the entry</span>
    <span class="n">scores</span><span class="nf">.entry</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Yellow"</span><span class="p">))</span><span class="nf">.or_insert</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
    <span class="n">scores</span><span class="nf">.entry</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Blue"</span><span class="p">))</span><span class="nf">.or_insert</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">scores</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="9-error-handling">9. <strong><a href="https://doc.rust-lang.org/book/ch09-00-error-handling.html#error-handling">Error Handling</a></strong></h1>

<p>There are two kinds of errors in Rust:</p>

<ul>
  <li><em>recoverable</em>: <code class="language-plaintext highlighter-rouge">Result&lt;T, E&gt;</code></li>
  <li><em>unrecoverable</em>: <code class="language-plaintext highlighter-rouge">panic</code></li>
</ul>

<h2 id="91-unrecoverable-errors-withpanic">9.1 <strong><a href="https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html#unrecoverable-errors-with-panic">Unrecoverable Errors with <code class="language-plaintext highlighter-rouge">panic!</code></a></strong></h2>

<p>Compared with C++, <code class="language-plaintext highlighter-rouge">panic</code> in Rust is crash, but Rust provide more user friendly debug infomation instead of just abort in C++, set the RUST_BACKTRACE=1 environment variable to print the crash backtrace.</p>

<h2 id="92-recoverable-errors-withresult">9.2 <strong><a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#recoverable-errors-with-result">Recoverable Errors with <code class="language-plaintext highlighter-rouge">Result</code></a></strong></h2>

<p>Compared with C++’s <code class="language-plaintext highlighter-rouge">try..throw..catch</code> , Rust use one special <em>enum</em> to handle exceptions, <code class="language-plaintext highlighter-rouge">Result&lt;T,E&gt;</code></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="c1">// T is the return value if no exception</span>
    <span class="nf">Err</span><span class="p">(</span><span class="n">E</span><span class="p">),</span> <span class="c1">// E is error type if exception happens</span>
<span class="p">}</span>
</code></pre></div></div>

<p>One can process error in following ways:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">match</code> :</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="n">File</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">_file</span> <span class="o">=</span> <span class="k">match</span> <span class="n">_file_result</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">file</span><span class="p">,</span>
        <span class="nf">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"file open failed"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">if let</code>:</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="n">File</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">_file_result</span> <span class="o">=</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="s">"hello.txt"</span><span class="p">);</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">_file</span><span class="p">)</span> <span class="o">=</span> <span class="n">_file_result</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"file successfully opend"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nd">panic!</span><span class="p">(</span><span class="s">"file open failed"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">unwrap</code>
    <ul>
      <li>Return the result or panic</li>
    </ul>
  </li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="n">File</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">_file</span> <span class="o">=</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="s">"hello.txt"</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">expect</code>
    <ul>
      <li>Same with <code class="language-plaintext highlighter-rouge">unwrap</code> but allow to specify custom message when panic</li>
    </ul>
  </li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="n">File</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">_file_result</span> <span class="o">=</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="s">"hello.txt"</span><span class="p">)</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"file open failed"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Rust propagates errors by <em>return a Result instance:</em></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="n">File</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">io</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="n">Read</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">return_file</span><span class="p">(</span><span class="n">file_name</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nn">io</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">//open file</span>
    <span class="k">let</span> <span class="n">file_result</span><span class="p">:</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">File</span><span class="p">,</span> <span class="nn">io</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">file_d</span><span class="p">:</span> <span class="n">File</span> <span class="o">=</span> <span class="k">match</span> <span class="n">file_result</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">file</span><span class="p">,</span>
        <span class="c1">// here have to use return , if not it returns to file_d, like file above</span>
        <span class="nf">Err</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="n">error</span><span class="p">),</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">name</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">match</span> <span class="n">file_d</span><span class="nf">.read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// following line do not need return, it's last expression, returned by default</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">name</span><span class="p">),</span>
        <span class="nf">Err</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Err</span><span class="p">(</span><span class="n">error</span><span class="p">),</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">_name</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="nf">return_file</span><span class="p">(</span><span class="s">"/home/swq/playground/rust_book/result/src/hello.txt"</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">_name</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">return_file</code> returns <code class="language-plaintext highlighter-rouge">Result</code> object, propagate possible errors at the same time</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">?</code> operator:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="n">File</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">io</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="n">Read</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">return_file</span><span class="p">(</span><span class="n">file_name</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nn">io</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">//The ? operator has two function:</span>
    <span class="c1">// 1. unwrap and get the value in Result</span>
    <span class="c1">// 2. if error, return the error from this function call</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">file</span><span class="p">:</span> <span class="n">File</span> <span class="o">=</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">name</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="n">file</span><span class="nf">.read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">name</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">_name</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="nf">return_file</span><span class="p">(</span><span class="s">"/home/swq/playground/rust_book/result/src/hello.txt"</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">_name</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">?</code> operator has two meaning:</p>

<ul>
  <li>If get the value, return the value and go on with the function</li>
  <li>If get error in Result, return from this function and propagate this error to the caller</li>
</ul>

<p>We can chain the operation without creating intermediate variables:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="n">File</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">io</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="n">Read</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">return_file</span><span class="p">(</span><span class="n">file_name</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nn">io</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">name</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span><span class="o">?</span><span class="nf">.read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">name</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">_name</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="nf">return_file</span><span class="p">(</span><span class="s">"/home/swq/playground/rust_book/result/src/hello.txt"</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">_name</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="10-generic-types-traits-and-lifetimes">10. <strong><a href="https://doc.rust-lang.org/book/ch10-00-generics.html#generic-types-traits-and-lifetimes">Generic Types, Traits, and Lifetimes</a></strong></h1>

<h2 id="101-generic-data-types">10.1 <strong><a href="https://doc.rust-lang.org/book/ch10-01-syntax.html#generic-data-types">Generic Data Types</a></strong></h2>

<p>The counterpart in C++ is <em>template</em>. C++ <em>template</em> and Rust <em>generic</em> are basically the same thing, with some differences.</p>

<p>The similarities are:</p>

<ul>
  <li>Both support function, struct(class), method</li>
  <li>Both support <em>specialization</em></li>
  <li>Both are <em>static</em>, meaning that they are resolved by compiler at compiling time, no runtime overhead</li>
</ul>

<p>Some differences are very subtle, we will use examples to demonstrate. The main differences are:</p>

<ul>
  <li>Rust support <em>enum</em> <em>generic</em>, while in C++ there are no <em>enum</em> <em>template</em>
    <ul>
      <li>Since Rust has more powerful <em>enum</em> with associate value</li>
    </ul>
  </li>
  <li>Rust has more powerful type deduction ability:</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">MyStruct</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
    <span class="n">_b</span><span class="p">:</span> <span class="n">U</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// we do not need to explicitly specify generic types here</span>
    <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="n">MyStruct</span> <span class="p">{</span> <span class="n">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_b</span><span class="p">:</span> <span class="mf">3.14</span> <span class="p">};</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">m</span><span class="py">.a</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>While in C++, programmer must explicitly specify type:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">U</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">MyStruct</span> <span class="p">{</span>
  <span class="n">T</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">U</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Use of class template 'MyStruct' requires template</span>
  <span class="c1">// argumentsclang(template_missing_args)</span>
  <span class="c1">// C++ requires to specify template argument type</span>

  <span class="c1">//   MyStruct m = {.a = 1, .b = 4};</span>

  <span class="c1">//   ok</span>
  <span class="n">MyStruct</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">h</span> <span class="o">=</span> <span class="p">{.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Rust has more strict implementation check than C++. This means Rust might find errors in template <em>itself</em>, while C++ can only find errors when <em>instantiation</em>, for example:</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">U</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">MyStruct</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">T</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">U</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">MyStruct</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">_a</span><span class="p">,</span> <span class="k">const</span> <span class="n">U</span> <span class="o">&amp;</span><span class="n">_b</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">_a</span><span class="p">;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">_b</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">//   c++ compile do not check whether T and U can be compared during template</span>
  <span class="c1">//   declaration; only checks when this template is instantiated</span>
  <span class="kt">bool</span> <span class="nf">compare</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">SomeType</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">a</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">MyStruct</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">MyStruct</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m</span><span class="p">.</span><span class="n">compare</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="c1">// if we do not have following instantiation, the code compiles OK, because</span>
  <span class="c1">// implementation check happens when template is instantiated</span>
  <span class="n">SomeType</span> <span class="n">s</span><span class="p">;</span>
  <span class="n">MyStruct</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">SomeType</span><span class="o">&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">MyStruct</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">SomeType</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">compare</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>But for Rust, it checks at <em>generic</em> definition time instead of <em>generic</em> instantiation time, which makes the error detection more earlier than in C++:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">MyStruct</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// Rust checks whether T supports &lt; operation at generic implementation time instead of instantiation time</span>
<span class="c1">// this means that errors in generics can be detect more earlier</span>

<span class="c1">// following code does not compile because rust have to know whether T support &lt; or not at this time</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">MyStruct</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">compare</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">from</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">MyStruct</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.a</span> <span class="o">&lt;</span> <span class="n">from</span><span class="py">.a</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="n">MyStruct</span> <span class="p">{</span> <span class="n">a</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>
    <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">MyStruct</span> <span class="p">{</span> <span class="n">a</span><span class="p">:</span> <span class="mi">2</span> <span class="p">};</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">m</span><span class="nf">.compare</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To correct the code, we have to tell Rust compiler that the template argument supports all operations inside implementation:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// tells Rust that T can be compared with each other</span>
<span class="k">struct</span> <span class="n">MyStruct</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nb">PartialOrd</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nb">PartialOrd</span><span class="o">&gt;</span> <span class="n">MyStruct</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">compare</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">from</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">MyStruct</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.a</span> <span class="o">&lt;</span> <span class="n">from</span><span class="py">.a</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="n">MyStruct</span> <span class="p">{</span> <span class="n">a</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>
    <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">MyStruct</span> <span class="p">{</span> <span class="n">a</span><span class="p">:</span> <span class="mi">2</span> <span class="p">};</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">m</span><span class="nf">.compare</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="102-traits-defining-shared-behavior">10.2 <strong><a href="https://doc.rust-lang.org/book/ch10-02-traits.html#traits-defining-shared-behavior">Traits: Defining Shared Behavior</a></strong></h2>

<p>There is no exact counterpart in C++ for <em>traits</em> in Rust. The most close one is pure virtual function. Traits in Rust can be compared with <em>interface</em> in Java.</p>

<ul>
  <li>A <em>trait</em> in Rust defines a set of method signatures that shared by any <em>type</em> that implement this <em>trait</em></li>
  <li>Method inside a <em>trait</em> are defaulted to <code class="language-plaintext highlighter-rouge">pub</code>, since <em>trait</em> are meant to be called</li>
  <li>Method inside <em>trait</em> can have default implementations
    <ul>
      <li>Inside default implementations, one can call other methods that have no default implementation</li>
      <li>When overriding default implementations, inside the overriding method, the default implementation of the same method can no be called</li>
    </ul>
  </li>
  <li>One can implement external <em>trait</em> on type inside local crate, or implement local <em>trait</em> one external types, or implement local <em>trait</em> on local types:
    <ul>
      <li>At least <em>trait</em> or type one of them must be local to current crate</li>
      <li>Otherwise, there might be duplicate implementations, since we do not know whether types in external packages implement the same <em>trait</em> on it or not. When this happens, Rust compiler do not know which <em>trait</em> implementation to use</li>
    </ul>
  </li>
  <li>Using <em>trait</em> to restrict parameter types</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// using impl</span>
<span class="k">fn</span> <span class="nf">notify</span><span class="p">(</span><span class="n">para</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">impl</span> <span class="n">Summary</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">para</span><span class="nf">.summarize</span><span class="p">());</span>
<span class="p">}</span>

<span class="c1">// more general way</span>
<span class="k">fn</span> <span class="n">general_notify</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Summary</span><span class="o">&gt;</span><span class="p">(</span><span class="n">para</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">para</span><span class="nf">.summarize</span><span class="p">());</span>
<span class="p">}</span>

<span class="c1">// para1 and para2 might have same or different types</span>
<span class="k">fn</span> <span class="nf">multi_notify_impl</span><span class="p">(</span><span class="n">para1</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">impl</span> <span class="n">Summary</span><span class="p">,</span> <span class="n">para2</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">impl</span> <span class="n">Summary</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}</span><span class="se">\n</span><span class="s">{}"</span><span class="p">,</span> <span class="n">para1</span><span class="nf">.summarize</span><span class="p">(),</span> <span class="n">para2</span><span class="nf">.summarize</span><span class="p">());</span>
<span class="p">}</span>

<span class="c1">// the same as above</span>
<span class="k">fn</span> <span class="n">multi_notify_two</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Summary</span><span class="p">,</span> <span class="n">U</span><span class="p">:</span> <span class="n">Summary</span><span class="o">&gt;</span><span class="p">(</span><span class="n">para1</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">para2</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">U</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}{}"</span><span class="p">,</span> <span class="n">para1</span><span class="nf">.summarize</span><span class="p">(),</span> <span class="n">para2</span><span class="nf">.summarize</span><span class="p">());</span>
<span class="p">}</span>

<span class="c1">// if we want restrict two parameters to same type, we have to use this way</span>
<span class="k">fn</span> <span class="n">multi_notify</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Summary</span><span class="o">&gt;</span><span class="p">(</span><span class="n">para1</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">para2</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}</span><span class="se">\n</span><span class="s">{}"</span><span class="p">,</span> <span class="n">para1</span><span class="nf">.summarize</span><span class="p">(),</span> <span class="n">para2</span><span class="nf">.summarize</span><span class="p">());</span>
<span class="p">}</span>

<span class="c1">// using + operator</span>
<span class="k">fn</span> <span class="n">multi_notify_three</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Summary</span><span class="p">,</span> <span class="n">U</span><span class="p">:</span> <span class="n">Summary</span> <span class="o">+</span> <span class="n">Display</span><span class="o">&gt;</span><span class="p">(</span><span class="n">para1</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">para2</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">U</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}{}"</span><span class="p">,</span> <span class="n">para1</span><span class="nf">.summarize</span><span class="p">(),</span> <span class="n">para2</span><span class="nf">.summarize</span><span class="p">());</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">multi_notify_four</span><span class="p">(</span><span class="n">para1</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">impl</span> <span class="n">Summary</span><span class="p">,</span> <span class="n">para2</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">(</span><span class="k">impl</span> <span class="n">Summary</span> <span class="o">+</span> <span class="n">Display</span><span class="p">))</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}</span><span class="se">\n</span><span class="s">{}"</span><span class="p">,</span> <span class="n">para1</span><span class="nf">.summarize</span><span class="p">(),</span> <span class="n">para2</span><span class="nf">.summarize</span><span class="p">());</span>
<span class="p">}</span>

<span class="c1">// using where</span>
<span class="k">fn</span> <span class="n">multi_notify_five</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">para1</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">para2</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">U</span><span class="p">)</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="n">Summary</span><span class="p">,</span>
    <span class="n">U</span><span class="p">:</span> <span class="n">Summary</span> <span class="o">+</span> <span class="n">Display</span><span class="p">,</span>
<span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}{}"</span><span class="p">,</span> <span class="n">para1</span><span class="nf">.summarize</span><span class="p">(),</span> <span class="n">para2</span><span class="nf">.summarize</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Return types that implement <em>trait</em>
    <ul>
      <li>Can not return different types in implementation. Compared with C++ virtual base class, <em>trait</em> here is static future, meaning that it is not achieved at <em>runtime</em>; While C++ virtual class is implemented at <em>runtime</em>, by virtual tables</li>
    </ul>
  </li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">returns_summarizable</span><span class="p">(</span><span class="n">switch</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="n">Summary</span> <span class="p">{</span>
		<span class="c1">// no ok, can not return two different types that implement Summary</span>
    <span class="k">if</span> <span class="n">switch</span> <span class="p">{</span>
        <span class="n">NewsArticle</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">Tweet</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(){};</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">DerivedOne</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"from DerivedOne"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">DerivedTwo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"from DerivedTwo"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// return pointer to Base, but we do not know which type at compile time</span>
<span class="n">Base</span> <span class="o">*</span><span class="nf">some_func</span><span class="p">(</span><span class="kt">bool</span> <span class="n">flg</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">flg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">DerivedOne</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DerivedOne</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">DerivedTwo</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DerivedTwo</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">b</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stoi</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
  <span class="c1">// this will call different functions depending on user's input during runtime</span>
  <span class="n">some_func</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">f</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="103-validating-references-with-lifetimes">10.3 <strong><a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#validating-references-with-lifetimes">Validating References with Lifetimes</a></strong></h2>

<p>There is no counterpart in C++.  Facts about Rust lifetimes:</p>

<ul>
  <li>Lifetimes are <em>generics</em>, it’s part of the definition, whether it is used on functions, methods, or types</li>
  <li>Lifetimes are <em>only</em> used on <em>reference</em>, and every <em>reference</em> have lifetimes</li>
  <li>Lifetimes can be used on: functions, methods, types, just like <em>generics</em></li>
  <li>Lifetimes do not change the code logic, and have nothing to do with memory allocation and deallocation, it is just programmer’s way to tell compiler the <em>relationship</em> between different references, so compiler can check possible dangling references during compiling time</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// in following function, when this funtion be called,</span>
<span class="c1">// the return value might be &amp;str1 or &amp;str2, it is decided during runtime</span>
<span class="c1">// by specifying the lifetime generic 'a, we tell compiler that</span>
<span class="c1">// the return value can not outlive the shortest lifetime of str1, str2</span>
<span class="c1">// based on this information, compiler will check for us statically the</span>
<span class="c1">// lifetimes of return value, str1, str2, if any violations, error will</span>
<span class="c1">// be issued</span>

<span class="c1">// 'a literally means that there must be some lifetime that is overlapped</span>
<span class="c1">// by str1 and str2, and the return value lives inside this lifetime</span>
<span class="c1">// if compiler can not find this lifetime during compile time, error</span>
<span class="c1">// will be generated</span>
<span class="k">fn</span> <span class="n">longest</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">str1</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="n">str2</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">str1</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">str2</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">str1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">str2</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// it's not possible to return str2, so no need to explicitly specify for str2</span>
<span class="k">fn</span> <span class="n">shortest</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">str1</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="n">str2</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">str2</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">100</span> <span class="p">{</span>
        <span class="n">str1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">str1</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Types that contain <em>reference</em> data elements also require lifetime specifier</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Some can not outlive name, otherwise there is dangling reference</span>
<span class="k">struct</span> <span class="nb">Some</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">{</span>
    <span class="n">name</span><span class="p">:</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">String</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Compiler assign every <em>reference</em> a lifetime at compiling time, if programmer does not explicitly specify one for it, and they are <em>different</em> lifetimes and do not have relationship between each other. When programmer explicitly specify a lifetime <em>generic</em> parameter, that means variables that have this lifetime must have <em>some</em> lifetime that all these variables must outlive. As for what is this lifetime, it is decided by compiler at check time</li>
  <li>
    <p><strong><a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision">Lifetime Elision</a></strong></p>

    <p>Sometimes programmer does not need to explicitly specify lifetimes, it is called <em>elision.</em></p>

    <ul>
      <li>Only function and method lifetimes have elision, struct definitions do not have <em>elision</em>, programmer must always explicitly specify lifetimes for struct definitions</li>
      <li>Lifetimes on function or method parameters are called <em>input lifetimes</em>, and lifetimes on return values are called <em>output lifetimes</em>.</li>
      <li>Compiler does <em>elision</em> based on three rules:
        <ul>
          <li>The first rule is that the compiler assigns a lifetime parameter to each parameter that’s a reference. They are different parameters</li>
          <li>The second rule is that, if there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters: <code class="language-plaintext highlighter-rouge">fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code></li>
          <li>The third rule is that, if there are multiple input lifetime parameters, but one of them is <code class="language-plaintext highlighter-rouge">&amp;self</code> or <code class="language-plaintext highlighter-rouge">&amp;mut self</code> because this is a method, the lifetime of <code class="language-plaintext highlighter-rouge">self</code> is assigned to all output lifetime parameters.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="11-writing-automated-tests">11. <strong><a href="https://doc.rust-lang.org/book/ch11-00-testing.html#writing-automated-tests">Writing Automated Tests</a></strong></h1>

<h2 id="111-how-to-write-tests">11.1 <strong><a href="https://doc.rust-lang.org/book/ch11-01-writing-tests.html#how-to-write-tests">How to Write Tests</a></strong></h2>

<p>There is no built-in test frameworks for C++. Rust somehow build one test framework like <em>Gtest</em> into it’s standard library.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">adder</span><span class="p">(</span><span class="n">left</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="n">left</span> <span class="o">+</span> <span class="n">right</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Guess</span> <span class="p">{</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Guess</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Guess</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="mi">200</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"value too big:{}"</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="nd">panic!</span><span class="p">(</span><span class="s">"value too small: {}"</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">Guess</span> <span class="p">{</span> <span class="n">value</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">test_adder</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nf">adder</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">test_adder_two</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="mi">4</span> <span class="o">==</span> <span class="nf">adder</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">test_adder_three</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_ne!</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nf">adder</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="c1">// should_panic to test panics</span>
    <span class="nd">#[should_panic]</span>
    <span class="k">fn</span> <span class="nf">should_panic</span><span class="p">()</span> <span class="p">{</span>
        <span class="nn">Guess</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">201</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="113-test-organization">11.3 <strong><a href="https://doc.rust-lang.org/book/ch11-03-test-organization.html#test-organization">Test Organization</a></strong></h2>

<p>Rust standard library supports two kinds of tests: <em>unit test</em> and <em>integration test</em>.</p>

<p>Unit test</p>

<hr />

<p>Unit test is used to test every <em>function or method</em>, it should be written inside the source file, with test attribute and a special module called <em>tests</em></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">it_works</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Integration Test</p>

<hr />

<p>Integration test is used to test <em>crate library</em> as a whole. It uses the to-be-tested library the same as how end user will use it.</p>

<ul>
  <li>Only <em>library crate</em> have integration test, <em>binary crate</em> do not need integration test, since itself is a executable</li>
</ul>

<p>The structure of integration test:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">├──</span> <span class="n">Cargo</span><span class="py">.lock</span>
<span class="err">├──</span> <span class="n">Cargo</span><span class="py">.toml</span>
<span class="err">├──</span> <span class="n">src</span>
<span class="err">│  </span> <span class="err">└──</span> <span class="n">lib</span><span class="py">.rs</span>
<span class="err">└──</span> <span class="n">tests</span>
    <span class="err">├──</span> <span class="n">common</span>
    <span class="err">│  </span> <span class="err">└──</span> <span class="k">mod</span><span class="py">.rs</span>
    <span class="err">└──</span> <span class="n">integration_test</span><span class="py">.rs</span>
</code></pre></div></div>

<ul>
  <li>Every source file <em>directly</em> under <em>tests</em> is treated as a individual <em>crate</em> and is a integration test unit</li>
  <li>Note the <em>common/mod.rs,</em> it is shared by all the integration test under <em>tests</em> folder, it has to be structured inside <em>common</em> folder, otherwise itself is treated as integration test too</li>
</ul>

<p>Then the integration test can be written as:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// bring to-be-test library into integration test crate</span>
<span class="k">use</span> <span class="n">adder</span><span class="p">;</span>

<span class="c1">//declare common module</span>
<span class="k">mod</span> <span class="n">common</span><span class="p">;</span>

<span class="nd">#[test]</span>
<span class="k">fn</span> <span class="nf">it_adds_two</span><span class="p">()</span> <span class="p">{</span>
    <span class="nn">common</span><span class="p">::</span><span class="nf">setup</span><span class="p">();</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nn">adder</span><span class="p">::</span><span class="nf">add_two</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="13-functional-language-features-iterators-and-closures">13. <strong><a href="https://doc.rust-lang.org/book/ch13-00-functional-features.html#functional-language-features-iterators-and-closures">Functional Language Features: Iterators and Closures</a></strong></h1>

<h2 id="131-closures-anonymous-functions-that-capture-their-environment">13.1 <strong><a href="https://doc.rust-lang.org/book/ch13-01-closures.html#closures-anonymous-functions-that-capture-their-environment">Closures: Anonymous Functions that Capture Their Environment</a></strong></h2>

<p><em>Rust’s closures are anonymous functions you can save in a variable or pass as arguments to other functions.</em> This has two meaning:</p>

<ul>
  <li>Closures can be called like functions</li>
  <li>Closures can be bind to variable, so that it obeys lifetime rules like variables</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">list</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Before defining closure: {:?}"</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

    <span class="c1">// here list is borrorwed mutablly by closure, Rust compiler infer this accoriding</span>
    <span class="c1">// to the operations inside closure body; also programmer can use 'move' keyword</span>
		<span class="c1">// to explicitly tell closure to take owner ship of captured variables</span>

    <span class="c1">// every closure is actually a data structure under the hood, Rust compiler keeps</span>
    <span class="c1">// all the addresses of the captured variables</span>

    <span class="c1">// if any parameters, Rust compiler will infer their type when the closure's first usage</span>
    
		<span class="k">let</span> <span class="k">mut</span> <span class="n">borrows_mutably</span> <span class="o">=</span> <span class="p">||</span> <span class="n">list</span><span class="nf">.push</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>

    <span class="c1">// this will tell compiler to take ownership of list, rather than use mut reference, which</span>
    <span class="c1">// is infered by the code in closure body</span>

    <span class="c1">// let mut borrows_mutably = move || list.push(7);</span>

    <span class="c1">// nok, since list is already mutablly borrowed, it can not be immutablly borrowed for now</span>
    <span class="c1">// println!("After calling closure: {:?}", list);</span>

    <span class="nf">borrows_mutably</span><span class="p">();</span>

    <span class="c1">// ok, closure has gone out of scope, now list can be borrowed again</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"After calling closure: {:?}"</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Closures capture the environment in three ways, like parameters in function:
    <ul>
      <li>Take the ownership of the captured variables</li>
      <li>Borrow immutably the captured variables</li>
      <li>Borrow mutably the captured variables</li>
      <li>Do not capture any variables in environment</li>
    </ul>
  </li>
  <li>
    <p>Closures are <em>types</em> that implement <em>Fn</em> traits. There are three kinds of <em>traits:</em></p>

    <blockquote>

      <ol>
        <li><code class="language-plaintext highlighter-rouge">FnOnce</code> applies to closures that can be called once. All closures implement at least this trait, because all closures can be called. A closure that moves captured values out of its body will only implement <code class="language-plaintext highlighter-rouge">FnOnce</code> and none of the other <code class="language-plaintext highlighter-rouge">Fn</code> traits, because it can only be called once.</li>
        <li><code class="language-plaintext highlighter-rouge">FnMut</code> applies to closures that don’t move captured values out of their body, but that might mutate the captured values. These closures can be called more than once.</li>
        <li><code class="language-plaintext highlighter-rouge">Fn</code> applies to closures that don’t move captured values out of their body and that don’t mutate captured values, as well as closures that capture nothing from their environment. These closures can be called more than once without mutating their environment, which is important in cases such as calling a closure multiple times concurrently.
          <ul>
            <li>Closures can implement <em>both</em> these traits</li>
            <li>These traits are <em>additive</em>, which means that when there is a situation that requires a <em>FnOnce</em> trait bound, one can pass closures that implement either of the trait; while if requires a <em>FnMut</em> closure, one can only pass <em>FnMut</em> or <em>Fn</em> closure.</li>
          </ul>
        </li>
      </ol>
    </blockquote>
  </li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">unwrap_or_else</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="n">F</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span>
    <span class="k">where</span>
				<span class="c1">// F must be a FnOnce closure, it can accept any closures</span>
        <span class="n">F</span><span class="p">:</span> <span class="nf">FnOnce</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">T</span>
    <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">x</span><span class="p">,</span>
            <span class="nb">None</span> <span class="k">=&gt;</span> <span class="nf">f</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="132-processing-a-series-of-items-with-iterators">13.2 <strong><a href="https://doc.rust-lang.org/book/ch13-02-iterators.html#processing-a-series-of-items-with-iterators">Processing a Series of Items with Iterators</a></strong></h2>

<ul>
  <li>All iterators implement a trait named <code class="language-plaintext highlighter-rouge">Iterator</code></li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">trait</span> <span class="nb">Iterator</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Item</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="c1">// methods with default implementations elided</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Note that <code class="language-plaintext highlighter-rouge">next</code> method is the basis for a serials of methods that compose the <code class="language-plaintext highlighter-rouge">Iterator</code> trait, which have default implementations</li>
  <li>There are three kinds of way to iterator over a sequence:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">iter()</code>: return immutable reference iterator</li>
      <li><code class="language-plaintext highlighter-rouge">iter_mut()</code>: return mutable reference iterator</li>
      <li><code class="language-plaintext highlighter-rouge">into_inter()</code>: return owned value iterator</li>
    </ul>
  </li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">v</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
    <span class="c1">// immutable reference</span>
    <span class="k">let</span> <span class="n">imu_it</span> <span class="o">=</span> <span class="n">v</span><span class="nf">.iter</span><span class="p">();</span>
    <span class="c1">// mutable reference; both iterator and variable need to be mutable</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">mu_it</span><span class="o">=</span><span class="n">v</span><span class="nf">.iter_mut</span><span class="p">();</span>
    <span class="c1">// take ownership</span>
    <span class="k">let</span> <span class="n">own_it</span> <span class="o">=</span> <span class="n">v</span><span class="nf">.into_iter</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Consuming adaptors</p>

<hr />

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">sum</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
        <span class="c1">// note that it does not need to be mutable to let sum() use next method, </span>
        <span class="c1">// since sum() will take owership of it: it works very like std::move in c++</span>
        <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="n">v</span><span class="nf">.iter</span><span class="p">();</span>
				<span class="c1">// now 'it' is consumed, it can not be used again</span>
        <span class="k">let</span> <span class="n">to</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="n">it</span><span class="nf">.sum</span><span class="p">();</span>

        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>Iterator adaptors</p>

<hr />

<p><em>Iterator adaptors</em> return a iterator that behaves different with the original iterator</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">map</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">v</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>

        <span class="k">let</span> <span class="n">it</span> <span class="o">=</span> <span class="n">v</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">i32</span><span class="p">|</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="c1">// collect method assign to new variable res</span>
        <span class="k">let</span> <span class="n">res</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">it</span><span class="nf">.collect</span><span class="p">();</span>
        <span class="c1">// true</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">res</span><span class="p">);</span>
        <span class="c1">// original value do not change</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]);</span>

        <span class="c1">// this will change v</span>
        <span class="c1">// note that map take a FnMut closure,which means it can change the captured variables</span>
        <span class="k">let</span> <span class="n">mu_it</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">v</span>
            <span class="nf">.iter_mut</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="p">{</span>
                <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="o">*</span><span class="n">x</span>
            <span class="p">})</span>
            <span class="nf">.collect</span><span class="p">();</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">mu_it</span><span class="p">,</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]);</span>

        <span class="c1">// this will change v</span>
        <span class="k">for</span> <span class="n">ele</span> <span class="k">in</span> <span class="n">v</span><span class="nf">.iter_mut</span><span class="p">()</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">ele</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]);</span>
    <span class="p">}</span>
</code></pre></div></div>

<h1 id="14-more-about-cargo-and-cratesio">14. <strong><a href="https://doc.rust-lang.org/book/ch14-00-more-about-cargo.html#more-about-cargo-and-cratesio">More About Cargo and Crates.io</a></strong></h1>

<h2 id="143-cargo-workspaces">14.3 <strong><a href="https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html#cargo-workspaces">Cargo Workspaces</a></strong></h2>

<p>Cargo workspace group together related packages and build them into one <em>target</em> folder.</p>

<ul>
  <li>Even though packages are grouped inside one workspace, they are independent packages, which means that their own dependencies need to be explicitly specified in their own <em>Cargo.toml</em> file and publishing to <em><a href="http://create.io">create.io</a></em> is also independent with each other</li>
  <li>Since all packages inside one workspace share the same <em>Cargo.lock</em> file, all dependencies of all packages are synced. If packages depend on same external package, this can assure  that they dependent on the same version</li>
</ul>

<h1 id="15-smart-pointers">15. <strong><a href="https://doc.rust-lang.org/book/ch15-00-smart-pointers.html#smart-pointers">Smart Pointers</a></strong></h1>

<h2 id="151-usingboxtto-point-to-data-on-the-heap">15.1 <strong><a href="https://doc.rust-lang.org/book/ch15-01-box.html#using-boxt-to-point-to-data-on-the-heap">Using <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> to Point to Data on the Heap</a></strong></h2>

<p>*Box<T>* can be compared with `new` key word in C++:</T></p>

<ul>
  <li>Allocate memory for instance of <em>T</em> in heap</li>
  <li>*Box<T>* type itself is known size(like pointer size returned by `new`)</T></li>
</ul>

<p>Comparing following code:</p>

<hr />

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">MyStruct</span><span class="p">{</span>
    <span class="n">node</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">MyStruct</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">MyStruct</span> <span class="p">{</span>
  <span class="n">MyStruct</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
  <span class="n">MyStruct</span><span class="p">()</span> <span class="p">{</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyStruct</span><span class="p">();</span> <span class="p">}</span>
  <span class="o">~</span><span class="n">MyStruct</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">node</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">or</span>

<span class="k">struct</span> <span class="nc">MyStruct</span> <span class="p">{</span>
  <span class="c1">// compile, but has segmentation fault(c++14)</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">MyStruct</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MyStruct</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div></div>

<ul>
  <li>Both Rust and C++ no NOT support use type of itself as data member, since this will obviously compose infinite loop</li>
  <li>However, containing member that is type of itself  is not the only way to come up with an infinite loop. Consider above code, both Rust and C++ code is infinite loop:
    <ul>
      <li>Even though both code does not contain member that is the type of itself, they contain a <em>ref</em> to instance that is the type of itself. This will cause infinite memory allocation in the heap, in other words this is just infinite loop in heap instead of stack</li>
      <li>To break infinite loop, two conditions have to be met:
        <ul>
          <li><strong>Type must not contain members that is the type of itself</strong></li>
          <li><strong>There must be a break point for chaining of member containing</strong></li>
        </ul>
      </li>
      <li>The crux here is <em>break</em> of the recursive chaining</li>
    </ul>
  </li>
  <li>To handle this, Rust and C++ takes different approach:
    <ul>
      <li>Since Rust do not support <em>default construction ,</em> user can not write code to create instance of <em>MyStruct</em>, because of the recursive nature of the type. Rust prevent this kind of mistake even before compile</li>
      <li>C++ compiler is not that responsible for your problem. The C++ code compiles and will segmentation fault at runtime since inside the constructor, the memory allocation is done recursively.</li>
    </ul>
  </li>
  <li>To <em>break</em> the recursive chaining, Rust and C++ also takes different approach:
    <ul>
      <li>C++ use <code class="language-plaintext highlighter-rouge">nullptr</code> , <code class="language-plaintext highlighter-rouge">unique_ptr</code> to break the chain</li>
      <li>Rust use <code class="language-plaintext highlighter-rouge">Option</code>, <code class="language-plaintext highlighter-rouge">Enum</code> to break the chain</li>
    </ul>
  </li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">MyStruct</span> <span class="p">{</span>
    <span class="n">node</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">MyStruct</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">MyStruct</span> <span class="p">{</span>
        <span class="n">node</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">MyStruct</span> <span class="p">{</span> <span class="n">node</span><span class="p">:</span> <span class="nb">None</span> <span class="p">})),</span>
    <span class="p">};</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"This compiles"</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">or</span>

<span class="k">struct</span> <span class="n">MyStruct</span> <span class="p">{</span>
    <span class="n">node</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">MyStruct</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">MyStruct</span> <span class="p">{</span>
        <span class="n">node</span><span class="p">:</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">MyStruct</span> <span class="p">{</span>
            <span class="n">node</span><span class="p">:</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nb">None</span><span class="p">),</span>
        <span class="p">})),</span>
    <span class="p">};</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"THIS ALSO COMPILES"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">MyStruct</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">MyStruct</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">MyStruct</span><span class="p">();</span>
  <span class="n">a</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MyStruct</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"a contains b"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>From above discussion, we can see that <code class="language-plaintext highlighter-rouge">std::unique_ptr</code> is comparable with <code class="language-plaintext highlighter-rouge">Option&lt;Box&lt;T&gt;&gt;</code> in Rust.</p>

<p>One more thing, following code does not compile either:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//recursive type `MyStruct` has infinite size</span>
<span class="k">struct</span> <span class="n">MyStruct</span> <span class="p">{</span>
    <span class="n">node</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">MyStruct</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Even type does not contain member that is of type itself and recursive chain can be broken by <code class="language-plaintext highlighter-rouge">None</code> of <code class="language-plaintext highlighter-rouge">Option</code> . This is because Rust calculate the memory size based on the largest possible member.</p>

<h2 id="152-treating-smart-pointers-like-regular-references-with-thedereftrait">15.2 <strong><a href="https://doc.rust-lang.org/book/ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait">Treating Smart Pointers Like Regular References with the <code class="language-plaintext highlighter-rouge">Deref</code> Trait</a></strong></h2>

<hr />

<blockquote>
  <p><em>Deref coercion</em> converts a reference to a type that implements the <code class="language-plaintext highlighter-rouge">Deref</code> trait into a reference to another type. For example, deref coercion can convert <code class="language-plaintext highlighter-rouge">&amp;String</code> to <code class="language-plaintext highlighter-rouge">&amp;str</code> because <code class="language-plaintext highlighter-rouge">String</code> implements the <code class="language-plaintext highlighter-rouge">Deref</code> trait such that it returns <code class="language-plaintext highlighter-rouge">&amp;str</code>. Deref coercion is a convenience Rust performs on arguments to functions and methods, and works only on types that implement the <code class="language-plaintext highlighter-rouge">Deref</code> trait. It happens automatically when we pass a reference to a particular type’s value as an argument to a function or method that doesn’t match the parameter type in the function or method definition. A sequence of calls to the <code class="language-plaintext highlighter-rouge">deref</code> method converts the type we provided into the type the parameter needs.</p>

</blockquote>

<p>Mechanism with <em>mut</em>:</p>

<ul>
  <li>From <code class="language-plaintext highlighter-rouge">&amp;T</code> to <code class="language-plaintext highlighter-rouge">&amp;U</code> when <code class="language-plaintext highlighter-rouge">T: Deref&lt;Target=U&gt;</code></li>
  <li>From <code class="language-plaintext highlighter-rouge">&amp;mut T</code> to <code class="language-plaintext highlighter-rouge">&amp;mut U</code> when <code class="language-plaintext highlighter-rouge">T: DerefMut&lt;Target=U&gt;</code></li>
  <li>From <code class="language-plaintext highlighter-rouge">&amp;mut T</code> to <code class="language-plaintext highlighter-rouge">&amp;U</code> when <code class="language-plaintext highlighter-rouge">T: Deref&lt;Target=U&gt;</code></li>
</ul>

<h2 id="153-running-code-on-cleanup-with-thedroptrait">15.3 <strong><a href="https://doc.rust-lang.org/book/ch15-03-drop.html#running-code-on-cleanup-with-the-drop-trait">Running Code on Cleanup with the <code class="language-plaintext highlighter-rouge">Drop</code> Trait</a></strong></h2>

<p><em>Drop</em> is comparable with <em>destructor in C++.</em></p>

<ul>
  <li>Unlike C++, in Rust programmer does not need to manually free memories, Rust compiler will do this for us. When a value is going out of scope, Rust will insert memory management code automatically.</li>
  <li><em>drop</em> function inside <em>Drop</em> trait works very much like <em>destructor</em> in C++
    <ul>
      <li>It is called automatically when value goes out of scope</li>
      <li>It can not be called manually, because there will be a <em>double free</em> problem just like C++
        <ul>
          <li>Rust prevent this at compile time</li>
          <li>C++ throws at runtime</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>Unlike in C++, Rust’s <em>drop</em> can be called with <code class="language-plaintext highlighter-rouge">std::mem::drop</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nb">drop</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">DropExample</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">Drop</span> <span class="k">for</span> <span class="n">DropExample</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{} is being dropped"</span><span class="p">,</span> <span class="k">self</span><span class="py">.data</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="n">DropExample</span> <span class="p">{</span>
        <span class="n">data</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">),</span>
    <span class="p">};</span>
    <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">DropExample</span> <span class="p">{</span>
        <span class="n">data</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"nihao"</span><span class="p">),</span>
    <span class="p">};</span>
    <span class="c1">// drop function take ownership of b and b goes out of scope when drop returns</span>
    <span class="nf">drop</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Now let's drop:"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="154-rct-the-reference-counted-smart-pointerhttpsdocrust-langorgbookch15-04-rchtmlrct-the-reference-counted-smart-pointer">15.4 <strong><code class="language-plaintext highlighter-rouge">[Rc&lt;T&gt;</code>, the Reference Counted Smart Pointer](https://doc.rust-lang.org/book/ch15-04-rc.html#rct-the-reference-counted-smart-pointer)</strong></h2>

<p>*Rc<T>* is NOT comparable with `std::share_ptr` in C++, where *Rc* means *reference count.* The C++ `std::share_ptr` use reference count like *Rc<T>, but it works under multi thread situations, in which it will have locks for the reference count(not for the data it carries, however) and can be used to mute the value inside,  while *Rc<T> in Rust:</T></T></T></p>

<ul>
  <li>*Rc<T>* is only for use in single-threaded cases</T></li>
  <li>Only immutable reference can be used inside *Rc<T>*</T></li>
</ul>

<h2 id="155-refcelltand-the-interior-mutability-patternhttpsdocrust-langorgbookch15-05-interior-mutabilityhtmlrefcellt-and-the-interior-mutability-pattern">15.5 <strong><code class="language-plaintext highlighter-rouge">[RefCell&lt;T&gt;</code> and the Interior Mutability Pattern](https://doc.rust-lang.org/book/ch15-05-interior-mutability.html#refcellt-and-the-interior-mutability-pattern)</strong></h2>

<p>*RefCell<T>* implement Rust borrow check at runtime. It wraps a value, this value can be borrowed as immutable or mutable at runtime, *RefCell<T>* will keep reference count for mutable borrow and immutable borrow at runtime, and do the borrow check during runtime, if the borrow check rules is violated, panic happens.</T></T></p>

<ul>
  <li>Like *Ref<T>* , it can only used on single thread situations. It only moves borrow check from compile time to runtime</T></li>
</ul>

<p>Comparison of *Ref<T>, Box<T>, RefCell<T>*:</T></T></T></p>

<ul>
  <li>*Box<T>* is just a way to store data on the heap, except that it behaves much like any other variables. It can be borrowed immutably and mutably and Rust compiler will do borrow check at compile time</T></li>
  <li>*Ref<T>*  is single threaded, multi-owner, compile time checked, immutable reference container
</T>    <ul>
      <li>*Ref<T>* stores value T in heap</T></li>
    </ul>
  </li>
  <li>*RefCell<T>* is single threaded, single-owner, runtime checked, mutable and immutable reference container
</T>    <ul>
      <li>*RefCell<T>* and *T* inside are stored together, there is no indirections involved, which is very different from *Box<t>* and *Ref<T>*</T></t></T></li>
    </ul>
  </li>
  <li>Both these three types <em>own</em>s the contained value</li>
</ul>

<h1 id="16-fearless-concurrency">16. <strong><a href="https://doc.rust-lang.org/book/ch16-00-concurrency.html#fearless-concurrency">Fearless Concurrency</a></strong></h1>

<h2 id="161-using-threads-to-run-code-simultaneously">16.1 <strong><a href="https://doc.rust-lang.org/book/ch16-01-threads.html#using-threads-to-run-code-simultaneously">Using Threads to Run Code Simultaneously</a></strong></h2>

<p>Rust use <em>closure</em> to start a thread:</p>

<ul>
  <li>If the closure need to catch variables in the environment, it must take ownership of it</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">thread</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="n">Duration</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
    <span class="c1">// have to use move to take ownership of v</span>
    <span class="k">let</span> <span class="n">handle</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="n">handle</span><span class="nf">.join</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>In this example, from the code we can see that the v outlives the thread because of the <em>join..</em> part. However, Rust compiler still does not compile if we remove the <em>move</em> keyword. It says that  if the new thread only use reference, it can not be certain that v will outlive the new thread(even it does in this example).  This is very important because this limitation makes foreign API calling without worries of data race:</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">process_ve</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">:</span><span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">){}</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">v</span><span class="o">=</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">];</span>
		<span class="c1">// here we farelessly call api with worries about data race</span>
		<span class="c1">// to v, since we know that if there is new thread inside</span>
		<span class="c1">// this api, v can not be passed into it, for the owership</span>
		<span class="c1">// can not be taken by the new thread</span>
    <span class="nf">process_ve</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">v</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">s</span><span class="o">=</span><span class="n">v</span><span class="nf">.get</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="n">s</span><span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="162-using-message-passing-to-transfer-data-between-threads">16.2 <strong><a href="https://doc.rust-lang.org/book/ch16-02-message-passing.html#using-message-passing-to-transfer-data-between-threads">Using Message Passing to Transfer Data Between Threads</a></strong></h2>

<p>Compared to C++, there is big difference between sharing data between threads:</p>

<ul>
  <li>C++ communicates by sharing data</li>
  <li>Rust sharing data by communication</li>
</ul>

<p>Rust use <em>channel</em>, which very much like <em>pipe</em> in Linux to <em>send</em> and <em>rec</em> between threads.</p>

<ul>
  <li><em>channel</em> can have multi senders, but only one receiver</li>
  <li>When sender sends data, it takes the ownership of the data</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="n">mpsc</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">thread</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">rx</span><span class="p">)</span> <span class="o">=</span> <span class="nn">mpsc</span><span class="p">::</span><span class="nf">channel</span><span class="p">();</span>

    <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">val</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hi"</span><span class="p">);</span>
        <span class="n">tx</span><span class="nf">.send</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="c1">// val ownership is taken, can not be borrowed anymore</span>
        <span class="c1">// println!("val is {}", val);</span>
    <span class="p">});</span>

    <span class="k">let</span> <span class="n">received</span> <span class="o">=</span> <span class="n">rx</span><span class="nf">.recv</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Got: {}"</span><span class="p">,</span> <span class="n">received</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="163-shared-state-concurrency">16.3 <strong><a href="https://doc.rust-lang.org/book/ch16-03-shared-state.html#shared-state-concurrency">Shared-State Concurrency</a></strong></h2>

<p>Introducing two more smart pointers for concurrent programming:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Arc&lt;T&gt;</code>: it is the counter part of <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> , the difference lies in that <code class="language-plaintext highlighter-rouge">Arc&lt;T&gt;</code> allow <em>atomic</em> updating of the reference counter, making it usable in multi-threading situations
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> exist because in single thread situations, it has less overhead than <code class="language-plaintext highlighter-rouge">Arc&lt;T&gt;</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Mutex&lt;T&gt;</code>: it is the counter part of <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code>, the difference lies in that <code class="language-plaintext highlighter-rouge">Mutex&lt;T&gt;</code> requires obtaining lock before borrow the value inside, making it suitable for multi thread situations.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Mutex&lt;T&gt;</code> has <em>interior mutability</em> like <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code></li>
    </ul>
  </li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nb">Arc</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="n">Mutex</span><span class="p">;</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">counter</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Mutex</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">handles</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">10</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">counter</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">counter</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">handle</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">m</span> <span class="o">=</span> <span class="n">counter</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="o">*</span><span class="n">m</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">});</span>
        <span class="n">handles</span><span class="nf">.push</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">handle</span> <span class="k">in</span> <span class="n">handles</span> <span class="p">{</span>
        <span class="n">handle</span><span class="nf">.join</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">counter</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="17-object-oriented-programming-features-of-rust">17. <strong><a href="https://doc.rust-lang.org/book/ch17-00-oop.html#object-oriented-programming-features-of-rust">Object-Oriented Programming Features of Rust</a></strong></h1>

<h2 id="172-using-trait-objects-that-allow-for-values-of-different-types">17.2 <strong><a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">Using Trait Objects That Allow for Values of Different Types</a></strong></h2>

<p>Trait object in Rust can be compared with virtual base class in C++. There underlying mechanism is the same:</p>

<ul>
  <li>Both use a <em>pointer</em> to object + a <em>vtable</em> that contain method indirection to achieve runtime polymorphism</li>
</ul>

<p>Runtime polymorphism and generics(or <em>template</em> in C++)</p>

<hr />

<ul>
  <li><em>generic</em> and <em>template</em> are statically dispatched at compile time(<em>static dispatch</em>), which means that their specific type is determined by the compiler at compiling time. They are <em>instantiated</em> during compilation</li>
  <li>Runtime polymorphism is dynamically dispatched at runtime(<em>dynamic dispatch</em>), which means that, at compile time, the compiler only know the <em>base type</em>(C++), or <em>trait</em>(Rust), compiler does not know the exact type.  So at compile time, compiler will only do <em>base type</em> or <em>trait</em> check. However, it is not enough to only have these information for the program to run. The compiler also need to <em>construct</em> a <em>vtable</em>, which is used to look up method of the <em>base type</em> and <em>trait</em> at runtime. Now the program knows a <em>pointer</em> to object and a <em>vtable</em> that is used to find method of the object, at runtime the program use these two information to call methods(For C++, <em>vtable</em> pointer is always the first member after the object pointer).
    <ul>
      <li>Every derived type in C++ and every type that implement some trait can be statically cast by the compiler to the base type pointer in C++ or <em>trait object</em> (which is also pointer) in Rust, plus (or included by the type pointer, if the vtable can be got by offset of the type pointer) a <em>vtable</em></li>
    </ul>
  </li>
</ul>

<p>Limitations of runtime polymorphism</p>

<hr />

<p>Runtime polymorphism seems to make the language dynamic typed, but it is not true. Dynamic language like Python keeps all meta data of a type, such as member name, method name and corresponding address. And object members can be changed at runtime. Runtime polymorphism is just a <em>trick</em> of the static language, which only have limited functionality:</p>

<ul>
  <li>Compiler will still check the <em>base type</em>(C++) or <em>trait</em>(Rust), statically</li>
</ul>

<p>Implementation difference between C++ and Rust</p>

<hr />

<p>Although the underlying mechanism is similar, C++ and Rust is different:</p>

<ul>
  <li>C++ use virtual base class based on <em>inheritance</em>. At runtime the derived type is <em>downcast</em> to the base type, which means that the derived type contains a continuous memory that can be cast into a base type object. Besides, virtual base class can also have data members.</li>
  <li>Rust use <em>trait</em>, like Java’s <em>interface</em>. It can not have data members. It’s a more modern way to use <em>interface</em> instead of <em>inheritance</em>, it makes the relationship more concise, while <em>inheritance</em> often inherit data members that the derived type does not need.</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">env</span><span class="p">;</span>

<span class="k">trait</span> <span class="n">Sound</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">make_sound</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">Color</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">is_white</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Dog</span> <span class="p">{</span>
    <span class="n">kind</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">color</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Color</span> <span class="k">for</span> <span class="n">Dog</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">is_white</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"i am of color {}"</span><span class="p">,</span> <span class="k">self</span><span class="py">.color</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Sound</span> <span class="k">for</span> <span class="n">Dog</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">make_sound</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"wang wang!, i am {}"</span><span class="p">,</span> <span class="k">self</span><span class="py">.kind</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Cat</span> <span class="p">{</span>
    <span class="n">kind</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Sound</span> <span class="k">for</span> <span class="n">Cat</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">make_sound</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"meow meow, i am {}"</span><span class="p">,</span> <span class="k">self</span><span class="py">.kind</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">zoo</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="n">Sound</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>
    <span class="c1">// Dog or Cat is not known at compile time</span>
    <span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="nn">env</span><span class="p">::</span><span class="nf">args</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">item</span> <span class="o">==</span> <span class="s">"Dog"</span> <span class="p">{</span>
            <span class="c1">// at compile time compiler will check pushed type and cast it to Sound trait object type</span>
            <span class="n">zoo</span><span class="nf">.push</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Dog</span> <span class="p">{</span>
                <span class="n">kind</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"any"</span><span class="p">),</span>
                <span class="n">color</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"any"</span><span class="p">),</span>
            <span class="p">}))</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">item</span> <span class="o">==</span> <span class="s">"Cat"</span> <span class="p">{</span>
            <span class="n">zoo</span><span class="nf">.push</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">Cat</span> <span class="p">{</span>
                <span class="n">kind</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"any"</span><span class="p">),</span>
            <span class="p">}))</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">animal</span> <span class="k">in</span> <span class="n">zoo</span> <span class="p">{</span>
        <span class="n">animal</span><span class="nf">.make_sound</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(){};</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">AnotherBase</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">g</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">DerivedOne</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AnotherBase</span><span class="p">,</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">g</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"from another base"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"from DerivedOne"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">DerivedTwo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"from DerivedTwo"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// return pointer to Base, but we do not know which type at compile time</span>
<span class="n">Base</span> <span class="o">*</span><span class="nf">some_func</span><span class="p">(</span><span class="kt">bool</span> <span class="n">flg</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">flg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">DerivedOne</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DerivedOne</span><span class="p">();</span>
    <span class="c1">// when return, compiler will generate code that donwcast Drived type to</span>
    <span class="c1">// Base, this makes all the differences</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">DerivedTwo</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DerivedTwo</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">b</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stoi</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
  <span class="c1">// this will call different functions depending on user's input during runtime</span>
  <span class="n">some_func</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">f</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="19-advanced-features">19. <strong><a href="https://doc.rust-lang.org/book/ch19-00-advanced-features.html#advanced-features">Advanced Features</a></strong></h1>

<h2 id="192-unsafe-rust">19.2 <strong><a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#unsafe-rust">Unsafe Rust</a></strong></h2>

<p>Dereferencing raw pointers</p>

<hr />

<p>Two kinds of raw pointers:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">*const T</code>:pointer to const variable, like <code class="language-plaintext highlighter-rouge">const T*</code> in C++</li>
  <li><code class="language-plaintext highlighter-rouge">*mut T</code>: pointer to mutable variable, like <code class="language-plaintext highlighter-rouge">T*</code> in C++</li>
</ul>

<blockquote>

  <ul>
    <li>Are allowed to ignore the borrowing rules by having both immutable and mutable pointers or multiple mutable pointers to the same location</li>
    <li>Aren’t guaranteed to point to valid memory</li>
    <li>Are allowed to be null</li>
    <li>Don’t implement any automatic cleanup</li>
  </ul>
</blockquote>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">r1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">num</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">i32</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">r2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">num</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">i32</span><span class="p">;</span>
    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"r1 is {}"</span><span class="p">,</span> <span class="o">*</span><span class="n">r1</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"r2 is {}"</span><span class="p">,</span> <span class="o">*</span><span class="n">r2</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Calling unsafe functions or methods</p>

<hr />

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">dangerous</span><span class="p">()</span> <span class="p">{}</span>

<span class="k">unsafe</span> <span class="p">{</span>
        <span class="nf">dangerous</span><span class="p">();</span>
    <span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>There can be unsafe blocks inside normal function or method!! The unsafe code does not make the whole function method unsafe</li>
  <li>External functions from other languages are all <em>unsafe</em>, since they are not checked by Rust compiler</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">abs</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Absolute value of -3 according to C: {}"</span><span class="p">,</span> <span class="nf">abs</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Accessing mutable global variables</p>

<hr />

<p>In Rust, global variables are called <em>static variables:</em></p>

<ul>
  <li>They have fixed memory address(unlike <em>const</em>, which might be duplicated when necessary)</li>
  <li>They can be <em>mutable</em> or <em>immutable</em>
    <ul>
      <li>When they are <em>mutable</em>, accessing them is <em>unsafe</em></li>
    </ul>
  </li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">mut</span> <span class="n">COUNTER</span><span class="p">:</span> <span class="nb">i32</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">incre</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="n">COUNTER</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">incre</span><span class="p">();</span>
    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"counter is {}"</span><span class="p">,</span> <span class="n">COUNTER</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Implementing unsafe trait</p>

<hr />

<p>If one of trait method contains code that the compiler can not verify, such as raw pointer, the trait need to be specified using <em>unsafe</em>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">unsafe</span> <span class="k">trait</span> <span class="n">Foo</span> <span class="p">{</span>
    <span class="c1">// methods go here</span>
<span class="p">}</span>

<span class="k">unsafe</span> <span class="k">impl</span> <span class="n">Foo</span> <span class="k">for</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="c1">// method implementations go here</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{}</span>
</code></pre></div></div>

<h2 id="192-advanced-traits">19.2 <strong><a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#advanced-traits">Advanced Traits</a></strong></h2>

<p>Associate types</p>

<hr />

<p>Inside trait definition associate types can be specified; it is a type placeholder, when implement the trait, the final type of the type placeholder will be specified:</p>

<ul>
  <li>It works like generic, but it can only be specified once, during implementation, while generic can specify many times during implementation(<em>specification)</em> , or instantiation</li>
</ul>

<p>Default generic types</p>

<hr />

<p>Trait can be generic. Generic can have default type. The generic in Rust is very flexible.</p>

<ul>
  <li>Default type saves type annotation every time the trait is used, at the same time allow future type specialization</li>
  <li>Default type also allow future modification of the trait, with additional type parameters, without breaking previous implementation of the same trait</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// trait itself is generic, with default type</span>
<span class="k">trait</span> <span class="nb">Some</span><span class="o">&lt;</span><span class="n">T</span> <span class="o">=</span> <span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">f</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">T</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// since generic type has default value, we can in the future extend type parameter</span>
<span class="c1">// with default value like following, without break previous implementation</span>
<span class="c1">// replace above Some with following Some, the code still compiles, even now</span>
<span class="c1">// we have another generic parameter U</span>

<span class="c1">// trait Some&lt;T = i32, U = String&gt; {</span>
<span class="c1">//     fn f(&amp;self, a: T) {}</span>
<span class="c1">// }</span>

<span class="c1">// fn inside trait is generic</span>
<span class="k">trait</span> <span class="n">AnotherTrait</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">g</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">SampleStruct</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
<span class="p">}</span>
<span class="k">struct</span> <span class="n">AnotherStruct</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">ThirdStruct</span> <span class="p">{}</span>

<span class="k">struct</span> <span class="n">FourthStruct</span> <span class="p">{}</span>

<span class="c1">// Some here is template implemetnation</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="nb">Some</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">SampleStruct</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">f</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">U</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// conbine two types into one, trait and AnotherStruct must have same type</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Some</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">AnotherStruct</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">f</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">AnotherTrait</span> <span class="k">for</span> <span class="n">SampleStruct</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// here the we can not use T as placeholder, because it have been used for SampleStruct</span>
    <span class="c1">// the reason is that the generic is method type, when the method is called</span>
    <span class="c1">// it can have unique parameter type than SampleStruct</span>
    <span class="k">fn</span> <span class="n">g</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// use Some's defautl type i32</span>
<span class="k">impl</span> <span class="nb">Some</span> <span class="k">for</span> <span class="n">ThirdStruct</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">f</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// specialization for Some</span>
<span class="k">impl</span> <span class="nb">Some</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">FourthStruct</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">f</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="n">SampleStruct</span> <span class="p">{</span>
        <span class="n">data</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="c1">// can accept different types</span>
    <span class="n">s</span><span class="nf">.f</span><span class="p">(</span><span class="mi">23</span><span class="p">);</span>
    <span class="n">s</span><span class="nf">.f</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">));</span>

    <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="n">AnotherStruct</span> <span class="p">{</span>
        <span class="n">data</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">),</span>
    <span class="p">};</span>

    <span class="c1">// a.f(23);</span>
    <span class="c1">// can only be String, since AnotherStrcut and Some must have same type</span>
    <span class="n">a</span><span class="nf">.f</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"helo"</span><span class="p">));</span>

    <span class="c1">// type for g have nothing to do with SampleStruct</span>
    <span class="n">s</span><span class="py">.g</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Fully Qualified Syntax</p>

<hr />

<p>Rust allow same named methods and functions inside one type, to distinguish which methods to call, fully qualified syntax must be used:</p>

<p>*<Type as="" Trait="">::function(receiver_if_method, next_arg, ...);*</Type></p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Human</span><span class="p">;</span>
<span class="k">impl</span> <span class="n">Human</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">introduce</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"I am human"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">Teacher</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">introduce</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">Polic</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">introduce</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Teacher</span> <span class="k">for</span> <span class="n">Human</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">introduce</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"I am teacher"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Polic</span> <span class="k">for</span> <span class="n">Human</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">introduce</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"I am polic"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">human</span> <span class="o">=</span> <span class="n">Human</span><span class="p">;</span>
    <span class="c1">// calling introduce of Human</span>
    <span class="n">human</span><span class="nf">.introduce</span><span class="p">();</span>
    <span class="nn">Human</span><span class="p">::</span><span class="nf">introduce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">human</span><span class="p">);</span>
    <span class="c1">// calling Teacher::introduce</span>
    <span class="o">&lt;</span><span class="n">Human</span> <span class="k">as</span> <span class="n">Teacher</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">introduce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">human</span><span class="p">);</span>
    <span class="c1">// calling Polic::introduce</span>
    <span class="o">&lt;</span><span class="n">Human</span> <span class="k">as</span> <span class="n">Polic</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">introduce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">human</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Supertrait</p>

<hr />

<p>When implement one trait for a type, we can require that the type must also implement other traits. The trait we are implementing now depend on other traits.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">fmt</span><span class="p">;</span>

<span class="c1">// types that implement OutlinePrint must also implement Display</span>
<span class="k">trait</span> <span class="n">OutlinePrint</span><span class="p">:</span> <span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">outline_print</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="193-advanced-types">19.3 <strong><a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html#advanced-types">Advanced Types</a></strong></h2>

<p>Newtype</p>

<hr />

<p>A <em>newtype</em> is a type wrapped inside a <em>tuple struct</em>, this type will be treated by compiler as a new type. It can be used when:</p>

<ul>
  <li>Wrap an external type so we can implement external trait on this wrapper</li>
  <li>Wrap an regular type so we can give a special meaning to this type</li>
</ul>

<p>Note that <em>newtype</em> is a real type, not the same as <em>type alias</em>, which is just syntax sugar and not treated by compiler as real type.</p>

<p>Type alias</p>

<hr />

<p>Type alias can be compared with <em>using</em> statement in C++. It is used for a better code style. Compiler will replace the real type during compilation.</p>

<p><em>!</em> never return type</p>

<hr />

<p><code class="language-plaintext highlighter-rouge">!</code> type is a special type that can be coerced into any other type</p>

<p><strong><a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait">Dynamically Sized Types and the <code class="language-plaintext highlighter-rouge">Sized</code> Trait</a></strong></p>

<hr />

<p>Dynamically sized types are types whose memory occupation is not known at compiling time. This characteristic determines that we have to to <em>pointer</em> to refer to those types.</p>

<p>For example, <code class="language-plaintext highlighter-rouge">str</code> in Rust is dynamically sized type, we can not create <code class="language-plaintext highlighter-rouge">str</code> types directly, since we do not know how many memory this variable will take. However we can use <code class="language-plaintext highlighter-rouge">&amp;str</code> type to point to <code class="language-plaintext highlighter-rouge">str</code> type, <code class="language-plaintext highlighter-rouge">&amp;str</code> type is actually fixed sized, it stores address of the <code class="language-plaintext highlighter-rouge">str</code> and the length of the character. Similarly, <code class="language-plaintext highlighter-rouge">Box&lt;str&gt;</code> or <code class="language-plaintext highlighter-rouge">Rc&lt;str&gt;</code> is also correct since they are also pointers under the hood.</p>

<ul>
  <li>Every trait is a dynamically sized type we can refer to by using the name of the trait. Trait objects are all dynamically sized types</li>
  <li>Rust provides the <code class="language-plaintext highlighter-rouge">Sized</code> trait to determine whether or not a type’s size is known at compile time. This trait is automatically implemented for everything whose size is known at compile time.</li>
  <li>Rust implicitly adds a bound on <code class="language-plaintext highlighter-rouge">Sized</code> to every generic function. Which means generic functions by default can only accept fixed sized type as parameters. To work with dynamically sized types for generic functions, it has to be explicitly specified:</li>
</ul>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// note the return type has to be a pointer like type</span>
<span class="k">fn</span> <span class="n">generic</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// --snip--</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="194-advanced-functions-and-closures">19.4 <strong><a href="https://doc.rust-lang.org/book/ch19-05-advanced-functions-and-closures.html#advanced-functions-and-closures">Advanced Functions and Closures</a></strong></h2>

<p>Function pointer</p>

<hr />

<p><code class="language-plaintext highlighter-rouge">fn</code> is the function pointer type.  Comparison with <em>closure</em>:</p>

<ul>
  <li><em>closures</em> in Rust can be seen as anonymous function type(like closures in C++)</li>
  <li><code class="language-plaintext highlighter-rouge">fn</code> can be seen as named function type(like <code class="language-plaintext highlighter-rouge">std::function</code> in C++)</li>
  <li>Whether anonymous or named, they both can be seen as <em>type</em></li>
  <li><em>closures</em> can catch environment variables, while <code class="language-plaintext highlighter-rouge">fn</code> can not</li>
  <li>Since <em>closures</em> can capture variables, so according to the capture manner: mutable borrow, immutable borrow, take, there are three <em>trait</em> that Rust compiler will implicitly implement for every <em>closure</em>: <code class="language-plaintext highlighter-rouge">FnOnce</code>, <code class="language-plaintext highlighter-rouge">FnMut</code>, <code class="language-plaintext highlighter-rouge">Fn</code>, these <em>traits</em> are used to describe the capture manners.</li>
  <li><code class="language-plaintext highlighter-rouge">fn</code> implement all three <em>traits</em>: <code class="language-plaintext highlighter-rouge">FnOnce</code>, <code class="language-plaintext highlighter-rouge">FnMut</code>, <code class="language-plaintext highlighter-rouge">Fn</code> because function pointers do not capture environment variables, so it will not influence it’s environment and can be called as may times. So anywhere a <em>closure</em> is capable, a function pointer with the same signature can also be used.</li>
  <li>Both <em>closure</em> and function pointer have signatures, but there some differences:
    <ul>
      <li>programmer does not need to annotate types when creating <em>closure,</em> since the types can be inferred from the <em>user</em> of the <em>closure</em></li>
      <li><code class="language-plaintext highlighter-rouge">fn</code> must annotate the type for the signatures because <code class="language-plaintext highlighter-rouge">fn</code> are supposed to be used in anywhere</li>
      <li>In simple words: <em>closures</em> are first defined by the <em>user</em> and then implemented when used; <code class="language-plaintext highlighter-rouge">fn</code> are first defined and implemented, and then called by <em>user</em> of the function.</li>
    </ul>
  </li>
</ul>

<p>Returning closure</p>

<hr />

<p>Since <em>closures</em> are anonymous, they can not be returned. But since <em>closures</em> implement <em>trait</em> and <em>closures</em> can be treated as <em>trait object,</em> so closures can be returned like this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// define the closure</span>
<span class="k">fn</span> <span class="nf">return_closure</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nf">Fn</span><span class="p">(</span><span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// implement closure, no type annotation is requred, can be</span>
    <span class="c1">// inferred from Box&lt;dyn Fn(i32)-&gt;i32&gt;</span>
    <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="nf">return_closure</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="nf">a</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

  </div><a class="u-url" href="/2023/08/12/C++-programmer's-guide-to-Rust.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">shanweiqiang&#39;s blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">shanweiqiang&#39;s blog</li><li><a class="u-email" href="mailto:schmessi@163.com">schmessi@163.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/shan-weiqiang"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">shan-weiqiang</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
