<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-06-29T15:20:50+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">shanweiqiangâ€™s blog</title><subtitle></subtitle><entry><title type="html">Protobuf Reflection</title><link href="http://localhost:4000/2025/06/14/protobuf-reflection.html" rel="alternate" type="text/html" title="Protobuf Reflection" /><published>2025-06-14T09:22:46+08:00</published><updated>2025-06-14T09:22:46+08:00</updated><id>http://localhost:4000/2025/06/14/protobuf-reflection</id><content type="html" xml:base="http://localhost:4000/2025/06/14/protobuf-reflection.html"><![CDATA[<p>I talked about types in <a href="https://shan-weiqiang.github.io/2024/07/14/understanding-types.html">Type system and language bindings</a>. Today I go deep into one specific type system: Google Protocol Buffers(GPB). GPB support introspection, reflection, dynamic type, dynamic data. However, I do not consider GPB a true dynamic typing system and I will talk about why after we have a deep look at how GPB works.</p>

<ul id="markdown-toc">
  <li><a href="#gpb-workflow" id="markdown-toc-gpb-workflow">GPB Workflow</a></li>
  <li><a href="#how-reflection-work" id="markdown-toc-how-reflection-work">How reflection work</a></li>
  <li><a href="#code-demo" id="markdown-toc-code-demo">Code demo</a></li>
  <li><a href="#why-gpb-is-not-true-dynamic-type" id="markdown-toc-why-gpb-is-not-true-dynamic-type">Why GPB is not true dynamic type</a></li>
</ul>

<h2 id="gpb-workflow">GPB Workflow</h2>

<p>The main workflow starts from <em>proto</em> definition files and <em>protoc</em> compiler will compile them into C++ types, which user will use directly. The process can be illustrated like following:</p>

<p><img src="/assets/images/workflow.png" alt="alt text" /></p>

<p>The main design pattern of GPB is static generation plus <a href="https://shan-weiqiang.github.io/2025/04/20/type-erasure.html">type erasure</a> in C++. All user-defined specific types inherit from the <em>Message</em> base type. All user-defined type information, like field name, field type, message name, field offsets are statically generated and stored in protoc-generated C++ files. During runtime, before main, those information will be registered into global <em>DescriptorPool</em>.</p>

<h2 id="how-reflection-work">How reflection work</h2>

<p>The message creation is based on type erasure. Member access is based on static offset information and type descriptor information. Dynamic type creation is based on <em>DynamicMessage</em> type.</p>

<p><img src="/assets/images/reflection.png" alt="alt text" /></p>

<p>When user calls <code class="language-plaintext highlighter-rouge">MessageFactory::generated_factory()-&gt;GetPrototype(descriptor)-&gt;New()</code>, GPB returns a <em>Message</em> type. Underneath this virtual type, there are two possibilities:</p>

<ul>
  <li>The protoc-generated C++ type, which is specific C++ type, and the returned <em>Message</em> type can be cast to it dynamically.</li>
  <li><em>DynamicMessage</em> type, which is constructed at runtime by protobuf library.</li>
</ul>

<h2 id="code-demo">Code demo</h2>

<p>Here I did a demonstration about protocol buffers advanced usage, the whole code can be found at <a href="https://github.com/shan-weiqiang/lab/tree/main/protobuf_reflection">protobuf reflection code demo</a>.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"my_message.pb.h"</span><span class="c1"> // Generated by protoc</span><span class="cp">
#include</span> <span class="cpf">&lt;absl/strings/string_view.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;google/protobuf/compiler/importer.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;google/protobuf/compiler/parser.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;google/protobuf/descriptor.pb.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;google/protobuf/dynamic_message.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;google/protobuf/text_format.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">// Custom SourceTree for in-memory .proto files</span>
<span class="k">class</span> <span class="nc">MemorySourceTree</span> <span class="o">:</span> <span class="k">public</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">compiler</span><span class="o">::</span><span class="n">SourceTree</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">MemorySourceTree</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">content</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">filename_</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">content_</span><span class="p">(</span><span class="n">content</span><span class="p">)</span> <span class="p">{}</span>

  <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">ZeroCopyInputStream</span> <span class="o">*</span>
  <span class="n">Open</span><span class="p">(</span><span class="n">absl</span><span class="o">::</span><span class="n">string_view</span> <span class="n">filename</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">filename</span> <span class="o">!=</span> <span class="n">filename_</span><span class="p">)</span>
      <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">ArrayInputStream</span><span class="p">(</span>
        <span class="n">content_</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">content_</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">filename_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">content_</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">GOOGLE_PROTOBUF_VERIFY_VERSION</span><span class="p">;</span>

  <span class="c1">// ============================================</span>
  <span class="c1">// Section 1: Static Message Creation</span>
  <span class="c1">// Demonstrates creating a message using the generated C++ class</span>
  <span class="c1">// This is the most common and straightforward way to use protobuf</span>
  <span class="c1">// ============================================</span>
  <span class="n">test</span><span class="o">::</span><span class="n">MyMessage</span> <span class="n">static_msg</span><span class="p">;</span>
  <span class="n">static_msg</span><span class="p">.</span><span class="n">set_id</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span>
  <span class="n">static_msg</span><span class="p">.</span><span class="n">set_name</span><span class="p">(</span><span class="s">"Static Message"</span><span class="p">);</span>

  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">=== Section 1: Static Message Creation ===</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"----------------------------------------</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Message Content:</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">static_msg</span><span class="p">.</span><span class="n">DebugString</span><span class="p">();</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Type: "</span> <span class="o">&lt;&lt;</span> <span class="n">static_msg</span><span class="p">.</span><span class="n">GetTypeName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n\n</span><span class="s">"</span><span class="p">;</span>

  <span class="c1">// ============================================</span>
  <span class="c1">// Section 2: Dynamic Message Creation</span>
  <span class="c1">// Shows how to create a message using the descriptor and reflection APIs</span>
  <span class="c1">// This is useful when you don't have the generated C++ class at compile time</span>
  <span class="c1">// ============================================</span>
  <span class="k">const</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Descriptor</span> <span class="o">*</span><span class="n">descriptor</span> <span class="o">=</span>
      <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">DescriptorPool</span><span class="o">::</span><span class="n">generated_pool</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">FindMessageTypeByName</span><span class="p">(</span>
          <span class="s">"test.MyMessage"</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">descriptor</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Descriptor not found!"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Message</span> <span class="o">*</span><span class="n">dynamic_msg</span> <span class="o">=</span>
      <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">MessageFactory</span><span class="o">::</span><span class="n">generated_factory</span><span class="p">()</span>
          <span class="o">-&gt;</span><span class="n">GetPrototype</span><span class="p">(</span><span class="n">descriptor</span><span class="p">)</span>
          <span class="o">-&gt;</span><span class="n">New</span><span class="p">();</span>

  <span class="c1">// ============================================</span>
  <span class="c1">// Section 3: Type Identity Verification</span>
  <span class="c1">// Proves that static and dynamic messages are of the same type</span>
  <span class="c1">// Demonstrates that dynamic messages can be cast to their static counterparts</span>
  <span class="c1">// ============================================</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">=== Section 3: Type Identity Verification ===</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"-------------------------------------------</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Are descriptors identical? "</span>
       <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">descriptor</span> <span class="o">==</span> <span class="n">test</span><span class="o">::</span><span class="n">MyMessage</span><span class="o">::</span><span class="n">descriptor</span><span class="p">()</span> <span class="o">?</span> <span class="s">"YES"</span> <span class="o">:</span> <span class="s">"NO"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

  <span class="n">test</span><span class="o">::</span><span class="n">MyMessage</span> <span class="o">*</span><span class="n">converted_msg</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">test</span><span class="o">::</span><span class="n">MyMessage</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">dynamic_msg</span><span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Dynamic cast successful? "</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">converted_msg</span> <span class="o">?</span> <span class="s">"YES"</span> <span class="o">:</span> <span class="s">"NO"</span><span class="p">)</span>
       <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n\n</span><span class="s">"</span><span class="p">;</span>

  <span class="c1">// ============================================</span>
  <span class="c1">// Section 4: Memory Compatibility Test</span>
  <span class="c1">// Shows that dynamic messages can be modified and accessed just like static</span>
  <span class="c1">// ones Demonstrates the memory layout compatibility between static and</span>
  <span class="c1">// dynamic messages</span>
  <span class="c1">// ============================================</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">=== Section 4: Memory Compatibility Test ===</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"------------------------------------------</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

  <span class="c1">// Set the same values in dynamic_msg as in static_msg</span>
  <span class="k">const</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Reflection</span> <span class="o">*</span><span class="n">compat_reflection</span> <span class="o">=</span>
      <span class="n">dynamic_msg</span><span class="o">-&gt;</span><span class="n">GetReflection</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Descriptor</span> <span class="o">*</span><span class="n">compat_desc</span> <span class="o">=</span>
      <span class="n">dynamic_msg</span><span class="o">-&gt;</span><span class="n">GetDescriptor</span><span class="p">();</span>

  <span class="k">const</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">FieldDescriptor</span> <span class="o">*</span><span class="n">compat_id_field</span> <span class="o">=</span>
      <span class="n">compat_desc</span><span class="o">-&gt;</span><span class="n">FindFieldByName</span><span class="p">(</span><span class="s">"id"</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">FieldDescriptor</span> <span class="o">*</span><span class="n">compat_name_field</span> <span class="o">=</span>
      <span class="n">compat_desc</span><span class="o">-&gt;</span><span class="n">FindFieldByName</span><span class="p">(</span><span class="s">"name"</span><span class="p">);</span>

  <span class="n">compat_reflection</span><span class="o">-&gt;</span><span class="n">SetInt32</span><span class="p">(</span><span class="n">dynamic_msg</span><span class="p">,</span> <span class="n">compat_id_field</span><span class="p">,</span> <span class="n">static_msg</span><span class="p">.</span><span class="n">id</span><span class="p">());</span>
  <span class="n">compat_reflection</span><span class="o">-&gt;</span><span class="n">SetString</span><span class="p">(</span><span class="n">dynamic_msg</span><span class="p">,</span> <span class="n">compat_name_field</span><span class="p">,</span>
                               <span class="n">static_msg</span><span class="p">.</span><span class="n">name</span><span class="p">());</span>

  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Static message content:</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">static_msg</span><span class="p">.</span><span class="n">DebugString</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Dynamic message content:</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">dynamic_msg</span><span class="o">-&gt;</span><span class="n">DebugString</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

  <span class="c1">// Compare serialized values</span>
  <span class="n">string</span> <span class="n">compat_static_serialized</span><span class="p">,</span> <span class="n">compat_dynamic_serialized</span><span class="p">;</span>
  <span class="n">static_msg</span><span class="p">.</span><span class="n">SerializeToString</span><span class="p">(</span><span class="o">&amp;</span><span class="n">compat_static_serialized</span><span class="p">);</span>
  <span class="n">dynamic_msg</span><span class="o">-&gt;</span><span class="n">SerializeToString</span><span class="p">(</span><span class="o">&amp;</span><span class="n">compat_dynamic_serialized</span><span class="p">);</span>

  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Serialized values identical? "</span>
       <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">compat_static_serialized</span> <span class="o">==</span> <span class="n">compat_dynamic_serialized</span> <span class="o">?</span> <span class="s">"YES"</span> <span class="o">:</span> <span class="s">"NO"</span><span class="p">)</span>
       <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">compat_static_serialized</span> <span class="o">!=</span> <span class="n">compat_dynamic_serialized</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Static serialized size: "</span> <span class="o">&lt;&lt;</span> <span class="n">compat_static_serialized</span><span class="p">.</span><span class="n">size</span><span class="p">()</span>
         <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Dynamic serialized size: "</span> <span class="o">&lt;&lt;</span> <span class="n">compat_dynamic_serialized</span><span class="p">.</span><span class="n">size</span><span class="p">()</span>
         <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

  <span class="c1">// ============================================</span>
  <span class="c1">// Section 5: Basic Reflection API Usage</span>
  <span class="c1">// Demonstrates how to use the reflection API to access message fields</span>
  <span class="c1">// Shows the basic operations for getting and setting field values</span>
  <span class="c1">// ============================================</span>
  <span class="n">test</span><span class="o">::</span><span class="n">MyMessage</span> <span class="n">message</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Reflection</span> <span class="o">*</span><span class="n">reflection</span> <span class="o">=</span> <span class="n">message</span><span class="p">.</span><span class="n">GetReflection</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Descriptor</span> <span class="o">*</span><span class="n">descriptor_message</span> <span class="o">=</span>
      <span class="n">message</span><span class="p">.</span><span class="n">GetDescriptor</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">FieldDescriptor</span> <span class="o">*</span><span class="n">id_field</span> <span class="o">=</span>
      <span class="n">descriptor_message</span><span class="o">-&gt;</span><span class="n">FindFieldByName</span><span class="p">(</span><span class="s">"id"</span><span class="p">);</span>

  <span class="kt">int32_t</span> <span class="n">id_value</span> <span class="o">=</span> <span class="n">reflection</span><span class="o">-&gt;</span><span class="n">GetInt32</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">id_field</span><span class="p">);</span>
  <span class="n">reflection</span><span class="o">-&gt;</span><span class="n">SetInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">message</span><span class="p">,</span> <span class="n">id_field</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">=== Section 5: Basic Reflection API Usage ===</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"-------------------------------------------</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Message ID after reflection: "</span> <span class="o">&lt;&lt;</span> <span class="n">message</span><span class="p">.</span><span class="n">id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n\n</span><span class="s">"</span><span class="p">;</span>

  <span class="k">delete</span> <span class="n">dynamic_msg</span><span class="p">;</span> <span class="c1">// Must manage dynamic allocation</span>
  <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">ShutdownProtobufLibrary</span><span class="p">();</span>

  <span class="c1">// ============================================</span>
  <span class="c1">// Section 6: Dynamic Message Type Creation</span>
  <span class="c1">// Shows how to create a new message type programmatically</span>
  <span class="c1">// Useful for creating message types at runtime without .proto files</span>
  <span class="c1">// ============================================</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">=== Section 6: Dynamic Message Type Creation ===</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"----------------------------------------------</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">DescriptorPool</span> <span class="nf">pool</span><span class="p">(</span>
      <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">DescriptorPool</span><span class="o">::</span><span class="n">generated_pool</span><span class="p">());</span>
  <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">FileDescriptorProto</span> <span class="n">file_proto</span><span class="p">;</span>
  <span class="n">file_proto</span><span class="p">.</span><span class="n">set_name</span><span class="p">(</span><span class="s">"my_dynamic.proto"</span><span class="p">);</span>
  <span class="n">file_proto</span><span class="p">.</span><span class="n">set_package</span><span class="p">(</span><span class="s">"mypackage"</span><span class="p">);</span>

  <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">DescriptorProto</span> <span class="o">*</span><span class="n">message_proto</span> <span class="o">=</span>
      <span class="n">file_proto</span><span class="p">.</span><span class="n">add_message_type</span><span class="p">();</span>
  <span class="n">message_proto</span><span class="o">-&gt;</span><span class="n">set_name</span><span class="p">(</span><span class="s">"MyDynamicMessage"</span><span class="p">);</span>

  <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">FieldDescriptorProto</span> <span class="o">*</span><span class="n">field</span> <span class="o">=</span> <span class="n">message_proto</span><span class="o">-&gt;</span><span class="n">add_field</span><span class="p">();</span>
  <span class="n">field</span><span class="o">-&gt;</span><span class="n">set_name</span><span class="p">(</span><span class="s">"my_field"</span><span class="p">);</span>
  <span class="n">field</span><span class="o">-&gt;</span><span class="n">set_number</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">field</span><span class="o">-&gt;</span><span class="n">set_type</span><span class="p">(</span><span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">FieldDescriptorProto</span><span class="o">::</span><span class="n">TYPE_STRING</span><span class="p">);</span>

  <span class="k">const</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">FileDescriptor</span> <span class="o">*</span><span class="n">file_desc</span> <span class="o">=</span>
      <span class="n">pool</span><span class="p">.</span><span class="n">BuildFile</span><span class="p">(</span><span class="n">file_proto</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file_desc</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to build file descriptor!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Descriptor</span> <span class="o">*</span><span class="n">message_desc</span> <span class="o">=</span> <span class="n">file_desc</span><span class="o">-&gt;</span><span class="n">message_type</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">message_desc</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to get message descriptor!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">DynamicMessageFactory</span> <span class="n">factory</span><span class="p">;</span>
  <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Message</span> <span class="o">*</span><span class="n">message_dyn</span> <span class="o">=</span>
      <span class="n">factory</span><span class="p">.</span><span class="n">GetPrototype</span><span class="p">(</span><span class="n">message_desc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">New</span><span class="p">();</span>

  <span class="k">const</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Reflection</span> <span class="o">*</span><span class="n">dyn_reflection</span> <span class="o">=</span>
      <span class="n">message_dyn</span><span class="o">-&gt;</span><span class="n">GetReflection</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">FieldDescriptor</span> <span class="o">*</span><span class="n">field_desc</span> <span class="o">=</span>
      <span class="n">message_desc</span><span class="o">-&gt;</span><span class="n">FindFieldByName</span><span class="p">(</span><span class="s">"my_field"</span><span class="p">);</span>

  <span class="n">dyn_reflection</span><span class="o">-&gt;</span><span class="n">SetString</span><span class="p">(</span><span class="n">message_dyn</span><span class="p">,</span> <span class="n">field_desc</span><span class="p">,</span>
                            <span class="s">"Hello from dynamic message!"</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">value</span> <span class="o">=</span> <span class="n">dyn_reflection</span><span class="o">-&gt;</span><span class="n">GetString</span><span class="p">(</span><span class="o">*</span><span class="n">message_dyn</span><span class="p">,</span> <span class="n">field_desc</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Dynamic message field value: "</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="c1">// Without this, there will be seg fault; this is a because the underlyting</span>
  <span class="c1">// derived type is not protoc generated c++ class type anymore, it's</span>
  <span class="c1">// DynamicMessage type, the reason is unknown</span>
  <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">UnknownFieldSet</span> <span class="o">*</span><span class="n">unknown</span> <span class="o">=</span>
      <span class="n">message_dyn</span><span class="o">-&gt;</span><span class="n">GetReflection</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">MutableUnknownFields</span><span class="p">(</span><span class="n">message_dyn</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">unknown</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unknown</span><span class="o">-&gt;</span><span class="n">AddVarint</span><span class="p">(</span><span class="mi">999999</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">message_dyn</span><span class="o">-&gt;</span><span class="n">DebugString</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="c1">// ============================================</span>
  <span class="c1">// Section 6.5: Immutability of built descriptors</span>
  <span class="c1">// Demonstrates that once a descriptor is built, it cannot be modified</span>
  <span class="c1">// ============================================</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">=== Section 6.5: Immutability of built descriptors ===</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"----------------------------------------------------</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

  <span class="c1">// Try to add another field to message_proto</span>
  <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">FieldDescriptorProto</span> <span class="o">*</span><span class="n">field2</span> <span class="o">=</span> <span class="n">message_proto</span><span class="o">-&gt;</span><span class="n">add_field</span><span class="p">();</span>
  <span class="n">field2</span><span class="o">-&gt;</span><span class="n">set_name</span><span class="p">(</span><span class="s">"another_field"</span><span class="p">);</span>
  <span class="n">field2</span><span class="o">-&gt;</span><span class="n">set_number</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">field2</span><span class="o">-&gt;</span><span class="n">set_type</span><span class="p">(</span><span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">FieldDescriptorProto</span><span class="o">::</span><span class="n">TYPE_INT32</span><span class="p">);</span>

  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Added 'another_field' to FileDescriptorProto in memory.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

  <span class="c1">// The existing message_desc is immutable and won't see the change.</span>
  <span class="k">const</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">FieldDescriptor</span> <span class="o">*</span><span class="n">field_desc2</span> <span class="o">=</span>
      <span class="n">message_desc</span><span class="o">-&gt;</span><span class="n">FindFieldByName</span><span class="p">(</span><span class="s">"another_field"</span><span class="p">);</span>

  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Is 'another_field' found in the original descriptor? "</span>
       <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">field_desc2</span> <span class="o">?</span> <span class="s">"YES"</span> <span class="o">:</span> <span class="s">"NO"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Original descriptor field count: "</span> <span class="o">&lt;&lt;</span> <span class="n">message_desc</span><span class="o">-&gt;</span><span class="n">field_count</span><span class="p">()</span>
       <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n\n</span><span class="s">"</span><span class="p">;</span>

  <span class="c1">// To use the new field, you would have to build a new FileDescriptor.</span>
  <span class="c1">// Building with the same name will fail because it's already in the pool.</span>
  <span class="k">const</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">FileDescriptor</span> <span class="o">*</span><span class="n">new_file_desc_fail</span> <span class="o">=</span>
      <span class="n">pool</span><span class="p">.</span><span class="n">BuildFile</span><span class="p">(</span><span class="n">file_proto</span><span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Trying to build with same name again: "</span>
       <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">new_file_desc_fail</span> <span class="o">?</span> <span class="s">"succeeded (unexpected!)"</span>
                              <span class="o">:</span> <span class="s">"failed as expected"</span><span class="p">)</span>
       <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

  <span class="c1">// We have to change the name to build a new version.</span>
  <span class="n">file_proto</span><span class="p">.</span><span class="n">set_name</span><span class="p">(</span><span class="s">"my_dynamic_v2.proto"</span><span class="p">);</span>
  <span class="c1">// We must also change the message name to avoid a symbol collision in the</span>
  <span class="c1">// pool.</span>
  <span class="n">message_proto</span><span class="o">-&gt;</span><span class="n">set_name</span><span class="p">(</span><span class="s">"MyDynamicMessageV2"</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">FileDescriptor</span> <span class="o">*</span><span class="n">new_file_desc_ok</span> <span class="o">=</span>
      <span class="n">pool</span><span class="p">.</span><span class="n">BuildFile</span><span class="p">(</span><span class="n">file_proto</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">new_file_desc_ok</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Building with a new file and message name succeeded.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Descriptor</span> <span class="o">*</span><span class="n">new_message_desc</span> <span class="o">=</span>
        <span class="n">new_file_desc_ok</span><span class="o">-&gt;</span><span class="n">FindMessageTypeByName</span><span class="p">(</span><span class="s">"MyDynamicMessageV2"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">new_message_desc</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Found new message: '"</span> <span class="o">&lt;&lt;</span> <span class="n">new_message_desc</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"'</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"New descriptor field count: "</span> <span class="o">&lt;&lt;</span> <span class="n">new_message_desc</span><span class="o">-&gt;</span><span class="n">field_count</span><span class="p">()</span>
           <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
      <span class="k">const</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">FieldDescriptor</span> <span class="o">*</span><span class="n">new_field_desc</span> <span class="o">=</span>
          <span class="n">new_message_desc</span><span class="o">-&gt;</span><span class="n">FindFieldByName</span><span class="p">(</span><span class="s">"another_field"</span><span class="p">);</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Is 'another_field' found in the new descriptor? "</span>
           <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">new_field_desc</span> <span class="o">?</span> <span class="s">"YES"</span> <span class="o">:</span> <span class="s">"NO"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to find 'MyDynamicMessageV2' in new file "</span>
              <span class="s">"descriptor.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Building with a new name failed unexpectedly.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// ============================================</span>
  <span class="c1">// Section 7: Proto File String Parsing</span>
  <span class="c1">// Demonstrates how to create message types from a .proto file content string</span>
  <span class="c1">// Shows how to use the compiler infrastructure to parse proto definitions</span>
  <span class="c1">// ============================================</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">=== Section 7: Proto File String Parsing ===</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"------------------------------------------</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">proto_content</span> <span class="o">=</span> <span class="s">R"(
        syntax = "proto3";
        package dynamic;
        
        message DynamicPerson {
            string name = 1;
            int32 age = 2;
            repeated string hobbies = 3;
            bool is_active = 4;
        }
    )"</span><span class="p">;</span>

  <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">DescriptorPool</span> <span class="nf">descriptor_pool</span><span class="p">(</span>
      <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">DescriptorPool</span><span class="o">::</span><span class="n">generated_pool</span><span class="p">());</span>
  <span class="n">MemorySourceTree</span> <span class="nf">source_tree</span><span class="p">(</span><span class="s">"person.proto"</span><span class="p">,</span> <span class="n">proto_content</span><span class="p">);</span>
  <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">compiler</span><span class="o">::</span><span class="n">SourceTreeDescriptorDatabase</span> <span class="nf">source_tree_db</span><span class="p">(</span>
      <span class="o">&amp;</span><span class="n">source_tree</span><span class="p">);</span>

  <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">FileDescriptorProto</span> <span class="n">file_desc_proto</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">source_tree_db</span><span class="p">.</span><span class="n">FindFileByName</span><span class="p">(</span><span class="s">"person.proto"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file_desc_proto</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to parse proto content!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">FileDescriptor</span> <span class="o">*</span><span class="n">file_desc_dyn</span> <span class="o">=</span>
      <span class="n">descriptor_pool</span><span class="p">.</span><span class="n">BuildFile</span><span class="p">(</span><span class="n">file_desc_proto</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file_desc_dyn</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to build file descriptor!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Descriptor</span> <span class="o">*</span><span class="n">descriptor_dyn</span> <span class="o">=</span>
      <span class="n">file_desc_dyn</span><span class="o">-&gt;</span><span class="n">FindMessageTypeByName</span><span class="p">(</span><span class="s">"DynamicPerson"</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">descriptor_dyn</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to find message descriptor!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">DynamicMessageFactory</span> <span class="nf">factory_dyn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">descriptor_pool</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Message</span> <span class="o">*</span><span class="n">prototype</span> <span class="o">=</span>
      <span class="n">factory_dyn</span><span class="p">.</span><span class="n">GetPrototype</span><span class="p">(</span><span class="n">descriptor_dyn</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prototype</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to get message prototype!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Message</span><span class="o">&gt;</span> <span class="n">message_dyn_</span><span class="p">(</span><span class="n">prototype</span><span class="o">-&gt;</span><span class="n">New</span><span class="p">());</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">message_dyn_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to create dynamic message!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Without this, there will be seg fault</span>
  <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">UnknownFieldSet</span> <span class="o">*</span><span class="n">unknown_fields</span> <span class="o">=</span>
      <span class="n">message_dyn_</span><span class="o">-&gt;</span><span class="n">GetReflection</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">MutableUnknownFields</span><span class="p">(</span><span class="n">message_dyn_</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">unknown_fields</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unknown_fields</span><span class="o">-&gt;</span><span class="n">AddVarint</span><span class="p">(</span><span class="mi">999999</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Reflection</span> <span class="o">*</span><span class="n">reflection_dyn</span> <span class="o">=</span>
      <span class="n">message_dyn_</span><span class="o">-&gt;</span><span class="n">GetReflection</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reflection_dyn</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to get reflection interface!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">FieldDescriptor</span> <span class="o">*</span><span class="n">name_field</span> <span class="o">=</span>
      <span class="n">descriptor_dyn</span><span class="o">-&gt;</span><span class="n">FindFieldByName</span><span class="p">(</span><span class="s">"name"</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">FieldDescriptor</span> <span class="o">*</span><span class="n">age_field</span> <span class="o">=</span>
      <span class="n">descriptor_dyn</span><span class="o">-&gt;</span><span class="n">FindFieldByName</span><span class="p">(</span><span class="s">"age"</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">FieldDescriptor</span> <span class="o">*</span><span class="n">hobbies_field</span> <span class="o">=</span>
      <span class="n">descriptor_dyn</span><span class="o">-&gt;</span><span class="n">FindFieldByName</span><span class="p">(</span><span class="s">"hobbies"</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">FieldDescriptor</span> <span class="o">*</span><span class="n">is_active_field</span> <span class="o">=</span>
      <span class="n">descriptor_dyn</span><span class="o">-&gt;</span><span class="n">FindFieldByName</span><span class="p">(</span><span class="s">"is_active"</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name_field</span> <span class="o">||</span> <span class="o">!</span><span class="n">age_field</span> <span class="o">||</span> <span class="o">!</span><span class="n">hobbies_field</span> <span class="o">||</span> <span class="o">!</span><span class="n">is_active_field</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to find required fields!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">reflection_dyn</span><span class="o">-&gt;</span><span class="n">SetString</span><span class="p">(</span><span class="n">message_dyn_</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">name_field</span><span class="p">,</span> <span class="s">"John Doe"</span><span class="p">);</span>
  <span class="n">reflection_dyn</span><span class="o">-&gt;</span><span class="n">SetInt32</span><span class="p">(</span><span class="n">message_dyn_</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">age_field</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
  <span class="n">reflection_dyn</span><span class="o">-&gt;</span><span class="n">SetBool</span><span class="p">(</span><span class="n">message_dyn_</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">is_active_field</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
  <span class="n">reflection_dyn</span><span class="o">-&gt;</span><span class="n">AddString</span><span class="p">(</span><span class="n">message_dyn_</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">hobbies_field</span><span class="p">,</span> <span class="s">"Reading"</span><span class="p">);</span>
  <span class="n">reflection_dyn</span><span class="o">-&gt;</span><span class="n">AddString</span><span class="p">(</span><span class="n">message_dyn_</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">hobbies_field</span><span class="p">,</span> <span class="s">"Hiking"</span><span class="p">);</span>
  <span class="n">reflection_dyn</span><span class="o">-&gt;</span><span class="n">AddString</span><span class="p">(</span><span class="n">message_dyn_</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">hobbies_field</span><span class="p">,</span> <span class="s">"Programming"</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">Debug Information:</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Message Type: "</span> <span class="o">&lt;&lt;</span> <span class="n">message_dyn_</span><span class="o">-&gt;</span><span class="n">GetTypeName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Descriptor Name: "</span> <span class="o">&lt;&lt;</span> <span class="n">descriptor_dyn</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Number of Fields: "</span> <span class="o">&lt;&lt;</span> <span class="n">descriptor_dyn</span><span class="o">-&gt;</span><span class="n">field_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Unknown Fields Size: "</span>
            <span class="o">&lt;&lt;</span> <span class="n">message_dyn_</span><span class="o">-&gt;</span><span class="n">GetReflection</span><span class="p">()</span>
                   <span class="o">-&gt;</span><span class="n">GetUnknownFields</span><span class="p">(</span><span class="o">*</span><span class="n">message_dyn_</span><span class="p">)</span>
                   <span class="p">.</span><span class="n">field_count</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">Trying DebugString():</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">message_dyn_</span><span class="o">-&gt;</span><span class="n">DebugString</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n\n</span><span class="s">"</span><span class="p">;</span>

  <span class="c1">// ============================================</span>
  <span class="c1">// Section 8: Static vs Dynamic Message Comparison</span>
  <span class="c1">// Creates a static DynamicPerson message and compares its serialization</span>
  <span class="c1">// with the dynamic message to verify they are identical</span>
  <span class="c1">// ============================================</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">=== Section 8: Static vs Dynamic Message Comparison ===</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"------------------------------------------</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">test</span><span class="o">::</span><span class="n">DynamicPerson</span> <span class="n">static_person</span><span class="p">;</span>
  <span class="n">static_person</span><span class="p">.</span><span class="n">set_name</span><span class="p">(</span><span class="s">"John Doe"</span><span class="p">);</span>
  <span class="n">static_person</span><span class="p">.</span><span class="n">set_age</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>
  <span class="n">static_person</span><span class="p">.</span><span class="n">set_is_active</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
  <span class="n">static_person</span><span class="p">.</span><span class="n">add_hobbies</span><span class="p">(</span><span class="s">"Reading"</span><span class="p">);</span>
  <span class="n">static_person</span><span class="p">.</span><span class="n">add_hobbies</span><span class="p">(</span><span class="s">"Hiking"</span><span class="p">);</span>
  <span class="n">static_person</span><span class="p">.</span><span class="n">add_hobbies</span><span class="p">(</span><span class="s">"Programming"</span><span class="p">);</span>

  <span class="c1">// Clear unknown fields before serialization for fair comparison</span>
  <span class="n">message_dyn_</span><span class="o">-&gt;</span><span class="n">GetReflection</span><span class="p">()</span>
      <span class="o">-&gt;</span><span class="n">MutableUnknownFields</span><span class="p">(</span><span class="n">message_dyn_</span><span class="p">.</span><span class="n">get</span><span class="p">())</span>
      <span class="o">-&gt;</span><span class="n">Clear</span><span class="p">();</span>

  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">static_serialized</span><span class="p">,</span> <span class="n">dynamic_serialized</span><span class="p">;</span>
  <span class="n">static_person</span><span class="p">.</span><span class="n">SerializeToString</span><span class="p">(</span><span class="o">&amp;</span><span class="n">static_serialized</span><span class="p">);</span>
  <span class="n">message_dyn_</span><span class="o">-&gt;</span><span class="n">SerializeToString</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dynamic_serialized</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Static vs Dynamic Message Comparison:</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Serialized data identical? "</span>
            <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">static_serialized</span> <span class="o">==</span> <span class="n">dynamic_serialized</span> <span class="o">?</span> <span class="s">"YES"</span> <span class="o">:</span> <span class="s">"NO"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">static_serialized</span> <span class="o">!=</span> <span class="n">dynamic_serialized</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Static serialized size: "</span> <span class="o">&lt;&lt;</span> <span class="n">static_serialized</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Dynamic serialized size: "</span> <span class="o">&lt;&lt;</span> <span class="n">dynamic_serialized</span><span class="p">.</span><span class="n">size</span><span class="p">()</span>
              <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="c1">// Print hex representation of both serialized messages for debugging</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Static serialized (hex): "</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">static_serialized</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"%02x "</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">Dynamic serialized (hex): "</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">dynamic_serialized</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"%02x "</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="why-gpb-is-not-true-dynamic-type">Why GPB is not true dynamic type</h2>

<p>GPB support dynamic type creation, dynamic data creation, why is it not considered true dynamic type(at least by me)? I think the reason are following:</p>

<ol>
  <li>Runtime type creation is just defered compile time type registration. When user use protoc to generate types and those types are registered during program start up, before main. The registration process is the same as the so-called runtime type creation, both reading from a text and compose a type descriptor, then register it to <em>DescriptorPool</em>. More importantly, once the type has been registered, it can not be modified: GPB can not update all instance of this type if the type itself can be modified during runtime. Think about what happens if one type is changed, might be a new field is added, and the existing instancees can not be updated to contain this new field in data.</li>
  <li><em>DynamicMessage</em> type do bring GPB one step close to true dynamic type. It works very much like <em>PyObject</em> class in Python. However, it still depend on <em>Descriptor</em> to contruct one message, yet again <em>Descriptor</em> can not be changed once registered. In Python, class attributes and instance attributes are added into a dynamic expanding list, which can be added and deleted at runtime. This can not be done with GPBâ€™s descriptor. For GPB to be truely dynamic, it must make <em>Descriptor</em> type dynamic at runtime, since the descriptors are the real ones that defines a <em>type</em>. But in GPB, <em>Descriptor</em> can be created and changed during runtime, but it can not be changed once registered.</li>
</ol>

<p>GPB supports â€‹â€‹runtime descriptor constructionâ€‹â€‹ and â€‹â€‹dynamic message handlingâ€‹â€‹ (via DynamicMessage), but the â€‹â€‹immutability of registered descriptorsâ€‹â€‹ and the â€‹â€‹inability to propagate type changes to existing instancesâ€‹â€‹ make it a â€‹â€‹static type systemâ€‹â€‹ with limited runtime flexibilityâ€”not a true dynamic type system. This design prioritizes performance, safety, and serialization reliability over full runtime dynamism.</p>

<p>Python achieves the propagation of â€‹â€‹type changes to existing instancesâ€‹â€‹ through its dynamic object model, leveraging two key features:</p>

<ul>
  <li>Mutable class dictionaries</li>
  <li>Attribute lookup delegationâ€‹â€‹</li>
</ul>

<p>In Python, an instance (obj) stores only its â€‹â€‹unique instance-level attributesâ€‹â€‹ in its own <strong>dict</strong> (dictionary).For â€‹â€‹class-level attributesâ€‹â€‹ (including methods), the instance delegates to its class. The class holds these attributes in its <strong>dict</strong>. If you modify a classâ€™s <strong>dict</strong> (e.g., add/change attributes), all existing instances immediately reflect the changes because attribute lookup always queries the class dynamically. When you access obj.attr: Python checks obj.<strong>dict</strong> for an instance attribute attr. If not found, it delegates to the â€‹â€‹classâ€™s <strong>dict</strong>â€‹â€‹. If the class doesnâ€™t have it, it checks base classes (MRO).
â€‹â€‹Class-level changes are â€‹â€‹visible instantlyâ€‹â€‹ because the lookup happens at runtime, not at instance creation.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyClass</span><span class="p">:</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">new_method</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>


<span class="n">obj1</span> <span class="o">=</span> <span class="nc">MyClass</span><span class="p">()</span>
<span class="n">MyClass</span><span class="p">.</span><span class="n">double_x</span> <span class="o">=</span> <span class="n">new_method</span>
<span class="n">obj1</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">obj2</span> <span class="o">=</span> <span class="nc">MyClass</span><span class="p">()</span>

<span class="c1"># obj1 can find double_x and x, can success
</span><span class="n">obj1</span><span class="p">.</span><span class="nf">double_x</span><span class="p">()</span>
<span class="c1"># obj2 can find double_x, but not x, fail
</span><span class="n">obj2</span><span class="p">.</span><span class="nf">double_x</span><span class="p">()</span>

</code></pre></div></div>

<p><strong>For dynamic types, the programmer are programming towards <em>interpreter</em>, programmer are acutually writing <em>text</em>; For static types, the programmer are programming towards <em>compiler</em>, the programmer are writing <em>code</em></strong></p>]]></content><author><name></name></author><category term="programming" /><summary type="html"><![CDATA[I talked about types in Type system and language bindings. Today I go deep into one specific type system: Google Protocol Buffers(GPB). GPB support introspection, reflection, dynamic type, dynamic data. However, I do not consider GPB a true dynamic typing system and I will talk about why after we have a deep look at how GPB works.]]></summary></entry><entry><title type="html">Compile-Time vs. Run-Time</title><link href="http://localhost:4000/2025/06/12/compile-vs-runtime.html" rel="alternate" type="text/html" title="Compile-Time vs. Run-Time" /><published>2025-06-12T19:22:46+08:00</published><updated>2025-06-12T19:22:46+08:00</updated><id>http://localhost:4000/2025/06/12/compile-vs-runtime</id><content type="html" xml:base="http://localhost:4000/2025/06/12/compile-vs-runtime.html"><![CDATA[<p><em>This blog post was co-authored with AI assistance.</em></p>

<h1 id="compile-time-vs-run-time">Compile-Time vs. Run-Time</h1>

<p>Picture compile-time as the resume screener for a job, checking your credentials before youâ€™re hired, and run-time as your actual performance on the job, where real-world challenges test your mettle.</p>

<h2 id="compile-time-the-resume-screener">Compile-Time: The Resume Screener</h2>

<p>Compile-time is all about <strong>static inspection</strong>â€”itâ€™s the phase where the compiler plays bouncer, making sure your code meets the â€œhard requirementsâ€ before itâ€™s allowed to execute. Think of it as a recruiter scanning your resume: Does your syntax check out? Are your types aligned? Are you following the rules?</p>

<ul>
  <li><strong>Type Safety</strong>: The compiler catches mismatches early. For example, in C# or Java:
    <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">string</span> <span class="n">my_value</span> <span class="p">=</span> <span class="n">Console</span><span class="p">.</span><span class="nf">ReadLine</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="n">my_value</span><span class="p">;</span>  <span class="c1">// Compiler: "Nope, string canâ€™t be an int!"</span>
</code></pre></div>    </div>
    <p>This prevents runtime chaos by enforcing type rules upfront.</p>
  </li>
  <li><strong>Syntax Rules</strong>: Miss a semicolon in C++ or mismatch function parameters? The compiler flags it immediately.</li>
  <li><strong>Scope and Visibility</strong>: Try accessing an undeclared variable or a private member, and youâ€™ll get a stern â€œaccess deniedâ€ before the code even runs.</li>
</ul>

<p>Itâ€™s like fixing a typo on your resume before the interviewâ€”preventive and efficient.</p>

<h2 id="run-time-the-real-world-test">Run-Time: The Real-World Test</h2>

<p>Once your code passes the compile-time â€œresume check,â€ itâ€™s time for <strong>run-time</strong>â€”the dynamic phase where your program faces the unpredictable. This is your job performance after being hired: the resume got you in, but now youâ€™re dealing with real tasks, unexpected inputs, and shifting conditions.</p>

<ul>
  <li><strong>Dynamic Type Conversion</strong>: Syntax might be fine, but the data? Thatâ€™s another story:
    <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="kt">int</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">my_value</span><span class="p">);</span>  <span class="c1">// If my_value is "abc", hello FormatException!</span>
</code></pre></div>    </div>
    <p>The compiler approves, but run-time decides if the conversion works.</p>
  </li>
  <li><strong>Polymorphism</strong>: In languages like C++:
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Base</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Derived</span><span class="p">();</span>
<span class="n">b</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">();</span>  <span class="c1">// Run-time picks Derived::func() via the vtable</span>
</code></pre></div>    </div>
    <p>This flexibilityâ€”deciding behavior on the flyâ€”is pure run-time magic.</p>
  </li>
  <li><strong>Resource Checks</strong>: Java and C# watch array bounds (throwing exceptions if you overstep), while C leaves you to fend for yourself:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>  <span class="c1">// Undefined behaviorâ€”good luck!</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>Run-time is your safety net when the real world throws curveballs.</p>

<h2 id="qualification-meets-execution">Qualification Meets Execution</h2>

<p>Compile-time and run-time arenâ€™t rivalsâ€”theyâ€™re a progressive duo. Compile-time ensures your code is <strong>qualified to execute</strong> (â€œYou meet the minimum standardsâ€), while run-time checks if it <strong>executes successfully</strong> (â€œCan you handle the real thing?â€).</p>

<h2 id="the-big-picture-a-staged-defense">The Big Picture: A Staged Defense</h2>

<p>In the end, compile-time and run-time are like <strong>design-time protection</strong> and <strong>operation-time monitoring</strong> in safety engineering. Compile-time is your preventive review, weeding out structural flaws. Run-time is your dynamic insurance, adapting to chaos and keeping things afloat.</p>

<p>Next time your compiler yells or your program crashes, think of it as this layered system at work: compile-time says, â€œYou <em>can</em> do this,â€ and run-time proves, â€œYou <em>did</em> it.â€ Itâ€™s this balance that drives modern programming languages, blending performance, safety, and flexibility into the tools we love.</p>]]></content><author><name></name></author><category term="programming" /><summary type="html"><![CDATA[This blog post was co-authored with AI assistance.]]></summary></entry><entry><title type="html">Static Storage and Nifty Counter</title><link href="http://localhost:4000/2025/05/23/static-storage-niftty-counter.html" rel="alternate" type="text/html" title="Static Storage and Nifty Counter" /><published>2025-05-23T21:22:46+08:00</published><updated>2025-05-23T21:22:46+08:00</updated><id>http://localhost:4000/2025/05/23/static-storage-niftty-counter</id><content type="html" xml:base="http://localhost:4000/2025/05/23/static-storage-niftty-counter.html"><![CDATA[<p>This is reading notes for <a href="https://en.cppreference.com/w/cpp/language/siof"><em>static initialization order fiasco</em></a> problem and its solutions.</p>

<p><a href="https://en.cppreference.com/w/cpp/language/storage_duration"><em>static storage duration</em></a> includes:</p>

<ul>
  <li>Global variables: <em>external linkage</em></li>
  <li><em>static</em> members of a class: <em>external linkage</em></li>
  <li><em>static</em> variables: <em>internal linkage</em></li>
  <li><em>static</em> local variables inside functions: <em>no linkage</em></li>
</ul>

<p>Since the <em>static initialization order fiasco</em> only happens between <em>static objects</em> which have <em>external linkage</em>, we only consider global variables and static members of a class. I call them <em>static objects</em> in the following content.</p>

<h1 id="initialization-and-destruction-order-of-static-objects">Initialization and destruction order of static objects</h1>

<p>Simply put:</p>

<ul>
  <li>Inside one translation unit (TU), static objects are initialized in the order of their appearance and deinitialized in reverse order.</li>
  <li>Across TUs, the order is unspecified.</li>
  <li>Initialization order:
    <ul>
      <li>Global variables and <em>static</em> class members: Initialization happens before <code class="language-plaintext highlighter-rouge">main</code>; Deinitialization happens after <code class="language-plaintext highlighter-rouge">main</code></li>
      <li><em>static</em> local variables: initialization at first use and deinitialization after <code class="language-plaintext highlighter-rouge">main</code></li>
      <li><em>static</em> variables inside TU: Initialization happens before <code class="language-plaintext highlighter-rouge">main</code>; Deinitialization happens after <code class="language-plaintext highlighter-rouge">main</code></li>
    </ul>
  </li>
</ul>

<p><em>static initialization order fiasco</em> happens when <em>static objects</em> across TUs depend on each other:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// file1.h</span>
<span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">doSomething</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">};</span>
<span class="k">extern</span> <span class="n">A</span> <span class="n">aObj</span><span class="p">;</span>

<span class="c1">// file1.cpp</span>
<span class="n">A</span> <span class="n">aObj</span><span class="p">;</span>

<span class="c1">// file2.h</span>
<span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">B</span><span class="p">()</span> <span class="p">{</span> <span class="n">aObj</span><span class="p">.</span><span class="n">doSomething</span><span class="p">();</span> <span class="p">}</span> <span class="c1">// Potential problem: aObj might not be initialized yet</span>
    <span class="k">static</span> <span class="n">B</span> <span class="n">bObj</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// file2.cpp</span>
<span class="cp">#include</span> <span class="cpf">"file1.h"</span><span class="c1"> </span><span class="cp">
#include</span> <span class="cpf">"file2.h"</span><span class="cp">
</span><span class="n">B</span> <span class="n">B</span><span class="o">::</span><span class="n">bObj</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h1 id="construct-on-first-use-idiom">Construct On First Use Idiom</h1>

<p><a href="https://isocpp.org/wiki/faq/ctors#static-init-order-on-first-use"><em>Construction On First Use Idiom</em></a> uses <em>static</em> local variable inside function to avoid the problem. Since <em>static</em> local variable inside a function has <em>no linkage</em> and is initialized when first used, this will prevent the order problem:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Fred</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="n">Fred</span><span class="o">*</span> <span class="n">ans</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Fred</span><span class="p">();</span>
  <span class="k">return</span> <span class="o">*</span><span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">ans</code> will <em>never</em> be destructed, which avoids the problem of destruction order. The memory will be freed when the process terminates by the operating system.</li>
</ul>

<p>If:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Fred</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="n">Fred</span> <span class="n">ans</span><span class="p">;</span>  <span class="c1">// was static Fred* ans = new Fred();</span>
  <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>       <span class="c1">// was return *ans;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If some <em>static object</em> that depends on <code class="language-plaintext highlighter-rouge">ans</code> is destructed after <code class="language-plaintext highlighter-rouge">ans</code> is destructed, there will be the same problem as <em>static initialization order fiasco</em>.</p>

<h1 id="nifty-counter-idiom">Nifty Counter Idiom</h1>

<p><a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Nifty_Counter"><em>Nifty Counter Idiom</em></a> can solve both initialization and deinitialization order problems. Here I quote the full explanation:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Stream.h</span>
<span class="cp">#ifndef STREAM_H
#define STREAM_H
</span>
<span class="k">struct</span> <span class="nc">Stream</span> <span class="p">{</span>
  <span class="n">Stream</span> <span class="p">();</span>
  <span class="o">~</span><span class="n">Stream</span> <span class="p">();</span>
<span class="p">};</span>
<span class="k">extern</span> <span class="n">Stream</span><span class="o">&amp;</span> <span class="n">stream</span><span class="p">;</span> <span class="c1">// global stream object</span>

<span class="k">static</span> <span class="k">struct</span> <span class="nc">StreamInitializer</span> <span class="p">{</span>
  <span class="n">StreamInitializer</span> <span class="p">();</span>
  <span class="o">~</span><span class="n">StreamInitializer</span> <span class="p">();</span>
<span class="p">}</span> <span class="n">streamInitializer</span><span class="p">;</span> <span class="c1">// static initializer for every translation unit</span>

<span class="cp">#endif // STREAM_H
</span></code></pre></div></div>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Stream.cpp</span>
<span class="cp">#include</span> <span class="cpf">"Stream.h"</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">&lt;new&gt;</span><span class="c1">         // placement new</span><span class="cp">
#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="c1"> // aligned_storage</span><span class="cp">
</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nifty_counter</span><span class="p">;</span> <span class="c1">// zero initialized at load time</span>
<span class="k">static</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">aligned_storage</span><span class="o">&lt;</span><span class="k">sizeof</span> <span class="p">(</span><span class="n">Stream</span><span class="p">),</span> <span class="k">alignof</span> <span class="p">(</span><span class="n">Stream</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span>
  <span class="n">stream_buf</span><span class="p">;</span> <span class="c1">// memory for the stream object</span>
<span class="n">Stream</span><span class="o">&amp;</span> <span class="n">stream</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">Stream</span><span class="o">&amp;&gt;</span> <span class="p">(</span><span class="n">stream_buf</span><span class="p">);</span>

<span class="n">Stream</span><span class="o">::</span><span class="n">Stream</span> <span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// initialize things</span>
<span class="p">}</span>
<span class="n">Stream</span><span class="o">::~</span><span class="n">Stream</span> <span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// clean-up</span>
<span class="p">}</span> 

<span class="n">StreamInitializer</span><span class="o">::</span><span class="n">StreamInitializer</span> <span class="p">()</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">nifty_counter</span><span class="o">++</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">new</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="p">)</span> <span class="n">Stream</span> <span class="p">();</span> <span class="c1">// placement new</span>
<span class="p">}</span>
<span class="n">StreamInitializer</span><span class="o">::~</span><span class="n">StreamInitializer</span> <span class="p">()</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">nifty_counter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">stream</span><span class="p">.</span><span class="o">~</span><span class="n">Stream</span> <span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>
<blockquote>
  <p>The header file of the Stream class must be included before any member function can be called on the Stream object. An instance of the StreamInitializer class is included in each compilation unit. Any use of the Stream object follows the inclusion of the header, which ensures that the constructor of the initializer object is called before the Stream object is used.</p>
</blockquote>

<blockquote>
  <p>The Stream classâ€™ header file declares a reference to the Stream object. In addition this reference is extern, meaning it is defined in one translation unit and accesses to it are resolved by the linker rather than the compiler.
The implementation file for the Stream class finally defines the Stream object, but in an unusual way: it first defines a static (i.e. local to the translation unit) buffer. This buffer is both properly aligned and big enough to store an object of type Stream. The reference to the Stream object defined in the header is then set to point to this buffer.
This buffer workaround enables fine-grained control of when the Stream objectâ€™s constructor and destructor are called. In the example above, the constructor is called within the constructor of the first StreamInitializer object, using placement new to place it within the buffer. The Stream objectâ€™s destructor is called when the last StreamInitializer object is destroyed.</p>
</blockquote>

<blockquote>
  <p>This workaround is necessary because defining a Stream variable within Stream.cpp - be it static or not - would define it after the StreamInitializer, which is defined by including the header. Then, the StreamInitializerâ€™s constructor would run before theStreamâ€™s constructor, and even worse, the initializerâ€™s destructor would run after the Stream objectâ€™s destructor. The buffer solution above avoids this.</p>
</blockquote>]]></content><author><name></name></author><category term="middleware" /><summary type="html"><![CDATA[This is reading notes for static initialization order fiasco problem and its solutions.]]></summary></entry><entry><title type="html">Type Erasure</title><link href="http://localhost:4000/2025/04/20/type-erasure.html" rel="alternate" type="text/html" title="Type Erasure" /><published>2025-04-20T09:22:46+08:00</published><updated>2025-04-20T09:22:46+08:00</updated><id>http://localhost:4000/2025/04/20/type-erasure</id><content type="html" xml:base="http://localhost:4000/2025/04/20/type-erasure.html"><![CDATA[<p>This is understanding notes for this presentation: <a href="https://www.youtube.com/watch?v=p-qaf6OS_f4">C++ Type Erasure Demystified - Fedor G Pikus - C++Now 2024</a>. Ppt at <a href="https://github.com/shan-weiqiang/shan-weiqiang.github.io/blob/main/assets/files/Cpp_Type_Erasure_Demystified.pdf">here</a>.</p>

<ul id="markdown-toc">
  <li><a href="#core-logic-behind-type-erasure" id="markdown-toc-core-logic-behind-type-erasure">Core logic behind type erasure</a></li>
  <li><a href="#implementation-methods-for-type-erasure" id="markdown-toc-implementation-methods-for-type-erasure">Implementation methods for type erasure</a></li>
  <li><a href="#abstraction-of-type" id="markdown-toc-abstraction-of-type">Abstraction of type</a></li>
  <li><a href="#type-erasure-of-stdfunction" id="markdown-toc-type-erasure-of-stdfunction">Type erasure of std::function</a></li>
  <li><a href="#type-erasure-of-stdshared_ptr-deleter" id="markdown-toc-type-erasure-of-stdshared_ptr-deleter">Type erasure of std::shared_ptr deleter</a></li>
  <li><a href="#more-about-binding" id="markdown-toc-more-about-binding">More about binding</a></li>
  <li><a href="#stdvariant" id="markdown-toc-stdvariant">std::variant</a></li>
</ul>

<h2 id="core-logic-behind-type-erasure">Core logic behind type erasure</h2>

<ul>
  <li>Encapsulate type infomation in implementation, remove type information in interface</li>
  <li>Different implementation for different types might be manually coded or generated by compiler(C++)
    <ul>
      <li>Template instantiation</li>
      <li>Virtual inheritence</li>
    </ul>
  </li>
  <li>Dispatch of implementation happens at construction phase. It might happens at compile time or runtime:
    <ul>
      <li>For template instantiated implementations, it happens at compile time</li>
      <li>For virtual inheritence, it happens at runtime
<strong>Dispatch is all about redirection of function pointers</strong></li>
    </ul>
  </li>
  <li>The user of the interface is not aware of the passed type information, hence the type is <em>erased</em>.</li>
</ul>

<p>Whatâ€™s the benifit of type erasure? Even though there is a type erased interface, like <code class="language-plaintext highlighter-rouge">qsort</code>, but when the <code class="language-plaintext highlighter-rouge">qsort</code> is actually used, we still need to pass <em>correct implementation</em> of the comparision function to <code class="language-plaintext highlighter-rouge">qsort</code>, we just <strong>defer</strong> the choice of implementation to later time. The <code class="language-plaintext highlighter-rouge">qsort</code> function acts as a <em>variation point</em>, it <strong>abstract</strong> the sorting logic functionality by using only the type erased compare function. When <code class="language-plaintext highlighter-rouge">qsort</code> is called, it binds the sorting logic to the actual type compare implementation. Without <code class="language-plaintext highlighter-rouge">qsort</code> that use the type-erased compare interface to implement <em>common behavior</em> of sorting, the type-erased compare interface will have no practical meaning:</p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">qsort</code> algorithm stands for the <em>common behavior</em>, which utilize the type-erased interface</li>
  <li>The implementation of this <em>common behavior</em> abstract out any specific type information</li>
  <li>When the implementation of this <em>common behavior</em> is used, user decides which type it is actually operates on(the <em>common behavior</em> implementation still know nothing about type whatsoever)</li>
</ul>

<p>Without this <em>abstraction</em>, we have to implement <code class="language-plaintext highlighter-rouge">qsort</code> for each individual type and the sorting algorithm has to be coded every time for each type. Now with type erasure, we only need to code the actual sorting algorithm <em>once</em> for all possible types. Of cource the compare function has to be implemented for each type, since each type has their own comparing logic.</p>

<h2 id="implementation-methods-for-type-erasure">Implementation methods for type erasure</h2>

<ol>
  <li>Virtual inheritance: redirection hanppens when using base class pointer to call implementation in derived class(whose type is erased)</li>
  <li>Static templated functions: C++ compiler will generate code implementation for each template instantiation. Itâ€™s the same as C, but code generated instead of manually written. Note that generated static functions are class members, which means that the amount of instantiations equals the number of generated class member functions.</li>
  <li>Vtable: similar as 2, this time use a vtable to point to generated static class member functions.</li>
</ol>

<p>Note: <strong>Method 3 is how <code class="language-plaintext highlighter-rouge">std::function</code> is implemented</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span>
<span class="c1">// Following code are in *.cpp file, without Some exposed</span>
<span class="c1">// But user will call this code through type erased interface: void</span>
<span class="c1">// print_data(const void *p). This is the core of type erasure: encapsulate type</span>
<span class="c1">// infomation in implementation, remove type information in interface.</span>
<span class="k">struct</span> <span class="nc">Some</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">bool</span> <span class="nf">less</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Some</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;</span>
         <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Some</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// The declaration in *.h, exposed to external user</span>
<span class="c1">// ! Here is where the type erasure happens</span>
<span class="kt">bool</span> <span class="nf">less</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="c1">// User of type erasure: qsort does not need to know which type it will sort,</span>
<span class="c1">// type is erased from qsort: type erasure is an abstraction for multiple</span>
<span class="c1">// implementations that provide the same behavior, the relevent behavior is what</span>
<span class="c1">// matters, not the type. In this example, `compare` parameter requires that two</span>
<span class="c1">// elements can be compared, qsort does not care about how it is compared, as</span>
<span class="c1">// long as it return a bool value. This gives chances to implement the compare</span>
<span class="c1">// logic in source code, instead of in interface code.</span>

<span class="c1">// Since type erasure is about abstraction of behavior, it alwarys involve</span>
<span class="c1">// redirection of function pointers, no matter which way it is implemented. This</span>
<span class="c1">// redirection of function pointer is called dispatch, which is another core</span>
<span class="c1">// brick in implementing type erasure. Dispatch might happen both at compile</span>
<span class="c1">// time or runtime.</span>

<span class="c1">// Compared with C, C++ ONLY add implementation methods for type erasure. In C,</span>
<span class="c1">// we have to manually write different implementations, like the `less` and</span>
<span class="c1">// `more` function in below. In C++, we have the compiler to generate different</span>
<span class="c1">// implementation code for us. They all involves template and are done at</span>
<span class="c1">// construction phase. The three ways are:</span>
<span class="c1">// 1. virtual inheritance: redirection hanppens when using base class pointer to</span>
<span class="c1">// call implementation in derived class(whose type is erased)</span>
<span class="c1">// 2. static templated functions: C++ compiler will generate</span>
<span class="c1">// code implementation for each template instantiation. It's the same as C, but</span>
<span class="c1">// code generated instead of manually written. Note that generated static</span>
<span class="c1">// functions are class members, which means that the amount of instantiations</span>
<span class="c1">// equals the number of generated class member functions.</span>
<span class="c1">// 3. vtable: Similar as 2, this time use a vtable to point to instead of</span>
<span class="c1">// generating static class member functions.</span>

<span class="c1">// One more important fact is that all the C++ ways are of value semantics. The</span>
<span class="c1">// implementation is stored as value(function pointers can be seen as value of</span>
<span class="c1">// function variables).</span>

<span class="c1">// Now we can summarize type erasure as follow:</span>

<span class="c1">// Core logic of type erasure:</span>
<span class="c1">// 1. Encapsulate type infomation in implementation, remove type information in</span>
<span class="c1">// interface.</span>
<span class="c1">// 2. The interface provide same behavior, regardless of specific type</span>

<span class="c1">// Implementation steps of type erasure involve two distinct phase: how</span>
<span class="c1">// implementation code is generated at compile time and how those implementation</span>
<span class="c1">// is dispatched to at runtime:</span>

<span class="c1">// 1. Statically write type erased code implementation, either manually, or by</span>
<span class="c1">// compiler(C++). The type must be inside cpp, not in header(interface)</span>
<span class="c1">// 2. Dynamically dispatch function call to the right implementation at runtime.</span>
<span class="c1">// How the dispatch is done varies. It can simply be hard coded(like in C qsort</span>
<span class="c1">// example in following code). Or it can be done using virtual inheritance in</span>
<span class="c1">// C++. Either way, the dispatch, or redirection is determined during</span>
<span class="c1">// construction phase. As soon as the construction is complete, the dispatch</span>
<span class="c1">// manner is determined.</span>

<span class="kt">void</span> <span class="nf">qsort</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nmeb</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span>
           <span class="kt">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">compare</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">));</span>

<span class="c1">// Following give another type that also use qsort</span>
<span class="k">struct</span> <span class="nc">Tome</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">bool</span> <span class="nf">more</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Tome</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;</span>
         <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Tome</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">bool</span> <span class="nf">more</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Some</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
  <span class="n">Tome</span> <span class="n">b</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
  <span class="c1">// qsort is universal, thanks to the redirection of `compare` parameter</span>
  <span class="n">qsort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">less</span><span class="p">);</span>
  <span class="n">qsort</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">more</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="abstraction-of-type">Abstraction of type</h2>

<p>Type erasure, C++ template, C++ concept, virtual inheritence, what is the common characteristic among them?  <strong>They both allow us to write code logic for a group of types, instead of just one type</strong>. The code logic is the <em>common behavior</em> for those types. The binding of specific types are deferred to later times: for type erasure and virtual inheritence, this binding is defered to runtime; for C++ template and C++ concept, this binding is deferred to compile time:</p>

<ul>
  <li>We can write binary libraries which can be used on difference types using type erasure and virtual inheritence</li>
  <li>We can write templated source code libraries which can be used on difference types using C++ template and C++ concept</li>
</ul>

<p>C++ concept is more restricted C++ template. C++ virtual inheritence is special kind of type erasure, with vtable as runtime dispatch method. <strong>All being said, at the core, they are all function pointer binding methods, at compile time, or at runtime. When bind at runtime, itâ€™s always during the construction phase</strong>.</p>

<h2 id="type-erasure-of-stdfunction">Type erasure of std::function</h2>

<p>After the signature is specified through template paramter, <code class="language-plaintext highlighter-rouge">std::function</code> variable can be used to store difference kinds of <em>types</em>, as long as they both have the same signature. This is done through type erasure. <code class="language-plaintext highlighter-rouge">std::function</code> has value semantics and can be copied and moved. After the template signature is determined the code for all methods is fixed for the compiler. After a <code class="language-plaintext highlighter-rouge">std::function</code> instance is constructed, the <em>implementation</em> binding is fixed.</p>

<p>Note that <code class="language-plaintext highlighter-rouge">std::function</code> variables, like virtual base class pointers can be re-assigned to other <code class="language-plaintext highlighter-rouge">std::function</code> instance with the same signature at runtime, just like virtual base class pointers changed to point to other derived class instances. This is because, internally, <code class="language-plaintext highlighter-rouge">std::function</code> erased type for specific implementation type after an instance is constructed. Take the <code class="language-plaintext highlighter-rouge">qsort</code> for example, if i have a class instance that stores <code class="language-plaintext highlighter-rouge">qsort</code> and <code class="language-plaintext highlighter-rouge">less</code>, another instance can store <code class="language-plaintext highlighter-rouge">qsort</code> and <code class="language-plaintext highlighter-rouge">more</code>, since <code class="language-plaintext highlighter-rouge">less</code> and <code class="language-plaintext highlighter-rouge">more</code> have the same signature and are type erased. The external API of <code class="language-plaintext highlighter-rouge">std::function</code> works for any instances(which have different function pointer bindings, which happens at compile time, and have difference implementation code).</p>

<h2 id="type-erasure-of-stdshared_ptr-deleter">Type erasure of std::shared_ptr deleter</h2>

<p><code class="language-plaintext highlighter-rouge">std::shared_ptr</code> type use virtual base class to do type erasure. If user pass a custom deleter during construction, the pointer instance will be bound to a unified base class and points to the implementation of this custom deleter.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Support for custom deleter and/or allocator</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Ptr</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">_Deleter</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">_Alloc</span><span class="p">,</span> <span class="n">_Lock_policy</span> <span class="n">_Lp</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">_Sp_counted_deleter</span> <span class="k">final</span> <span class="o">:</span> <span class="k">public</span> <span class="n">_Sp_counted_base</span><span class="o">&lt;</span><span class="n">_Lp</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">class</span> <span class="nc">_Impl</span> <span class="o">:</span> <span class="n">_Sp_ebo_helper</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">_Deleter</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">_Sp_ebo_helper</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="n">_Alloc</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="n">_Sp_ebo_helper</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">_Deleter</span><span class="o">&gt;</span> <span class="n">_Del_base</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">_Sp_ebo_helper</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="n">_Alloc</span><span class="o">&gt;</span> <span class="n">_Alloc_base</span><span class="p">;</span>

  <span class="nl">public:</span>
    <span class="n">_Impl</span><span class="p">(</span><span class="n">_Ptr</span> <span class="n">__p</span><span class="p">,</span> <span class="n">_Deleter</span> <span class="n">__d</span><span class="p">,</span> <span class="k">const</span> <span class="n">_Alloc</span> <span class="o">&amp;</span><span class="n">__a</span><span class="p">)</span> <span class="k">noexcept</span>
        <span class="o">:</span> <span class="n">_M_ptr</span><span class="p">(</span><span class="n">__p</span><span class="p">),</span> <span class="n">_Del_base</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">__d</span><span class="p">)),</span> <span class="n">_Alloc_base</span><span class="p">(</span><span class="n">__a</span><span class="p">)</span> <span class="p">{}</span>

    <span class="n">_Deleter</span> <span class="o">&amp;</span><span class="n">_M_del</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_Del_base</span><span class="o">::</span><span class="n">_S_get</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
    <span class="n">_Alloc</span> <span class="o">&amp;</span><span class="n">_M_alloc</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_Alloc_base</span><span class="o">::</span><span class="n">_S_get</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>

    <span class="n">_Ptr</span> <span class="n">_M_ptr</span><span class="p">;</span>
  <span class="p">};</span>

<span class="k">public</span><span class="o">:</span>
  <span class="k">using</span> <span class="n">__allocator_type</span> <span class="o">=</span> <span class="n">__alloc_rebind</span><span class="o">&lt;</span><span class="n">_Alloc</span><span class="p">,</span> <span class="n">_Sp_counted_deleter</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="c1">// __d(__p) must not throw.</span>
  <span class="n">_Sp_counted_deleter</span><span class="p">(</span><span class="n">_Ptr</span> <span class="n">__p</span><span class="p">,</span> <span class="n">_Deleter</span> <span class="n">__d</span><span class="p">)</span> <span class="k">noexcept</span>
      <span class="o">:</span> <span class="n">_M_impl</span><span class="p">(</span><span class="n">__p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">__d</span><span class="p">),</span> <span class="n">_Alloc</span><span class="p">())</span> <span class="p">{}</span>

  <span class="c1">// __d(__p) must not throw.</span>
  <span class="n">_Sp_counted_deleter</span><span class="p">(</span><span class="n">_Ptr</span> <span class="n">__p</span><span class="p">,</span> <span class="n">_Deleter</span> <span class="n">__d</span><span class="p">,</span> <span class="k">const</span> <span class="n">_Alloc</span> <span class="o">&amp;</span><span class="n">__a</span><span class="p">)</span> <span class="k">noexcept</span>
      <span class="o">:</span> <span class="n">_M_impl</span><span class="p">(</span><span class="n">__p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">__d</span><span class="p">),</span> <span class="n">__a</span><span class="p">)</span> <span class="p">{}</span>

  <span class="o">~</span><span class="n">_Sp_counted_deleter</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{}</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">_M_dispose</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_del</span><span class="p">()(</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_ptr</span><span class="p">);</span> <span class="p">}</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">_M_destroy</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="n">__allocator_type</span> <span class="n">__a</span><span class="p">(</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_alloc</span><span class="p">());</span>
    <span class="n">__allocated_ptr</span><span class="o">&lt;</span><span class="n">__allocator_type</span><span class="o">&gt;</span> <span class="n">__guard_ptr</span><span class="p">{</span><span class="n">__a</span><span class="p">,</span> <span class="k">this</span><span class="p">};</span>
    <span class="k">this</span><span class="o">-&gt;~</span><span class="n">_Sp_counted_deleter</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_M_get_deleter</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">type_info</span> <span class="o">&amp;</span><span class="n">__ti</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
<span class="cp">#if __cpp_rtti
</span>    <span class="c1">// _GLIBCXX_RESOLVE_LIB_DEFECTS</span>
    <span class="c1">// 2400. shared_ptr's get_deleter() should use addressof()</span>
    <span class="k">return</span> <span class="n">__ti</span> <span class="o">==</span> <span class="k">typeid</span><span class="p">(</span><span class="n">_Deleter</span><span class="p">)</span> <span class="o">?</span> <span class="n">std</span><span class="o">::</span><span class="n">__addressof</span><span class="p">(</span><span class="n">_M_impl</span><span class="p">.</span><span class="n">_M_del</span><span class="p">())</span>
                                    <span class="o">:</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="cp">#else
</span>    <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="cp">#endif
</span>  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">_Impl</span> <span class="n">_M_impl</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">_Deleter</code> type is erased at compile time, <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> type will only store a pointer of <code class="language-plaintext highlighter-rouge">_Sp_counted_base</code> type, which makes the <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> type not depend on custom deleters.</p>

<h2 id="more-about-binding">More about binding</h2>

<p>After a type is erased, we <strong>have to</strong> bind to the correct <em>implementations</em>. The implementation must coorespond to this type, otherwise, there will be errors if we pass a <em>void</em> pointer to this implementation, since inside this implementation, the <em>void</em> pointer will be cast back to this type. Of course, there can be multiple implementations for this type, <strong>but, there is only one binding</strong>. Better use examples:</p>

<ul>
  <li>Whether itâ€™s compile time or runtime, as long as the binding is finished, it <em>cannot</em> be changed.</li>
  <li>For virtual class, when a derived class instance is created, itâ€™s vtable is bound to vtable of this class, itâ€™s <em>wrong</em> to change it.</li>
  <li>For template functions, which binds at compile time, itâ€™s fixed after compilation, and cannot be changed.</li>
  <li>For <code class="language-plaintext highlighter-rouge">std::function</code>, we can have multiple variable for the same signature: <code class="language-plaintext highlighter-rouge">std::function&lt;int(int)&gt; a</code>, <code class="language-plaintext highlighter-rouge">std::function&lt;int(int)&gt;b</code>, and they can have <strong>different</strong> implementations. However, after <strong>construction</strong> of <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, their binding to implementation is <em>fixed</em>, we cannot change <code class="language-plaintext highlighter-rouge">a</code>â€™s implementation to <code class="language-plaintext highlighter-rouge">b</code>â€™s. Of course, we can assign <code class="language-plaintext highlighter-rouge">a</code> to <code class="language-plaintext highlighter-rouge">b</code>, which will create a copy of <code class="language-plaintext highlighter-rouge">b</code>, but this is <em>not</em> changing the binding of <code class="language-plaintext highlighter-rouge">a</code>.  Even though <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> are of the same type, but they contain and bind to different callables:
    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Res</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">_ArgTypes</span><span class="p">&gt;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Functor</span><span class="p">,</span> <span class="k">typename</span><span class="p">,</span> <span class="k">typename</span><span class="p">&gt;</span>
<span class="n">function</span><span class="o">&lt;</span><span class="n">_Res</span><span class="p">(</span><span class="n">_ArgTypes</span><span class="p">...)</span><span class="o">&gt;::</span><span class="n">function</span><span class="p">(</span><span class="n">_Functor</span> <span class="n">__f</span><span class="p">)</span> <span class="o">:</span> <span class="n">_Function_base</span><span class="p">()</span> <span class="p">{</span>
<span class="k">typedef</span> <span class="n">_Function_handler</span><span class="o">&lt;</span><span class="n">_Res</span><span class="p">(</span><span class="n">_ArgTypes</span><span class="p">...),</span> <span class="n">_Functor</span><span class="o">&gt;</span> <span class="n">_My_handler</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">_My_handler</span><span class="o">::</span><span class="n">_M_not_empty_function</span><span class="p">(</span><span class="n">__f</span><span class="p">))</span> <span class="p">{</span>
  <span class="n">_My_handler</span><span class="o">::</span><span class="n">_M_init_functor</span><span class="p">(</span><span class="n">_M_functor</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">__f</span><span class="p">));</span>
  <span class="n">_M_invoker</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_My_handler</span><span class="o">::</span><span class="n">_M_invoke</span><span class="p">;</span>
  <span class="n">_M_manager</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_My_handler</span><span class="o">::</span><span class="n">_M_manager</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <p>After <em>construction</em> the binding is fixed and can not be changed.</p>
  </li>
</ul>

<h2 id="stdvariant">std::variant</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">std::variant</code> itself is not type erasure, itâ€™s a union and will record flags to indicate which type it currently stores</li>
  <li><code class="language-plaintext highlighter-rouge">std::visit</code> involves two phase:
    <ul>
      <li>Dispatch right function according to specific type stored in std::variant at runtime</li>
      <li>Each function is stored type erased, like <code class="language-plaintext highlighter-rouge">std::function</code></li>
    </ul>
  </li>
</ul>]]></content><author><name></name></author><category term="c++" /><summary type="html"><![CDATA[This is understanding notes for this presentation: C++ Type Erasure Demystified - Fedor G Pikus - C++Now 2024. Ppt at here.]]></summary></entry><entry><title type="html">Reactor and Proactor Exectuion Context</title><link href="http://localhost:4000/2025/03/29/reactor-proactor.html" rel="alternate" type="text/html" title="Reactor and Proactor Exectuion Context" /><published>2025-03-29T09:22:46+08:00</published><updated>2025-03-29T09:22:46+08:00</updated><id>http://localhost:4000/2025/03/29/reactor-proactor</id><content type="html" xml:base="http://localhost:4000/2025/03/29/reactor-proactor.html"><![CDATA[<p>Following content aggregates materials about <em>reactor</em> and <em>proactor</em>, along with some keynotes about it.</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://github.com/shan-weiqiang/shan-weiqiang.github.io/blob/main/assets/files/tpd_reactor_proactor.pdf">Reactor and Proactor, Examples of event handling patterns</a>: Great material on what is reactor and what is proactor.</li>
  <li><a href="https://github.com/shan-weiqiang/shan-weiqiang.github.io/blob/main/assets/files/The%20Proactor%20Design%20Pattern.pdf">The Proactor Design Pattern: Concurrency Without Threads</a>: Explains the boost.asio proactor design pattern. What is key about this material is that it also explains the relationship between reactor and proactor in Linux: proactor is implemented on top of reactor(epoll).</li>
  <li><a href="https://en.wikipedia.org/wiki/Proactor_pattern">Proactor Wikipedia</a>: The wiki page reveals an important fact about proactor: <strong>The proactor pattern can be considered to be an asynchronous variant of the synchronous reactor pattern.</strong></li>
</ul>

<h2 id="keynotes">Keynotes</h2>

<ul>
  <li>Reactor in Linux has native OS support through system primitives like <code class="language-plaintext highlighter-rouge">epoll</code>. But Linux does not have native support for proactor. Windows have native support for proactor, IOCP</li>
  <li>In Linux, proactor is implemented on top of reactor.</li>
  <li>Reactor is <em>synchronous</em> I/O, while proactor is <em>asynchronous</em> I/O.</li>
  <li>Again and important: <strong>The proactor pattern can be considered to be an asynchronous variant of the synchronous reactor pattern.</strong></li>
  <li>Reactor in Linux can be simplified as I/O multiplexing.</li>
</ul>

<h2 id="execution-context">Execution Context</h2>

<p>One thing that have long been confusing me about proactor is itâ€™s execution context. For reactor, it occupies one execution context(eg, a thread) and blockingly waiting for any of file descriptors to be ready for relevant events. Since in Linux proactors are implemented on top of reactor, does proactor need additional execution context? In Boost, proactor is called <a href="https://live.boost.org/doc/libs/1_47_0/doc/html/boost_asio/overview/core/async.html"><em>The Proactor Design Pattern: Concurrency Without Threads</em></a>, which indicates that there are no additional threads required for proactor. Then how to implement proactor in one thread, knowing that reactor itself already occupies one thread?</p>

<p>The foundation here is to know that(in the context of <code class="language-plaintext highlighter-rouge">boost.asio</code>):</p>

<ul>
  <li>There is a underlying reactor, which is normally implemented using <code class="language-plaintext highlighter-rouge">epoll</code> in Linux.</li>
  <li>There is one execution context, <code class="language-plaintext highlighter-rouge">io_context</code>, which will be called in one thread <code class="language-plaintext highlighter-rouge">io_context.run()</code>, which will call <code class="language-plaintext highlighter-rouge">epoll</code> wait under the hood.</li>
  <li>That <code class="language-plaintext highlighter-rouge">epoll</code> can monitor multiple file descriptors and can be updated.</li>
</ul>

<p>Yet there is one brick missing to understanding the proactor pattern: <em>software events</em>. Epoll can only monitor file descriptors, like if a file descriptor is readable, writable, etc. But proactor requires that the <em>epoll_wait</em> be unblocked if a user async operation is completed. How can epoll monitor these kinds of events? In the reactor that is used to implement proactor, there is an pre-defined additional file descriptor, it might be a pipe, uds socket, or something else, as long as it can be written and read. This fd is used to unblock <em>epoll_wait</em> whenever there is software events. For example, <em>epoll_wait</em> monitor this fd, <em>fd_events</em> and another socket fd, <em>fd_socket</em>. <em>fd_socket</em> is to read bytes from a connection. <em>fd_events</em> is a, for example, pipe. There is a async reading operation initiated by user to read n bytes from <em>fd_socket</em>, and also a completion handler is provided and registered. Now the <em>epoll_wait</em> is blocked waiting to read from <em>fd_socket</em>, and the execution context thread is suspended in OS. Now n-1 bytes are recieved from kernel and is ready to be read. The <em>epoll_wait</em> is unblocked and find that <em>fd_socket</em> is ready to read from. The reactor calls relevant callbacks to read from this socket. Since the callback only read n-1 bytes, not n bytes, which is required by the async operation, it exit the loop and give control to <em>epoll_wait</em> again. Next, the last one byte finally arrived, again the <em>epoll_wait</em> is unblocked and the registered callback is called to read the last one byte. After reading, inside the callback, it knows that the operation is finally completed as required from the async operation. It now writes the completion information to the <em>fd_events</em> and exit the loop to go back to <em>epoll_wait</em> again. This time the <em>epoll_wait</em> immediately unblocks since there are content to be read from <em>fd_events</em>, software events happen. The reactor calls relevant software events callback and process the software events. Inside the callback, it first read from the <em>fd_events</em> and knows which software events happen and according to the information,it finds the corresponding completion handler and executes it. It goes on until all completed software events handlers are executed, then goes to <em>epoll_wait</em> again.</p>

<p>Letâ€™s understand above process with the help of following code snippet:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"make_day_time.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;asio.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="cp">#ifndef ASYNC_UDP
#define ASYNC_UDP
</span>
<span class="k">using</span> <span class="n">asio</span><span class="o">::</span><span class="n">ip</span><span class="o">::</span><span class="n">udp</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">udp_server</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">udp_server</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">io_context</span> <span class="o">&amp;</span><span class="n">io_context</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">socket_</span><span class="p">(</span><span class="n">io_context</span><span class="p">,</span> <span class="n">udp</span><span class="o">::</span><span class="n">endpoint</span><span class="p">(</span><span class="n">udp</span><span class="o">::</span><span class="n">v4</span><span class="p">(),</span> <span class="mi">5002</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">start_receive</span><span class="p">();</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">udp</span><span class="o">::</span><span class="n">socket</span> <span class="n">socket_</span><span class="p">;</span>
  <span class="n">udp</span><span class="o">::</span><span class="n">endpoint</span> <span class="n">remote_endpoint</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">buffer</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">start_receive</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">socket_</span><span class="p">.</span><span class="n">async_receive_from</span><span class="p">(</span>
        <span class="n">asio</span><span class="o">::</span><span class="n">buffer</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="n">remote_endpoint</span><span class="p">,</span>
        <span class="p">[</span><span class="k">this</span><span class="p">](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="o">&amp;</span><span class="n">error</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">msg</span> <span class="o">=</span>
                <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">make_daytime_string</span><span class="p">());</span>
            <span class="n">socket_</span><span class="p">.</span><span class="n">async_send_to</span><span class="p">(</span>
                <span class="n">asio</span><span class="o">::</span><span class="n">buffer</span><span class="p">(</span><span class="o">*</span><span class="n">msg</span><span class="p">),</span> <span class="n">remote_endpoint</span><span class="p">,</span>
                <span class="p">[](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="o">&amp;</span><span class="n">error</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">)</span> <span class="p">{});</span>
            <span class="n">start_receive</span><span class="p">();</span>
          <span class="p">}</span>
        <span class="p">});</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="cp">#endif
</span></code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">io_context</code> serves as the sole execution context. It will be run inside one thread. The reactor is implemented inside <code class="language-plaintext highlighter-rouge">asio::io_context</code></li>
  <li><code class="language-plaintext highlighter-rouge">socket_.async_receive_from</code> is the asyn operation initialized from user. It provides two requirements:
    <ul>
      <li>The receive operation should fill the buffer</li>
      <li>After the buffer is filled, the lambda completion handler should be called
  Inside this call, it will register:
        <ul>
          <li>Monitoring of this socket to <code class="language-plaintext highlighter-rouge">io_context</code>, when itâ€™s available to read, epoll will unblock. <strong>Note that after the reading is completed, inside the callback registered to the reactor, it will deregister the monitoring of this socket from the reactor. Then also inside the callback, it will trigger software events to make the execution context execute completion handler in next loop of <em>epoll_wait</em>.</strong></li>
          <li>Register software event and itâ€™s handler(the lambda) to this same <code class="language-plaintext highlighter-rouge">io_context</code>, expecting it to be called when the reading is completed. This call returns immediately.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Inside the lambda, <code class="language-plaintext highlighter-rouge">socket_.async_send_to</code> is called to give feedback. Again itâ€™s the same pattern as <code class="language-plaintext highlighter-rouge">socket_.async_receive_from</code> , except that this time the reactor will unblock when this socket is available to write. After the writing complete, the completion lambda is again called as software event.</li>
  <li>Inside the <code class="language-plaintext highlighter-rouge">socket_.async_send_to</code> completion handler, <code class="language-plaintext highlighter-rouge">start_receive();</code> is called recursively, which starts the loop again.</li>
  <li>Note that the send-recieve-send-recieve is executed in order.</li>
</ul>

<p>Do not call async read and write operations before the last one is completed. There is no meaning to do that anyway:</p>

<ul>
  <li>Interleaved read/write is meaningless, even if it is possible(I donâ€™t know if it is possible in <code class="language-plaintext highlighter-rouge">asio</code>)</li>
  <li>Even if the async operations are queued by <code class="language-plaintext highlighter-rouge">asio</code>(again I donâ€™t know if it is the case in <code class="language-plaintext highlighter-rouge">asio</code>), we can chain the read/write in completion handlers to have the same effect.</li>
</ul>]]></content><author><name></name></author><category term="linux" /><summary type="html"><![CDATA[Following content aggregates materials about reactor and proactor, along with some keynotes about it.]]></summary></entry><entry><title type="html">Expressions: type and value category</title><link href="http://localhost:4000/2025/02/28/cplusplus-expressions.html" rel="alternate" type="text/html" title="Expressions: type and value category" /><published>2025-02-28T09:22:46+08:00</published><updated>2025-02-28T09:22:46+08:00</updated><id>http://localhost:4000/2025/02/28/cplusplus-expressions</id><content type="html" xml:base="http://localhost:4000/2025/02/28/cplusplus-expressions.html"><![CDATA[<p>According to my experience, the most difficult part in understanding C++ is however the most basic one: the <code class="language-plaintext highlighter-rouge">expression</code>. Only by having a comprehensive understanding of <code class="language-plaintext highlighter-rouge">expression</code>, one can further have a clear understanding about lvalue, rvalue, type deduction, <code class="language-plaintext highlighter-rouge">auto</code> keyword, universal reference, <code class="language-plaintext highlighter-rouge">decltype</code>, move semantics,etc. As you can see, above-mentioned concepts are at the core of C++ 11 and afterwards.</p>

<p>This blog summarize information, concepts, references around <code class="language-plaintext highlighter-rouge">expression</code>. It does not provide additional knowledge, but act as a understanding note.</p>

<ul id="markdown-toc">
  <li><a href="#expressions" id="markdown-toc-expressions">Expressions</a>    <ul>
      <li><a href="#type" id="markdown-toc-type">Type</a></li>
      <li><a href="#value-category" id="markdown-toc-value-category">Value Category</a></li>
      <li><a href="#type-vs-valuecategory" id="markdown-toc-type-vs-valuecategory">Type vs ValueCategory</a></li>
    </ul>
  </li>
  <li><a href="#type-deduction" id="markdown-toc-type-deduction">Type Deduction</a>    <ul>
      <li><a href="#deduction-context" id="markdown-toc-deduction-context">Deduction context</a></li>
      <li><a href="#function-template-parameter-type-deduction" id="markdown-toc-function-template-parameter-type-deduction">Function template parameter type deduction</a></li>
      <li><a href="#auto-deduction" id="markdown-toc-auto-deduction">auto deduction</a></li>
      <li><a href="#more-about-universal-reference" id="markdown-toc-more-about-universal-reference">More about Universal Reference</a>        <ul>
          <li><a href="#reference-collapsing-rules" id="markdown-toc-reference-collapsing-rules">Reference Collapsing Rules</a></li>
          <li><a href="#key-points--golden-rules" id="markdown-toc-key-points--golden-rules">Key Points &amp; Golden Rules</a></li>
          <li><a href="#stdforward-explained" id="markdown-toc-stdforward-explained">std::forward explained</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#named-variables" id="markdown-toc-named-variables">Named Variables</a></li>
  <li><a href="#decltype" id="markdown-toc-decltype">decltype</a>    <ul>
      <li><a href="#print-valueness" id="markdown-toc-print-valueness">Print valueness</a></li>
    </ul>
  </li>
  <li><a href="#static_cast-vs-decltype" id="markdown-toc-static_cast-vs-decltype">static_cast vs decltype</a></li>
  <li><a href="#declval" id="markdown-toc-declval">declval</a></li>
</ul>

<h1 id="expressions">Expressions</h1>

<p><a href="https://en.cppreference.com/w/cpp/language/expressions">C++ expressions</a></p>

<p>Each C++ expression (an operator with its operands, a literal, a variable name, etc.) is characterized by two independent properties: a type and a value category. Each expression has some non-reference type, and each expression belongs to exactly one of the three primary value categories: <em>prvalue</em>, <em>xvalue</em>, and <em>lvalue</em>.</p>

<h2 id="type">Type</h2>

<p>An expression can have basic type, user-defined type, const/non-const, reference/non-reference types. However, <strong>If an expression initially has the type â€œreference to Tâ€ (8.3.2, 8.5.3), the type is adjusted to T prior to any further analysis.</strong>, which indicates that expression can have reference types. <a href="https://scottmeyers.blogspot.com/2015/02/expressions-can-have-reference-type.html">Expressions can have Reference Type</a>:</p>

<blockquote>
  <p>Today I got email about some information in <em>Effective Modern C++</em>. The email included the statement, â€œAn expression never has reference type.â€ This is easily shown to be incorrect, but people assert it to me often enough that Iâ€™m writing this blog entry so that I can refer people to it in the future.</p>

  <p>Section 5/5 of the Standard is quite clear (Iâ€™ve put the relevant text in bold):</p>

  <blockquote>
    <p><strong>If an expression initially has the type â€œreference to Tâ€</strong> (8.3.2, 8.5.3), the type is adjusted to T prior to any further analysis. The expression designates the object or function denoted by the reference, and the expression is an lvalue or an xvalue, depending on the expression.</p>
  </blockquote>

  <p>Thereâ€™d clearly be no need for this part of the Standard if expressions couldnâ€™t have reference type.</p>

  <p>If thatâ€™s not enough to settle the matter, consider the type of an expression that consists of a function call. For example:</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        int&amp; f();                // f returns int&amp;
        auto x = f();            // a call to f
        
</code></pre></div>  </div>

  <p>What is the type of the expression â€œf()â€, i.e., the type of the expression consisting of a call to f? Itâ€™s hard to imagine anybody arguing that itâ€™s not int&amp;, i.e., a reference type. But what does the Standard say? Per 5.2.2/3 (where Iâ€™ve again put the relevant text in bold and where Iâ€™m grateful to Marcel Wid for correcting the error I had in an earlier version of this post that referred to 5.2.2/10):</p>

  <blockquote>
    <p>If the <em>postfix-expression</em> designates a destructor (12.4), the type of the function call expression is void; otherwise, <strong>the type of the function call expression is the return type of the statically chosen function</strong> (i.e., ignoring the virtual keyword), even if the type of the function actually called is different. This return type shall be an object type, <strong>a reference type</strong> or cv void.</p>
  </blockquote>

  <p>Itâ€™s very clear that expressions can have reference type. Section 5/5 takes those expressions and strips the reference-ness off of them before doing anything else, but thatâ€™s not the same as the reference-ness never being present in the first place.</p>
</blockquote>

<h2 id="value-category">Value Category</h2>

<p><a href="https://en.cppreference.com/w/cpp/language/value_category">C++ value_category</a></p>

<blockquote>
  <p>With the introduction of move semantics in C++11, value categories were redefined to characterize two independent properties of expressions[<a href="https://en.cppreference.com/w/cpp/language/value_category#cite_note-5">5]</a>:</p>

  <ul>
    <li><em>has identity</em>: itâ€™s possible to determine whether the expression refers to the same entity as another expression, such as by comparing addresses of the objects or the functions they identify (obtained directly or indirectly);</li>
    <li><em>can be moved from</em>: <a href="https://en.cppreference.com/w/cpp/language/move_constructor">move constructor</a>, <a href="https://en.cppreference.com/w/cpp/language/move_assignment">move assignment operator</a>, or another function overload that implements move semantics can bind to the expression.</li>
  </ul>

  <p>In C++11, expressions that:</p>

  <ul>
    <li>have identity and cannot be moved from are called <em>lvalue</em> expressions;</li>
    <li>have identity and can be moved from are called <em>xvalue</em> expressions;</li>
    <li>do not have identity and can be moved from are called <em>prvalue</em> (â€œpure rvalueâ€) expressions;</li>
    <li>do not have identity and cannot be moved from are not used[<a href="https://en.cppreference.com/w/cpp/language/value_category#cite_note-6">6]</a>.</li>
  </ul>

  <p>The expressions that have identity are called â€œglvalue expressionsâ€ (glvalue stands for â€œgeneralized lvalueâ€). Both lvalues and xvalues are glvalue expressions.</p>

  <p>The expressions that can be moved from are called â€œrvalue expressionsâ€. Both prvalues and xvalues are rvalue expressions.</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   ______ ______

  /      X      \

 /      / \      \

|   l  | x |  pr  |

 \      \ /      /

  \______X______/

â€‹      gl    r
</code></pre></div></div>

<p>Above diagram describes the general relationship between <em>lvalue</em>(l), <em>xvalue</em>(x), <em>prvalue</em>(pr), <em>glvalue</em>(gl), <em>rvalue</em>(r)</p>

<h2 id="type-vs-valuecategory">Type vs ValueCategory</h2>

<p>Lvalueness or rvalueness of an expression is independent of its type, itâ€™s possible to have lvalues whose type is rvalue reference, and itâ€™s also possible to have rvalues of the type rvalue reference. See examples from <a href="https://github.com/shan-weiqiang/cplusplus/blob/main/expression/universal-references-and-reference-collapsing-scott-meyers.pdf">Universal References in C++11, Scott Meyers</a>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Widget</span> <span class="nf">makeWidget</span><span class="p">();</span>
 <span class="c1">// factory function for Widget</span>
<span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">var1</span> <span class="o">=</span> <span class="n">makeWidget</span><span class="p">()</span>
 <span class="c1">// var1 is an lvalue, but</span>
 <span class="c1">// its type is rvalue reference (to Widget)</span>
<span class="n">Widget</span> <span class="n">var2</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">var1</span><span class="p">);</span>
 <span class="c1">// the cast expression yields an rvalue, but</span>
 <span class="c1">// its type is rvalue reference (to Widget)</span>
</code></pre></div></div>

<p>Note that the valueness of expression <code class="language-plaintext highlighter-rouge">static_cast</code> is decided by <a href="https://en.cppreference.com/w/cpp/language/static_cast"><code class="language-plaintext highlighter-rouge">static_cast</code></a> itself:</p>

<blockquote>
  <p>As with all cast expressions, the result is:</p>

  <ul>
    <li>An lvalue if target-type is an lvalue reference type or an rvalue reference to function type(since C++11);</li>
    <li>A xvalue if target-type is an rvalue reference to object type; [swq: how <code class="language-plaintext highlighter-rouge">std::move</code> is implemented] (since C++11)</li>
    <li>A prvalue otherwise.</li>
  </ul>
</blockquote>

<h1 id="type-deduction">Type Deduction</h1>

<h2 id="deduction-context">Deduction context</h2>

<p>We consider two occasions where type deduction happens:</p>

<ul>
  <li><a href="(https://en.cppreference.com/w/cpp/language/template_argument_deduction).">Function template parameter type deduction</a></li>
  <li><code class="language-plaintext highlighter-rouge">auto</code></li>
</ul>

<p>Additionally, a special kind of type deduction, universal reference is considered.</p>

<p>During compile time compiler has mainly two ways to deduce template parameter types: from user and auto deduction. In the case of user input, whatever user specifies, compiler will use them. If user specified reference, reference collapsing rules apply. Also in C++ 17, class template parameter type can also be deduced: <a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">Class template argument deduction (CTAD) (since C++17)</a>.</p>

<h2 id="function-template-parameter-type-deduction">Function template parameter type deduction</h2>

<p>Note: Most content of this paragraph comes from the book: <em>Effective Modern C++, Scott Meyers</em>. I only copies them here to make this artical complete.</p>

<p>Take:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">ParamType</span> <span class="n">param</span><span class="p">);</span>
<span class="n">f</span><span class="p">(</span><span class="n">expr</span><span class="p">);</span> <span class="c1">// deduce T and ParamType from expr</span>

<span class="c1">// Above pseudo code can represent most cases, since reference, const are not allowed insdie parameter list: template&lt;typename const T&gt; and template&lt;typename T&amp;&gt; and template&lt;typename T&amp;&amp;&gt; are both not valid. However, when user specify T, const and reference types can be used and reference collapsing rules apply.</span>
</code></pre></div></div>

<p>Note: <code class="language-plaintext highlighter-rouge">typename</code> can only be <code class="language-plaintext highlighter-rouge">class</code>, or <code class="language-plaintext highlighter-rouge">typename</code>, no additional qualifiers are possible: <a href="https://en.cppreference.com/w/cpp/language/template_parameters">type-parameter-key	-either typename or class</a></p>

<ul>
  <li>Case 1: ParamType is a Reference or Pointer, but not a Universal Reference
    <ul>
      <li>If exprâ€™s type is a reference, ignore the reference part</li>
      <li>Then pattern-match exprâ€™s type against ParamType to determine T.</li>
    </ul>
  </li>
  <li>Case 2: ParamType is a Universal Reference
    <ul>
      <li>If expr is an lvalue, both T and ParamType are deduced to be lvalue references. Thatâ€™s doubly unusual. First, itâ€™s the only situation in  template type deduction where T is deduced to be a reference. Second, although ParamType is declared using the syntax for an rvalue reference, its deduced type is an lvalue reference.</li>
      <li>If expr is an rvalue, the â€œnormalâ€ (i.e., Case 1) rules apply.</li>
    </ul>
  </li>
  <li>Case 3: ParamType is Neither a Pointer nor a Reference
    <ul>
      <li>As before, if exprâ€™s type is a reference, ignore the reference part</li>
      <li>If, after ignoring exprâ€™s reference-ness, expr is const, ignore that, too. If itâ€™s volatile, also ignore that.</li>
    </ul>
  </li>
</ul>

<h2 id="auto-deduction">auto deduction</h2>

<p>Itâ€™s essentially the same as function template parameter type deduction like above, the mappings relationships are:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">auto</code> â€“&gt; <code class="language-plaintext highlighter-rouge">T</code></li>
  <li>Expression before <code class="language-plaintext highlighter-rouge">=</code> â€“&gt; <code class="language-plaintext highlighter-rouge">ParamType</code></li>
  <li>Expression after <code class="language-plaintext highlighter-rouge">=</code> â€“&gt; <code class="language-plaintext highlighter-rouge">expr</code></li>
</ul>

<p>For example:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span> <span class="c1">// case 3 (x is neither ptr nor reference)</span>
<span class="k">const</span> <span class="k">auto</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// case 3 (cx isn't either)</span>
<span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// case 1 (rx is a non-universal ref.)</span>
<span class="c1">// T --&gt; auto; const auto&amp; --&gt; ParamType; x --&gt; expr</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">auto</code> can also be used in lamda and support universal reference:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="c1">// Default constructor</span>
  <span class="n">A</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Default constructor called</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Destructor</span>
  <span class="o">~</span><span class="n">A</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Destructor called</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Copy constructor</span>
  <span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Copy constructor called</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Move constructor</span>
  <span class="n">A</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Move constructor called</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Copy assignment operator</span>
  <span class="n">A</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Copy assignment operator called</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Move assignment operator</span>
  <span class="n">A</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Move assignment operator called</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
                <span class="c1">// e is of lvalue, copy contructor called</span>
                <span class="c1">// Note: e is not expression here, decltype get the real type of</span>
                <span class="c1">// e, for universal reference, it's either non-reference type or</span>
                <span class="c1">// lvalue reference type</span>
                <span class="p">[](</span><span class="k">auto</span> <span class="o">&amp;&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">);</span> <span class="p">});</span>

  <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_move_iterator</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">()),</span>
                <span class="n">std</span><span class="o">::</span><span class="n">make_move_iterator</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">()),</span>
                <span class="c1">// e is of xvalue, move contructor called</span>
                <span class="c1">// Note: e is not expression here, decltype get the real type of</span>
                <span class="c1">// e, for universal reference, it's either non-reference type or</span>
                <span class="c1">// lvalue reference type</span>
                <span class="p">[](</span><span class="k">auto</span> <span class="o">&amp;&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">);</span> <span class="p">});</span>
<span class="p">}</span>

</code></pre></div></div>

<h2 id="more-about-universal-reference">More about Universal Reference</h2>

<p><a href="https://github.com/shan-weiqiang/cplusplus/blob/main/expression/universal-references-and-reference-collapsing-scott-meyers.pdf">Universal References in C++11, Scott Meyers</a></p>

<h3 id="reference-collapsing-rules">Reference Collapsing Rules</h3>

<p><a href="https://en.cppreference.com/w/cpp/language/reference">C++ Reference</a></p>

<ul>
  <li>An rvalue reference to an rvalue reference becomes (â€˜collapses intoâ€™) an rvalue reference.</li>
  <li>All other references to references (i.e., all combinations involving an lvalue reference) collapse into an lvalue reference.</li>
</ul>

<h3 id="key-points--golden-rules">Key Points &amp; Golden Rules</h3>

<ul>
  <li>Remember that â€œ&amp;&amp;â€ indicates a universal reference only where type deduction takes place.  Where thereâ€™s no type deduction, thereâ€™s no universal reference.  In such cases, â€œ&amp;&amp;â€ in type declarations always means rvalue reference.</li>
  <li>Apply std::move to rvalue references and std::forward to universal references</li>
  <li>Only use std::forward with universal references</li>
  <li><strong>Universal reference type deduction is the only situation a template parameter is deduced as reference(when passed type is of lvalue).</strong></li>
</ul>

<h3 id="stdforward-explained">std::forward explained</h3>

<p><a href="https://en.cppreference.com/w/cpp/utility/forward">std::forward</a></p>

<ul>
  <li>Only use <code class="language-plaintext highlighter-rouge">std::forward</code> with universal reference. So the template argument for it should always be deduced, instead of specified.
    <ul>
      <li>This implies that the deduced type T is either non-reference type or a lvalue reference.</li>
      <li>Always use universal reference template paramter <code class="language-plaintext highlighter-rouge">T</code> <strong>directly</strong> for <code class="language-plaintext highlighter-rouge">std::forward</code>â€™s template paramters, do not manually add additional const/reference to it. Note that <code class="language-plaintext highlighter-rouge">T</code> can be decorated: like <code class="language-plaintext highlighter-rouge">forward&lt;decltype(forward&lt;T&gt;(arg).get())&gt;</code>, as long as <code class="language-plaintext highlighter-rouge">T</code> itself is the same as the universal reference.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">std::forward</code> is an <em>expression</em> and <em>function</em>, itâ€™s value category conform to normal C++ expression rules. It always return <em>reference</em>:
    <ul>
      <li>When return lvalue reference, its value category is lvalue</li>
      <li>When return rvalue reference, its value category is rvalue(xvalue or prvalue)</li>
      <li>Above behavior is due to the fact that when cast to rvalue reference, the result of <code class="language-plaintext highlighter-rouge">static_cast</code> is of xvalue; when cast to non-reference, the result is of prvalue; when cast to lvalue reference, the result is of lvalue.</li>
    </ul>
  </li>
  <li>The type and valueness is decided by <code class="language-plaintext highlighter-rouge">static_cast</code>, which is the internal implementation of <code class="language-plaintext highlighter-rouge">std::forward</code></li>
</ul>

<p>The standard implements <code class="language-plaintext highlighter-rouge">std::forward</code>:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cm">/**
   *  @brief  Forward an lvalue.
   *  @return The parameter cast to the specified type.
   *
   *  This function is used to implement "perfect forwarding".
   */</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Tp</span><span class="p">&gt;</span>
    <span class="k">constexpr</span> <span class="n">_Tp</span><span class="o">&amp;&amp;</span>
    <span class="n">forward</span><span class="p">(</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;</span> <span class="n">__t</span><span class="p">)</span> <span class="k">noexcept</span>
    <span class="p">{</span> <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">__t</span><span class="p">);</span> <span class="p">}</span>

  <span class="cm">/**
   *  @brief  Forward an rvalue.
   *  @return The parameter cast to the specified type.
   *
   *  This function is used to implement "perfect forwarding".
   */</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Tp</span><span class="p">&gt;</span>
    <span class="k">constexpr</span> <span class="n">_Tp</span><span class="o">&amp;&amp;</span>
    <span class="n">forward</span><span class="p">(</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;&amp;</span> <span class="n">__t</span><span class="p">)</span> <span class="k">noexcept</span>
    <span class="p">{</span>
      <span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_lvalue_reference</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="s">"template argument"</span>
		    <span class="s">" substituting _Tp is an lvalue reference type"</span><span class="p">);</span>
      <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">__t</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">_Tp</code> is the type deduced from universal references, which might be non-reference type or lvalue reference type. <code class="language-plaintext highlighter-rouge">__t</code> is the parameter passed to <code class="language-plaintext highlighter-rouge">std::forward</code>, which is of lvalue category, since inside function, parameters are passed always as lvalues. The aim of <code class="language-plaintext highlighter-rouge">std::forward</code> is to restore the value category of the passed parameter:</p>

<ul>
  <li>When <code class="language-plaintext highlighter-rouge">_Tp</code> is of non-reference type, which means the universal reference is deduced based on passed rvalue parameter:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">__t</code> is of <code class="language-plaintext highlighter-rouge">_Tp&amp;&amp;</code> type, the second overload is used, <code class="language-plaintext highlighter-rouge">std::forward</code> return rvalue category, rvalue reference type object</li>
    </ul>
  </li>
  <li>When <code class="language-plaintext highlighter-rouge">_Tp</code> is of lvalue reference type, which means the universal reference is deduced based on passed lvalue parameter:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">__t</code> is of <code class="language-plaintext highlighter-rouge">_Tp&amp;</code> type, the first overload is used, <code class="language-plaintext highlighter-rouge">std::forward</code> return lvalue category, lvalue reference type object</li>
    </ul>
  </li>
</ul>

<p>Note: <strong>Type is not changed when parameters are passed down to nested function calls, only value category are changed. This is how <code class="language-plaintext highlighter-rouge">std:forward</code> do overload based on types</strong></p>

<p>Usage1: Forwards lvalues as either lvalues or as rvalues, depending on T:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// arg is always lvalue</span>
    <span class="n">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg</span><span class="p">));</span> <span class="c1">// Forward as lvalue or as rvalue, depending on T</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>When T is deduced to non-reference type,the expression <code class="language-plaintext highlighter-rouge">std::forward</code> is of:
    <ul>
      <li>type: rvalue reference to T</li>
      <li>value category: rvalue</li>
    </ul>
  </li>
  <li>When T is deduced to lvalue reference type, the expression <code class="language-plaintext highlighter-rouge">std::forward</code> is of:
    <ul>
      <li>type: lvalue reference to T</li>
      <li>value category: lvalue</li>
    </ul>
  </li>
</ul>

<p>Note: <strong>This usage is to restore the value category of the passed parameter, whose valueness, due to the nested argument passing, is all treated as lvalue category.</strong></p>

<p>Usage2: Forwards rvalues as rvalues and prohibits forwarding of rvalues as lvalues.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Arg</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span>  <span class="n">get</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// call to this overload is rvalue</span>
    <span class="kt">int</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="o">&amp;</span>  <span class="p">{</span> <span class="k">return</span> <span class="n">i</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// call to this overload is lvalue</span>
<span class="p">};</span>
<span class="c1">// transforming wrapper</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">foo</span><span class="p">(</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg</span><span class="p">).</span><span class="n">get</span><span class="p">())</span><span class="o">&gt;</span><span class="p">(</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg</span><span class="p">).</span><span class="n">get</span><span class="p">()));</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">decltype(forward&lt;T&gt;(arg).get())</code> evalues the type:
    <ul>
      <li>If T is deduced to non-reference type, the expression <code class="language-plaintext highlighter-rouge">forward&lt;T&gt;(arg).get()</code> will have type <code class="language-plaintext highlighter-rouge">int</code> and have xvalueness. <code class="language-plaintext highlighter-rouge">decltype</code> will result in type <code class="language-plaintext highlighter-rouge">int&amp;&amp;</code></li>
      <li>If T is deduced to lvalue reference type, the expression <code class="language-plaintext highlighter-rouge">forward&lt;T&gt;(arg).get()</code> will have type <code class="language-plaintext highlighter-rouge">int&amp;</code> and have lvalueness. <code class="language-plaintext highlighter-rouge">decltype</code> will result int type <code class="language-plaintext highlighter-rouge">int&amp;</code></li>
    </ul>
  </li>
  <li>The second appearance of <code class="language-plaintext highlighter-rouge">forward&lt;T&gt;(arg).get()</code> just call proper implementation of <code class="language-plaintext highlighter-rouge">get()</code></li>
</ul>

<p>Note: when using <code class="language-plaintext highlighter-rouge">decltype</code> as parameter argument to <code class="language-plaintext highlighter-rouge">std::forward</code>, we only need to care about whether the expression in <code class="language-plaintext highlighter-rouge">decltype</code> is lvalue or rvalue, no need to care about the type(only need to know the non-reference type of T). Since if the expression is lvalue, <code class="language-plaintext highlighter-rouge">decltype</code> will result in lvalue reference type, which result in lvalue reference type(lvalueness) for the <code class="language-plaintext highlighter-rouge">std::forward</code>. Otherwise, if the expression inside <code class="language-plaintext highlighter-rouge">decltype</code> is of xvalue or prvalue, <code class="language-plaintext highlighter-rouge">decltype</code> results in non-reference type or rvalue reference type, which both result in a rvalue reference type(rvalueness) for the <code class="language-plaintext highlighter-rouge">std::forward</code> expression. <code class="language-plaintext highlighter-rouge">decltype</code> and <code class="language-plaintext highlighter-rouge">std::forward</code> together to pass the valueness down to nested function calls.</p>

<p>Note: If we use <code class="language-plaintext highlighter-rouge">foo(forward&lt;int&amp;&gt;(forward&lt;T&gt;(arg).get()));</code> and pass a rvalue of <code class="language-plaintext highlighter-rouge">Arg</code> instance to <code class="language-plaintext highlighter-rouge">wrapper</code>, there will be compile time error, since we try to forward rvalue as lvalue(the valueness of the return of <code class="language-plaintext highlighter-rouge">std::forward</code>).</p>

<p><code class="language-plaintext highlighter-rouge">std::forward</code> can be used together with <code class="language-plaintext highlighter-rouge">auto&amp;&amp;</code> in lambdas, which needs the help of <code class="language-plaintext highlighter-rouge">decltype</code> to infer the correct type:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="p">{</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"b"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">};</span>

  <span class="c1">//   This is totally generic</span>
  <span class="k">auto</span> <span class="n">forwarder</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span> <span class="o">&amp;&amp;</span><span class="n">container</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// If container is of lvalue, it's type is lvalue reference type, decltype</span>
    <span class="c1">// return lvalue reference.</span>
    <span class="c1">// If container is of rvalue, it's type is rvalue reference type, decltype</span>
    <span class="c1">// return rvalue reference</span>
    <span class="k">auto</span> <span class="n">dest</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">container</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="n">forwarder</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">source</span><span class="p">));</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">source</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">source2</span> <span class="o">=</span> <span class="p">{</span><span class="s">"x"</span><span class="p">,</span> <span class="s">"y"</span><span class="p">,</span> <span class="s">"z"</span><span class="p">};</span>
  <span class="n">forwarder</span><span class="p">(</span><span class="n">source2</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">source2</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>

<p>However, using of <code class="language-plaintext highlighter-rouge">std::forward</code> in range-based for loop with <code class="language-plaintext highlighter-rouge">auto&amp;&amp;</code> will not work as expected:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="p">{</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"b"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">};</span>

  <span class="c1">//   item is std::string&amp; type, even with std::move</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;&amp;</span><span class="n">item</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">source</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// After std::forward the return  type is still std::string&amp;</span>
    <span class="k">auto</span> <span class="n">dst</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>

<p>In above code snippet, <code class="language-plaintext highlighter-rouge">std::move(source)</code> will not trigger move operation for <code class="language-plaintext highlighter-rouge">source</code> and <code class="language-plaintext highlighter-rouge">item</code> is of lvalue category and lvalue reference type. This behavior can be explained by looking at the internal <a href="https://en.cppreference.com/w/cpp/language/range-for">implementation of range-based for</a> in C++:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="p">{</span>

<span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="cm">/* range */</span> <span class="o">=</span> <span class="n">range</span><span class="o">-</span><span class="n">initializer</span><span class="err">â€Šï»¿</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="cm">/* begin */</span> <span class="o">=</span> <span class="cm">/* begin-expr */</span><span class="p">,</span> <span class="cm">/* end */</span> <span class="o">=</span> <span class="cm">/* end-expr */</span><span class="p">;</span>
<span class="cm">/* begin */</span> <span class="o">!=</span> <span class="cm">/* end */</span><span class="p">;</span> <span class="o">++</span><span class="cm">/* begin */</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">item</span><span class="o">-</span><span class="n">declaration</span> <span class="o">=</span> <span class="err">*/</span><span class="o">*</span> <span class="n">begin</span> <span class="err">*/</span><span class="p">;</span>
<span class="n">statement</span>
<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>First the <code class="language-plaintext highlighter-rouge">auto&amp;&amp;</code> universal reference is used to create a local variable, which is itself a lvalue</li>
  <li>Then use iterator to iterate over this lvalue and dereference this lvalue and create a local variable using <code class="language-plaintext highlighter-rouge">item-declaration</code>, which is the user specified <code class="language-plaintext highlighter-rouge">auto &amp;&amp;item</code></li>
  <li><code class="language-plaintext highlighter-rouge">auto &amp;&amp;item</code> will always be deduced as lvalue reference</li>
  <li>If <code class="language-plaintext highlighter-rouge">auto item</code> is used, <code class="language-plaintext highlighter-rouge">item</code> will be a copy, and the original <code class="language-plaintext highlighter-rouge">const</code> qualifier will be removed</li>
</ul>

<p>To iterate and move element out of a container, move iterators can be used:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="p">{</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"b"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">};</span>

  <span class="c1">//   This will move the element</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_move_iterator</span><span class="p">(</span><span class="n">source</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
       <span class="n">it</span> <span class="o">!=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_move_iterator</span><span class="p">(</span><span class="n">source</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">dst</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>

<h1 id="named-variables">Named Variables</h1>

<p>Named variables and parameters of rvalue reference type are lvalues. Also from <a href="https://github.com/shan-weiqiang/cplusplus/blob/main/expression/universal-references-and-reference-collapsing-scott-meyers.pdf">Universal References in C++11, Scott Meyers</a>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
 <span class="p">...</span>
 <span class="n">Widget</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">);</span>
 <span class="c1">// rhs's type is rvalue reference, but rhs</span>
 <span class="c1">// itself is an lvalue</span>
 <span class="p">...</span>
<span class="p">};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T1</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Gadget</span> <span class="p">{</span>
 <span class="p">...</span>
 <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T2</span><span class="p">&gt;</span>
 <span class="n">Gadget</span><span class="p">(</span><span class="n">T2</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">);</span>
 <span class="c1">// rhs is a universal reference whose type will</span>
 <span class="c1">// eventually become an rvalue reference or an</span>
 <span class="c1">// lvalue reference, but rhs itself is an lvalue</span>
 <span class="p">...</span>
<span class="p">};</span>
</code></pre></div></div>

<p>To create rvalue, <code class="language-plaintext highlighter-rouge">std::move</code>, <code class="language-plaintext highlighter-rouge">std::forward</code>, <code class="language-plaintext highlighter-rouge">static_cast</code> specifier has to be used:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="c1">// Default constructor</span>
  <span class="n">A</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Default constructor called</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Destructor</span>
  <span class="o">~</span><span class="n">A</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Destructor called</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Copy constructor</span>
  <span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Copy constructor called</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Move constructor</span>
  <span class="n">A</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Move constructor called</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Copy assignment operator</span>
  <span class="n">A</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Copy assignment operator called</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Move assignment operator</span>
  <span class="n">A</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Move assignment operator called</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

  <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">A</span> <span class="o">&amp;&amp;</span><span class="n">b</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>

  <span class="c1">// ! This will call copy constructor, NOT move constructor, even b is rvalue</span>
  <span class="c1">// reference type, but it's lvalue</span>
  <span class="n">A</span> <span class="n">c</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

  <span class="c1">// ! This will call move constructor</span>
  <span class="n">A</span> <span class="n">d</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="decltype">decltype</h1>

<p><a href="https://en.cppreference.com/w/cpp/language/decltype">C++ decltype</a></p>

<p>Inspects the declared type of an entity or the type and value category of an expression.
This implies two funtionality of decltype:</p>

<ol>
  <li>When used as decltype ( entity ), where entity is unparenthesized id-expression or class memeber expression, it yields
the type of entity</li>
  <li>When used as decltype ( expression ), where expression is any other expression, it inspects the expressionâ€™s
value type(eg,T) and value category and yields following types accordingly:</li>
</ol>

<ul>
  <li>if value category of expression is xvalue, it yields T&amp;&amp;</li>
  <li>if value category of expression is lvalue, it yields T&amp;</li>
  <li>if value category of expression is prvalue, it yields T</li>
</ul>

<p>Note: if variable id-expression or class memeber access expression is parenthesized, it is treated as ordinary lvalue
expression(which is reasonable, because named variables are always lvalue expressions)</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{};</span>
<span class="n">Widget</span> <span class="nf">makeWidget</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Widget</span><span class="p">();</span> <span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

  <span class="n">Widget</span> <span class="o">&amp;&amp;</span><span class="n">var1</span> <span class="o">=</span> <span class="n">makeWidget</span><span class="p">();</span>
  <span class="c1">// var1 is an lvalue, but</span>
  <span class="c1">// its type is rvalue reference (to Widget)</span>
  <span class="n">Widget</span> <span class="n">var2</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Widget</span> <span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">var1</span><span class="p">);</span>
  <span class="c1">// the cast expression yields an rvalue, but</span>
  <span class="c1">// its type is rvalue reference (to Widget)</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Widget</span> <span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">var1</span><span class="p">))</span> <span class="n">var3</span> <span class="o">=</span> <span class="n">makeWidget</span><span class="p">();</span>
  <span class="c1">//   expression type is Widget &amp;&amp;, value category of expression is xvalue,</span>
  <span class="c1">//   first get the non-reference type Widget, so var3 is of Widget&amp;&amp; type.</span>
  <span class="n">Widget</span> <span class="o">&amp;</span><span class="n">var4</span> <span class="o">=</span> <span class="n">var2</span><span class="p">;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">var4</span><span class="p">))</span> <span class="n">var5</span> <span class="o">=</span> <span class="n">makeWidget</span><span class="p">();</span>
  <span class="c1">// expression type is Widget &amp;, value category of expression is xvalue; first</span>
  <span class="c1">// get the non-reference type Widget, so var5 is of Widget &amp;&amp; type</span>

  <span class="k">decltype</span><span class="p">((</span><span class="n">var4</span><span class="p">))</span> <span class="n">var6</span> <span class="o">=</span> <span class="n">var2</span><span class="p">;</span>
  <span class="c1">// expression type is Widget &amp;, value category of expression is lvalue; first</span>
  <span class="c1">// get the non-reference type Widget, so var6 is of Widget &amp; type</span>

  <span class="k">decltype</span><span class="p">(</span><span class="n">makeWidget</span><span class="p">())</span> <span class="n">var7</span> <span class="o">=</span> <span class="n">makeWidget</span><span class="p">();</span>
  <span class="c1">// expression type is Widget , value category of expression is prvalue; first</span>
  <span class="c1">// get the non-reference type Widget, so var6 is of Widget  type</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note: When doing all deduction the expression type <code class="language-plaintext highlighter-rouge">T</code> will use the non-reference version, since as the standard says:</p>

<blockquote>
  <p>If an expression initially has the type â€œreference to Tâ€ (8.3.2, 8.5.3), the type is adjusted to T prior to any further analysis.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">decltype</code> links valueness of an expression to type.</strong></p>

<h2 id="print-valueness">Print valueness</h2>

<p>First approach, we can check whether the yield type of decltype(expression) is lvalue or rvalue reference, if rvalue
reference, the expression is xvalue; if lvalue reference, the expression is lvalue; otherwise, the expression is prvalue</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="c1"> // for std::move</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Widget</span> <span class="p">{};</span>
<span class="n">Widget</span> <span class="nf">makeWidget</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Widget</span><span class="p">();</span> <span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">value_category</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s">"prvalue"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">value_category</span><span class="o">&lt;</span><span class="n">T</span> <span class="o">&amp;&gt;</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s">"lvalue"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">value_category</span><span class="o">&lt;</span><span class="n">T</span> <span class="o">&amp;&amp;&gt;</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s">"xvalue"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Macro to check the value category of an expression</span>
<span class="cp">#define PRINT_VALUE_CATEGORY(expr)                                             \
  std::cout &lt;&lt; "The expression '" #expr "' is a "                              \
            &lt;&lt; value_category&lt;decltype((expr))&gt;::str() &lt;&lt; std::endl;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Widget</span> <span class="o">&amp;&amp;</span><span class="n">var1</span> <span class="o">=</span> <span class="n">makeWidget</span><span class="p">();</span>
  <span class="n">Widget</span> <span class="n">var2</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Widget</span> <span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">var1</span><span class="p">);</span>
  <span class="n">Widget</span> <span class="o">&amp;</span><span class="n">var4</span> <span class="o">=</span> <span class="n">var2</span><span class="p">;</span>

  <span class="n">PRINT_VALUE_CATEGORY</span><span class="p">(</span><span class="n">var1</span><span class="p">);</span>                         <span class="c1">// lvalue</span>
  <span class="n">PRINT_VALUE_CATEGORY</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Widget</span> <span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">var1</span><span class="p">));</span> <span class="c1">// xvalue</span>
  <span class="n">PRINT_VALUE_CATEGORY</span><span class="p">(</span><span class="n">var4</span><span class="p">);</span>                         <span class="c1">// lvalue</span>
  <span class="n">PRINT_VALUE_CATEGORY</span><span class="p">((</span><span class="n">var4</span><span class="p">));</span>                       <span class="c1">// lvalue</span>
  <span class="n">PRINT_VALUE_CATEGORY</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">var4</span><span class="p">));</span>              <span class="c1">// xvalue</span>
  <span class="n">PRINT_VALUE_CATEGORY</span><span class="p">(</span><span class="n">makeWidget</span><span class="p">());</span>                 <span class="c1">// prvalue</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="static_cast-vs-decltype">static_cast vs decltype</h1>

<p>Letâ€™s compare <code class="language-plaintext highlighter-rouge">static_cast</code> and <code class="language-plaintext highlighter-rouge">decltype</code>:</p>

<p>With <code class="language-plaintext highlighter-rouge">static_cast</code>:</p>

<blockquote>
  <p>As with all cast expressions, the result is:</p>

  <ul>
    <li>An lvalue if target-type is an lvalue reference type or an rvalue reference to function type(since C++11);</li>
    <li>A xvalue if target-type is an rvalue reference to object type; [swq: how <code class="language-plaintext highlighter-rouge">std::move</code> is implemented] (since C++11)</li>
    <li>A prvalue otherwise.(non-reference type)</li>
  </ul>
</blockquote>

<p>With <code class="language-plaintext highlighter-rouge">decltype</code>:</p>

<blockquote>
  <ul>
    <li>if value category of expression is xvalue, it yields T&amp;&amp;</li>
    <li>if value category of expression is lvalue, it yields T&amp;</li>
    <li>if value category of expression is prvalue, it yields T</li>
  </ul>
</blockquote>

<p>They do reverse operations:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">static_cast</code> sets the type/value category (via the target type).</li>
  <li><code class="language-plaintext highlighter-rouge">decltype</code> infers the type/value category (from the expression).</li>
</ul>

<h1 id="declval">declval</h1>

<p><a href="https://en.cppreference.com/w/cpp/utility/declval">C++ declval</a></p>

<p><code class="language-plaintext highlighter-rouge">declval</code> can return a reference to a type, <strong>without going through actual construction</strong>.</p>

<p>Implementation:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">add_rvalue_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span> <span class="nf">declval</span><span class="p">()</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="nb">false</span><span class="p">,</span> <span class="s">"declval not allowed in an evaluated context"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>What <code class="language-plaintext highlighter-rouge">declval</code> does is simply add rvalue reference to type <code class="language-plaintext highlighter-rouge">T</code></li>
  <li>The <code class="language-plaintext highlighter-rouge">static_cast</code> statement make sure that it can only be used in <code class="language-plaintext highlighter-rouge">unevaluated</code> context, like inside <code class="language-plaintext highlighter-rouge">decltype</code></li>
</ul>

<p><a href="https://stackoverflow.com/questions/20303250/is-there-a-reason-declval-returns-add-rvalue-reference-instead-of-add-lvalue-ref/20303350#20303350">Why add rvalue reference, instead of lvalue reference?</a></p>

<p>The reason is related to reference collapsing rules: only by adding rvalue reference, <code class="language-plaintext highlighter-rouge">declval</code> might have the possibility return a rvalue reference, so as to have more possibility to call methods, such as methods that can only be called by rvalue.</p>]]></content><author><name></name></author><category term="c++" /><summary type="html"><![CDATA[According to my experience, the most difficult part in understanding C++ is however the most basic one: the expression. Only by having a comprehensive understanding of expression, one can further have a clear understanding about lvalue, rvalue, type deduction, auto keyword, universal reference, decltype, move semantics,etc. As you can see, above-mentioned concepts are at the core of C++ 11 and afterwards.]]></summary></entry><entry><title type="html">Variable-length shared memory ring buffer</title><link href="http://localhost:4000/2025/01/12/variable-length-shm-ring-buffer.html" rel="alternate" type="text/html" title="Variable-length shared memory ring buffer" /><published>2025-01-12T09:22:46+08:00</published><updated>2025-01-12T09:22:46+08:00</updated><id>http://localhost:4000/2025/01/12/variable-length-shm-ring-buffer</id><content type="html" xml:base="http://localhost:4000/2025/01/12/variable-length-shm-ring-buffer.html"><![CDATA[<p>A variable-length shard memory ring buffer that supports sharing variable length payloads data between processes. This is based on https://github.com/bo-yang/shm_ring_buffer, which only support POD fixed length data. The idea is illustrated in following diagram:</p>

<p><img src="/assets/images/var-length-ring-buffer.png" alt="alt text" /></p>

<p>Github: <a href="https://github.com/shan-weiqiang/shm_ring_buffer">shm_ring_buffer</a></p>]]></content><author><name></name></author><category term="c++" /><summary type="html"><![CDATA[A variable-length shard memory ring buffer that supports sharing variable length payloads data between processes. This is based on https://github.com/bo-yang/shm_ring_buffer, which only support POD fixed length data. The idea is illustrated in following diagram:]]></summary></entry><entry><title type="html">Symbols, libraries and One Definition Rule</title><link href="http://localhost:4000/2024/11/03/symbols-libraries-one-definition-rule.html" rel="alternate" type="text/html" title="Symbols, libraries and One Definition Rule" /><published>2024-11-03T09:22:46+08:00</published><updated>2024-11-03T09:22:46+08:00</updated><id>http://localhost:4000/2024/11/03/symbols-libraries-one-definition-rule</id><content type="html" xml:base="http://localhost:4000/2024/11/03/symbols-libraries-one-definition-rule.html"><![CDATA[<p>In this post, I talk about declaration and definition and their relationship with symbols and code in binaries. Then I discuss library dependency issues and finally the ODR rule. Those are things that we normally donâ€™t care about. However, understanding them give us more control over the binaries we produce.</p>

<ul id="markdown-toc">
  <li><a href="#declaration-and-definition" id="markdown-toc-declaration-and-definition">Declaration and Definition</a>    <ul>
      <li><a href="#data-declaration-and-definition" id="markdown-toc-data-declaration-and-definition">Data declaration and definition</a></li>
      <li><a href="#code-declaration-and-definition" id="markdown-toc-code-declaration-and-definition">Code declaration and definition</a></li>
      <li><a href="#classes-are-combination-of-data-and-code" id="markdown-toc-classes-are-combination-of-data-and-code">Classes are combination of data and code</a></li>
    </ul>
  </li>
  <li><a href="#symbols-and-libraries" id="markdown-toc-symbols-and-libraries">Symbols and libraries</a>    <ul>
      <li><a href="#static-libraries" id="markdown-toc-static-libraries">Static libraries</a></li>
      <li><a href="#shared-libraries" id="markdown-toc-shared-libraries">Shared libraries</a></li>
      <li><a href="#more-about-libraries" id="markdown-toc-more-about-libraries">More about libraries</a>        <ul>
          <li><a href="#symbol-visibility" id="markdown-toc-symbol-visibility">Symbol visibility</a></li>
        </ul>
      </li>
      <li><a href="#best-practices" id="markdown-toc-best-practices">Best practices</a></li>
    </ul>
  </li>
  <li><a href="#one-definition-rule" id="markdown-toc-one-definition-rule">One definition rule</a>    <ul>
      <li><a href="#odr-check-during-linking" id="markdown-toc-odr-check-during-linking">ODR check during linking</a></li>
      <li><a href="#which-definition-to-use" id="markdown-toc-which-definition-to-use">Which definition to use?</a></li>
      <li><a href="#data-definitions-are-special" id="markdown-toc-data-definitions-are-special">Data definitions are special</a></li>
      <li><a href="#code-definitions-are-influenced-by-optimization" id="markdown-toc-code-definitions-are-influenced-by-optimization">Code definitions are influenced by optimization</a></li>
      <li><a href="#how-templates-cope-with-odr" id="markdown-toc-how-templates-cope-with-odr">How templates cope with ODR</a></li>
    </ul>
  </li>
</ul>

<h2 id="declaration-and-definition">Declaration and Definition</h2>

<p>Declaration determines symbols in binary; definition determines code in binary. A definition is itself a declaration. A declaration in a translation unit gives us a <em>promise</em> that the declared entity exists <em>somewhere</em> in the final <em>executable</em>. For example, when we declare <code class="language-plaintext highlighter-rouge">void f();</code> we make a promise that a function called <code class="language-plaintext highlighter-rouge">f</code> can be used, it might be implemented in the current translation unit, or it can be implemented in another translation unit. When we declare <code class="language-plaintext highlighter-rouge">class S{..};</code> we make a promise that a type called <code class="language-plaintext highlighter-rouge">S</code> can be used and compiled in this translation unit, we can use the member functions and members of it in this translation unit and the implementation of those member functions might be elsewhere.</p>

<p>A declaration and definition can be about <em>data</em> or <em>code</em>. They differ in what they really mean for declaration and definition.</p>

<h3 id="data-declaration-and-definition">Data declaration and definition</h3>

<p>For data, such as C++ built-in types and user-defined types, a declaration decides the <em>memory layout</em> of the data. A definition decides a concrete <em>instance</em> of the data. The key points here are:</p>

<ul>
  <li>Data declaration only says that <em>all data of this type must have this kind of memory layout</em></li>
  <li>Data definition says that <em>here you have an instance of this kind of data, its address in memory is â€¦</em></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">class S{...}</code> is a <em>declaration</em>; <code class="language-plaintext highlighter-rouge">S s;</code> is a <em>definition</em>. A definition <em>requires</em> the compiler to allocate memory for this definition. A declaration <em>tells</em> the compiler <em>how</em> to allocate memory for this specific type.</p>

<p>Saying that <em>declaration does not occupy memory</em> is correct but often misleading. Itâ€™s misleading in that it sounds like declarations have nothing to do with memory, which is wrong. A declaration <em>determines</em> how the compiler should allocate memory. Itâ€™s better to say like this:</p>

<p><strong>Declaration tells compiler how to allocate memory; Definition asks for memory from the compiler</strong></p>

<h3 id="code-declaration-and-definition">Code declaration and definition</h3>

<p>For code, declaration and definition meanings are a little different. A declaration of code decides the <em>signature</em> of a function. A definition of code decides the <em>implementation</em> of a function. <code class="language-plaintext highlighter-rouge">int f(double);</code> declares code that accepts <code class="language-plaintext highlighter-rouge">double</code> and returns <code class="language-plaintext highlighter-rouge">int</code>. <code class="language-plaintext highlighter-rouge">int f(double) {...}</code> defines <em>what to do</em> with this function, this definition asks for memory from the compiler to store code. As we can see, itâ€™s more complicated than simple data. We can summarize:</p>

<ul>
  <li>Code declaration says that <em>function should be used in this *form</em> and compiler should allocate memory according to this signature*</li>
  <li>Code definition says that <em>here is the code for the execution of this function and here its address in memory is â€¦</em></li>
</ul>

<p>Difference between data and code declaration and definition is subtle:</p>

<ul>
  <li>Data declaration alone does not produce symbols in binary, while code declaration produces symbols in binary</li>
  <li>Multiple data definitions (with different names) can be made for one data declaration, while only one definition can be made for a code declaration in one translation unit</li>
</ul>

<h3 id="classes-are-combination-of-data-and-code">Classes are combination of data and code</h3>

<p>For declaration and definition of classes, itâ€™s only a combination of data and code. The data members of a class are data declarations. The member functions of a class are code declarations. Besides:</p>

<ul>
  <li>All classâ€™s member functions that are implemented inside the class declaration are <em>potentially</em> inlined (not guaranteed to be inlined)</li>
</ul>

<p>Except for that, class is not that special compared to standalone types and functions in declaration and definition.</p>

<h2 id="symbols-and-libraries">Symbols and libraries</h2>

<p>Data definitions(global variables) and code declaration(global functions, class member functions..) will produce symbols in binary. Symbols can be categorized into <em>defined</em> and <em>undefined</em>:</p>

<ul>
  <li>Defined(T): those are symbols that current translation unit or library <em>provides</em></li>
  <li>Undefined(U): those are symbols that current translation unit or library <em>requires</em> from outside</li>
</ul>

<p>Normally, every object file and shared library file contains a section <code class="language-plaintext highlighter-rouge">.symtab</code> to store all symbols.</p>

<h3 id="static-libraries">Static libraries</h3>

<p>Static libraries are archives of object files. Static libraries are not <em>linked</em>, which has many implications:</p>

<ul>
  <li>Multiple definitions of data and functions can exist in different object files</li>
  <li>When a static library depends on other static libraries or shared libraries:
    <ul>
      <li>Only header files of those static libraries and shared libraries are actually required by this static library</li>
      <li>Binaries of those dependees are not required, since static libraries are <em>not</em> linked</li>
      <li>Static libraries do not contain the information of their dependees</li>
    </ul>
  </li>
</ul>

<p>When itâ€™s used, only the relevant object files will be copied, not the whole archive. The linker copies code <strong>in the unit of object files</strong>. But if instead we separately give the object files to gcc compiler in command, all the object files, even if they are not used by the final program, will be copied into the executable.</p>

<h3 id="shared-libraries">Shared libraries</h3>

<p>Shared libraries are <em>linked</em> (not necessarily fully linked, might contain unresolved symbols) executable files:</p>

<ul>
  <li>When a shared lib A depends on another static lib B:
    <ul>
      <li>A <em>absorbs</em> B at binary level, after compilation and linking, in the eyes of A there is no B anymore</li>
      <li>Thanks to the PRIVATE-becomes-PUBLIC behavior mentioned above, all Bâ€™s dependencies will be passed into A</li>
      <li>If A is about to be exported as a library, relevant headers of B, more in general relevant headers of all dependent static libs of A, should also be exported together with Aâ€™s headers, as long as those headers are used in Aâ€™s public API.
        <ul>
          <li>Or lib B will still be used as individual lib and is required in downstream target that depends on A, but this time only the headers of B are actually used. This can lead to another problem, that is when lib B is linked to multiple shared libs: Problem reproduction can be found at <a href="https://github.com/shan-weiqiang/cplusplus/tree/main/ODR">here</a>.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>When a shared lib A depends on another shared lib B (A needs Bâ€™s header to compile, but can link or not link to B during compile time):
    <ul>
      <li>A <em>works</em> with B. After compilation and linking, A stores dependency information on B and will see B during load time again (if B is linked during compile time, otherwise there is no Bâ€™s information in A)</li>
      <li>See more in <em>More about libraries</em> section</li>
    </ul>
  </li>
</ul>

<p>Shared libs contain unresolved symbols. Those undefined symbols can further be categorized into:</p>
<ul>
  <li>Unresolved symbols in linked dependencies: those symbols are <em>resolved</em> during compile time and the dependent shared libs information are recorded in shared lib</li>
  <li>Unresolved symbols with no known provider at compile time: those symbols are <em>not resolved</em> at compile time and the resolution of them is deferred until this shared lib is used with an executable.</li>
</ul>

<h3 id="more-about-libraries">More about libraries</h3>

<p>If A is a static lib we are building, B and C are two libs that A depends on. Letâ€™s suppose B is static and C is dynamic:</p>

<ul>
  <li>A only needs B and Câ€™s header file location to successfully compile</li>
  <li>After compilation, inside Aâ€™s binary there are no B or Câ€™s dependency information</li>
</ul>

<p>If in Aâ€™s public API, there is no use of B or Câ€™s any declaration or definitions (only includes B or Câ€™s header in cpp file), the normal way to link to B and C is to use <em>PRIVATE</em> keyword, since Aâ€™s public API does not refer to B or Câ€™s headers. When A as a library is depended on by executable D, D will have the problem of finding symbols in B and C during linking time, because there is no information in binary A to locate B and C! So cmake is smart enough to have a PRIVATE-becomes-PUBLIC behavior for static libraries. See: <a href="https://cmake.org/pipermail/cmake/2016-May/063400.html">[CMake] Difference between PRIVATE and PUBLIC with target_link_libraries</a></p>

<p>If A is a shared lib, the situation is even more complex:</p>

<ul>
  <li>For B, all depended code in B will be copied into A already, D does not need Bâ€™s binary anymore (might still need its headers!!)</li>
  <li>For C, even though itâ€™s not copied into A, but inside A there will be information recorded in DT_NEEDED section that says that A depends on C, so D can find C according to this information, <strong>both at compile/link time and load time!!</strong>. During load time the dynamic linker will read info from A and load C into program automatically.</li>
</ul>

<p>About in which scenario PRIVATE keyword can be used:</p>
<ul>
  <li>If in Aâ€™s API there is any header dependency, PUBLIC should be used.</li>
  <li>If in Aâ€™s API there is no header dependency:
    <ul>
      <li>If A is static: if Aâ€™s binary depends on B or C, PUBLIC should be used.</li>
      <li>If A is shared:
        <ul>
          <li>For static lib B, if A has binary dependency on B, PUBLIC should be used, otherwise PRIVATE can be used: <strong>A only used Bâ€™s declaration headers in Aâ€™s source file</strong></li>
          <li>For shared lib C:
            <ul>
              <li>If A only used Câ€™s declaration headers in Aâ€™s source file, hence no binary dependency, PRIVATE can be used. Otherwise:
                <ul>
                  <li>If A is linked during compile time, then Câ€™s information is already inside DT_NEEDED section, PRIVATE keyword can be used, when A is used to link an executable, <strong>linker will find C according to DT_NEEDED information</strong>.</li>
                  <li>If A is not linked during compile time, then Câ€™s information is not inside DT_NEEDED section, when A is used to link an executable, linker will need C specified on command, so PUBLIC keyword should be used.</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>Refer to experiment: <a href="https://github.com/shan-weiqiang/lab/tree/main/shared_lib_link">shared_lib_link</a></p>

<p>From point of view of cmake, header and binary dependency are independent from each other: each one can exist independently from each other and co-exist with each other:</p>

<ol>
  <li>
    <p>When building and linking static libraries or shared libraries, only header files are required; all symbols can be unresolved.</p>
  </li>
  <li>
    <p>When building and linking executables, all dependent libraries must be present to the compiler and linker! Including those recursively dependent libraries.</p>
  </li>
  <li>
    <p>Compiler and linker will search libraries according to:</p>
    <ul>
      <li>Command line arguments (decided by CMake)</li>
      <li>DT_NEEDED section (in shared libraries)</li>
    </ul>
  </li>
</ol>

<h4 id="symbol-visibility">Symbol visibility</h4>

<p>Except for .symtab section, shared libraries also have .dynsym section which stores symbols that this lib defines and symbols that need to be resolved during load time. We can control symbolâ€™s visibility in .dynsym with gcc compiler. By default, all symbols that are defined in shared lib will appear in .dynsym. We can use <code class="language-plaintext highlighter-rouge">__attribute__((visibility("hidden")))</code> to hide symbols from appearing here. This specifier has different meanings when used on defined and undefined symbols:</p>

<ul>
  <li>If itâ€™s used on defined symbols inside current lib, this symbol will not be seen outside. Not appear in .dynsym</li>
  <li>If itâ€™s used on undefined symbols, this symbol will not appear in .dynsym. If its definition is not found inside current lib, compiler will issue not-defined error</li>
</ul>

<p>Visibility specifier can be used on both data definitions and code definitions.</p>

<h3 id="best-practices">Best practices</h3>

<p>When building libraries using cmake:</p>

<ul>
  <li>Never use PRIVATE when specifying static libâ€™s dependencies. Since all its dependencies info will not be recorded inside it and every user of it will use its dependencies during final linking when building an executable. Even if PRIVATE is used, cmake is smart enough to behave like PUBLIC and dismiss the requirement.</li>
  <li>Use PRIVATE when specifying shared libâ€™s dependencies if this dependencyâ€™s header file does not appear inside shared libâ€™s public API. Shared lib remembers what it depends on.</li>
  <li>When shared lib depends on static lib, properly manage the header files of the static lib. Install relevant static libâ€™s headers into shared libâ€™s headers set. Note that we do not need to worry about the dependee static libâ€™s headers locations if current shared lib is used inside current build system, again thanks to the PRIVATE-becomes-PUBLIC behavior for static libraries. However, if the shared lib will be exported and used by clients, proper header file installation is required.</li>
  <li>Use symbol control: .dynsym will be loaded into memory when program is running. If a symbol is not used by outside libs and exists in .dynsym, itâ€™s a waste of memory and a slow down of program loading phase. It will also have the problem of multiple definition, although not intentionally by programmer, which will lead to unexpected behaviors. We will talk about this when we talk about one definition rule later.</li>
</ul>

<h2 id="one-definition-rule">One definition rule</h2>

<p>For definition of ODR, see <a href="https://en.cppreference.com/w/cpp/language/definition">Definitions and ODR (One Definition Rule)</a>. I only share what I get from experiment and its implications in linking.</p>

<h3 id="odr-check-during-linking">ODR check during linking</h3>

<p>Static linking</p>

<p>This is when <em>executable</em> files are generated, including <em>executables</em> and <em>shared libraries</em>. During static linking, multiple <em>object</em> files are processed and merged into one <em>executable</em> file. ODR rules are checked during this phase, for example if multiple definitions exist in more than one <em>object</em> file, errors will be issued. Note that <em>object</em> file, aka translation unit, is the smallest unit that is being operated by the compiler. If static libraries are being linked, <em>object</em> files inside this archive file are chosen and used atomically. Using <em>object</em> file (one translation unit) as the smallest unit is based on that:</p>
<ul>
  <li>If one symbol, for example a function name, is used from this TU, it is possible that this function will call other functions or variables inside this same TU. If linker only extracts the function itself, it needs to know the detail of the inner structure of this translation unit, which is the job of the compiler, not the linker. So, for simplicity, linker treats TU atomically.</li>
</ul>

<p>Dynamic linking - Compile time</p>

<p>This is when <em>executable</em> depends on another <em>shared library</em>. Linker will NOT check ODR and use the first one it can find.</p>
<ul>
  <li>If the <em>executable</em> is a dynamic library, and if it depends on another dynamic library, for example <em>liba.so</em>, then if not specially handled with linking options, <em>liba.so</em> can be linked and NOT linked during this phase, since dynamic libraries symbols are resolved during load time. But the resulting shared libraries binary is a little bit different:
    <ul>
      <li>If <em>liba.so</em> is linked at this phase, in the <em>metadata</em>, the DT_NEEDED section of this library will contain <em>liba.so</em> and will be automatically loaded during load time.</li>
      <li>If <em>liba.so</em> is not linked at this phase, there will be no <em>liba.so</em> in DT_NEEDED section. This means <em>liba.so</em> will not be automatically loaded during load time. This dependency management is deferred for the executable which uses this shared library.</li>
      <li>Other than that, the code inside the shared library is the same and shared lib can both be built successfully.</li>
    </ul>
  </li>
</ul>

<p>Dynamic linking - Run time</p>

<p>This is when <em>executables</em> are being loaded. Linker will NOT check ODR and use the first one it can find. However, even though linker does not check ODR, it implements ODR strictly: if there are multiple definitions, the first one will be used for all.</p>

<h3 id="which-definition-to-use">Which definition to use?</h3>

<p>In static libs there might be multiple definitions for the same symbol name in different object files (see <a href="https://github.com/shan-weiqiang/cplusplus/tree/main/ODR/static">experiment</a>). In shared libs there might be multiple definitions for the same symbols in different shared libs when those libs are both required by an executable (see <a href="https://github.com/shan-weiqiang/cplusplus/tree/main/ODR/shared">experiment</a>). When an executable is linked to those libs, how does the compiler choose definitions if there are multiple definitions available? The answer is rather interesting:</p>

<p><strong>There is no such problem in the eyes of the linker, since the linker just uses the definition that it first finds and the resolution process is finished</strong></p>

<p>The linker is <em>lazy</em>, it does not try to find all available options and decide which one to use. Instead, the linker finds the available one and says: <em>oh! here you are!</em> and stops the searching process. The first symbol appearance wins and is used by the linker.</p>

<h3 id="data-definitions-are-special">Data definitions are special</h3>

<p>Data definitions are special in that they not only involve data memory allocation, they also involve <em>construction and initialization</em> code execution. For example, if the linker tries to find one global variable definition and it finds one in shared lib A, all hereafter appearances of this symbol will be treated as the same definition. If in shared lib B there is also this symbol, this symbol will be addressed in lib Aâ€™s memory mappings, the memory of the same definition in lib B will <em>not</em> be used, since lib Aâ€™s definition appears <em>first</em>.</p>

<p>But, a data definition is not only about memory, itâ€™s also about construction and initialization. In our example, lib A and lib B both will construct and initialize at lib Aâ€™s symbol address, which means that this data definition symbol will be constructed and initialized <strong>two times</strong>. I encountered one such situation once:</p>

<ul>
  <li>Static lib A contains global variable <code class="language-plaintext highlighter-rouge">a</code></li>
  <li>Lib A is linked into shared lib S1</li>
  <li>Lib A is linked into shared lib S2</li>
  <li>S1 and S2 are both linked into executable E</li>
  <li>In <code class="language-plaintext highlighter-rouge">a</code>â€™s construction and initialization code, there is some checking that says it cannot be initialized twice, otherwise program terminates.</li>
</ul>

<p>The above situation will terminate the program and the reason is that <code class="language-plaintext highlighter-rouge">a</code> will be constructed twice. Problem reproduction can be found at <a href="https://github.com/shan-weiqiang/cplusplus/tree/main/ODR">here</a>.</p>

<h3 id="code-definitions-are-influenced-by-optimization">Code definitions are influenced by optimization</h3>

<p>Since the linker only respects the first appearance of symbols, if a code definition symbol, such as a function, is inlined by the compiler, there will be no such problem. And whether a function is inlined or not can be decided by the optimization level of the compiler. So different optimization levels might produce different code behaviors. Take an example:</p>

<ul>
  <li>Lib A has its own implementation of function <code class="language-plaintext highlighter-rouge">f</code></li>
  <li>main.cpp also has an implementation of function <code class="language-plaintext highlighter-rouge">f</code></li>
  <li>main.cpp depends and links to lib A</li>
</ul>

<p>When compiled with different optimization levels:</p>

<ul>
  <li>If <code class="language-plaintext highlighter-rouge">f</code> is inlined, lib A will use <code class="language-plaintext highlighter-rouge">f</code> in lib A</li>
  <li>If <code class="language-plaintext highlighter-rouge">f</code> is not inlined, lib A will refer to <code class="language-plaintext highlighter-rouge">f</code> in main.cppâ€™s source file and use its implementation, since the linker finds the <code class="language-plaintext highlighter-rouge">f</code> implementation in main.cpp first</li>
</ul>

<p>This video demonstrates this problem very well: <a href="https://www.youtube.com/watch?v=HakSW8wIH8A">C++ Linkers and the One Definition Rule - Roger Orr - ACCU 2024</a></p>

<h3 id="how-templates-cope-with-odr">How templates cope with ODR</h3>

<p>Templates, such as standard libraries, are instantiated in each translation unit. Inside one translation unit, the compiler will only instantiate one definition for one particular template parameter. But what happens during link time? Since all translation units might instantiate the same template argument, which is basically certain because everybody is using standard library. This can be solved possibly in two ways:</p>

<ul>
  <li>Make all template instantiation in-line</li>
  <li>At link time, use the first instantiation that appears to the linker</li>
</ul>

<p>The first approach avoids problems by removing any symbols. The second approach just goes the normal way. But this approach brings another question: if lib A uses lib Bâ€™s implementation code, how does the linker manage the load and unload sequence of lib A and lib B, so as to avoid any disaster during runtime? I asked this problem in StackOverflow, and I think the answer is satisfying: <a href="https://stackoverflow.com/questions/79147491/template-instantiation-and-symbol-resolution-problem?noredirect=1#comment139562798_79147491">template instantiation and symbol resolution problem
</a>.</p>

<blockquote>
  <p>Start with the obvious: libraries are loaded in one order, unloaded in the reverse order, exactly so that non-cyclical dependencies can work.
Now ask the question again: how can the dynamic linker resolve a symbol so that itâ€™s not prematurely unloaded? The answer is trivial: just use the first occurrence. It will be unloaded last.
Note that most std::vector&lt;std::string&gt; methods are likely to be inlined and simply wonâ€™t appear in any library, precisely because theyâ€™re templates. operator[] for instance is not a whole lot more than a simple addition.</p>
</blockquote>]]></content><author><name></name></author><category term="c++" /><summary type="html"><![CDATA[In this post, I talk about declaration and definition and their relationship with symbols and code in binaries. Then I discuss library dependency issues and finally the ODR rule. Those are things that we normally donâ€™t care about. However, understanding them give us more control over the binaries we produce.]]></summary></entry><entry><title type="html">Life of an object</title><link href="http://localhost:4000/2024/10/26/life-of-an-object.html" rel="alternate" type="text/html" title="Life of an object" /><published>2024-10-26T09:22:46+08:00</published><updated>2024-10-26T09:22:46+08:00</updated><id>http://localhost:4000/2024/10/26/life-of-an-object</id><content type="html" xml:base="http://localhost:4000/2024/10/26/life-of-an-object.html"><![CDATA[<p>Itâ€™s safe to say that one of the most important part of C++ is how an object is created and how it is destructed. Letâ€™s explain it. To understand the runtime behavior and logic, firstly we need to understand the resource model of an C++ object.</p>

<ul id="markdown-toc">
  <li><a href="#resource-model" id="markdown-toc-resource-model">Resource model</a>    <ul>
      <li><a href="#resources-are-managed-recursively" id="markdown-toc-resources-are-managed-recursively">Resources are managed recursively</a></li>
      <li><a href="#every-object-is-responsible-for-its-own-resoruces" id="markdown-toc-every-object-is-responsible-for-its-own-resoruces">Every object is responsible for itâ€™s own resoruces</a></li>
    </ul>
  </li>
  <li><a href="#object-creation-and-object-destruction-operators" id="markdown-toc-object-creation-and-object-destruction-operators">Object creation and Object destruction operators</a>    <ul>
      <li><a href="#new-and-delete" id="markdown-toc-new-and-delete"><code class="language-plaintext highlighter-rouge">new</code> and <code class="language-plaintext highlighter-rouge">delete</code></a></li>
      <li><a href="#operator-new-and-operator-delete" id="markdown-toc-operator-new-and-operator-delete"><code class="language-plaintext highlighter-rouge">operator new</code> and <code class="language-plaintext highlighter-rouge">operator delete</code></a></li>
      <li><a href="#placement-new-and-calling-destructor-explicitly" id="markdown-toc-placement-new-and-calling-destructor-explicitly">placement <code class="language-plaintext highlighter-rouge">new</code> and calling destructor explicitly</a></li>
    </ul>
  </li>
  <li><a href="#runtime-creation-and-destruction" id="markdown-toc-runtime-creation-and-destruction">Runtime creation and destruction</a>    <ul>
      <li><a href="#recursion-again" id="markdown-toc-recursion-again">Recursion, again</a></li>
      <li><a href="#here-comes-exceptions" id="markdown-toc-here-comes-exceptions">Here comes exceptions</a></li>
      <li><a href="#why-destructors-should-not-throw-exceptions" id="markdown-toc-why-destructors-should-not-throw-exceptions">Why destructors should not throw exceptions?</a></li>
    </ul>
  </li>
</ul>

<h2 id="resource-model">Resource model</h2>

<p>An object contain resources: memory, file descriptors, sockets, threads, timers, etc.. Those resources are managed using RAII by object. For now we only consider the memory part, which is also the most complicated. An object manages memory in two ways:</p>

<ul>
  <li>Direct management: memory is together with the object itself</li>
  <li>Indirect management: memory is managed by pointers</li>
</ul>

<h3 id="resources-are-managed-recursively">Resources are managed recursively</h3>

<p>Following diagram illustrate an example of memory resources of object A. object A contains one member called member1, which is <em>directly managed</em> by object A; Inside member1 there is a pointer points to object C, which is <em>indirectly managed</em> my member1; Inside object C there is again a pointer which points to object D, which <em>directly manages</em> object E and <em>indirectly manages</em> a chunk of raw memory.</p>

<p><img src="/assets/images/object_memory.png" alt="alt text" /></p>

<p>Above example is just an illustration, as we can see: it goes recursively. An object can <em>directly</em> or <em>indirectly</em> manage a huge mount of resources in this way. Another important point is that through pointers, a <em>fixed</em> sized object can manage <em>variable</em> amount of resources at runtime: this is actually the cornerstone of how dynamic languages are implemented using static languages like C/C++. It is also the basis for any program written in static languages that can dynamically manage resources.</p>

<h3 id="every-object-is-responsible-for-its-own-resoruces">Every object is responsible for itâ€™s own resoruces</h3>

<p>Every object is <em>single-handedly</em> responsible for itâ€™s own resources: both <em>directly managed resources</em> or <em>indirectly managed resources</em>. In our example, member1 is <em>directly managed</em> by object A, so when object A is constructed or destructed, itâ€™s responsible for allocating memory for member1, calling constructor of member1, calling destructor of member1 and deallocate memories occupied by member1. Object A does not know and care anything about object C, object D, or any raw memory. Those are recursively being taken care of by the object to which they belong.</p>

<h2 id="object-creation-and-object-destruction-operators">Object creation and Object destruction operators</h2>

<p>Creation of an object involves two distinct stages:</p>

<ul>
  <li>Memory allocation: allocate <em>fixed-sized</em> amount of memory required to hold the object</li>
  <li>Initialization: calling constructor on pre-allocated memory region</li>
</ul>

<p>Destruction of an object involves two distinct stages:</p>

<ul>
  <li>Destruction: calling destructor of the object</li>
  <li>Memory deallocation: return the memory occupied by this object to kernel</li>
</ul>

<h3 id="new-and-delete"><code class="language-plaintext highlighter-rouge">new</code> and <code class="language-plaintext highlighter-rouge">delete</code></h3>

<p>The <code class="language-plaintext highlighter-rouge">new</code> keyword does memory allocation and initialization at the same time</p>

<p>The <code class="language-plaintext highlighter-rouge">delete</code> keyword does call of destructor and memory deallocation at the same time</p>

<h3 id="operator-new-and-operator-delete"><code class="language-plaintext highlighter-rouge">operator new</code> and <code class="language-plaintext highlighter-rouge">operator delete</code></h3>

<p>The <code class="language-plaintext highlighter-rouge">operator new</code> only allocate the required amount of memory for an object</p>

<p>The <code class="language-plaintext highlighter-rouge">operator delete</code> only deallocate the memory occupied for an object</p>

<h3 id="placement-new-and-calling-destructor-explicitly">placement <code class="language-plaintext highlighter-rouge">new</code> and calling destructor explicitly</h3>

<p>Placement new call constructor of object directly in pre-allocated memory region. Generally, the memory is individually managed by memory pool or something. After the object fulfils itâ€™s mission, destructor of it must be <em>explicitly</em> called programatically by programmer, which is almost the only circumstance where destructor is called by programmer. Two important point here:</p>

<ul>
  <li>Placement new <em>does not</em> allocate memory</li>
  <li>Call of destructor <em>does not</em> deallocate memory</li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">std::uninitialized_copy</code> function can be used to do range of placement <code class="language-plaintext highlighter-rouge">new</code> on a sequence of pre-allocated memories.</p>

<h2 id="runtime-creation-and-destruction">Runtime creation and destruction</h2>

<p>Now we know the memory model and the creation and destruction phase of object, now letâ€™s consider them in action.</p>

<h3 id="recursion-again">Recursion, again</h3>

<p>Since the resouces are managed <em>recursively</em>, so does the creation and destruction of object. Following diagram illustrate the creation and destruction of object A. (Note this is not the same object A above)</p>

<p><img src="/assets/images/life_of_object.png" alt="alt text" /></p>

<p>Letâ€™s first ignores the exception part of this diagram and only focus on the creation and destruction part:</p>

<ul>
  <li>The blue part: memory allocation/deallocation/constructors/destructors are the only phase that code are being executed</li>
  <li>Other part only indicates logical sequence of program execution</li>
</ul>

<p>Firstly, memory has to be allocated before calling of constructors, one thing to note:</p>

<ul>
  <li>Memory allocation happens <em>once</em> for object A</li>
  <li>All memers <em>directly managed</em> by object A are constructed on pre-allocated memory similar to placement <code class="language-plaintext highlighter-rouge">new</code></li>
</ul>

<p>Secondly, since itâ€™s a recursion, then what is the <em>base case</em>? Answering this question make us see through a lot of mistories of object creation/destruction. In simple words, the recursion base object meet following requriements:</p>

<ul>
  <li>This object <em>do not</em> have parent class</li>
  <li>All members(if any) must be basic types in C++, which can be zero-initialized by the compiler</li>
  <li>This object have compiler-synthesized constructor or user-defined constructor</li>
</ul>

<p>An object that meet above requirements is where the recursion ends, both for construction and destruction.</p>

<h3 id="here-comes-exceptions">Here comes exceptions</h3>

<p>What if exceptions occur during the construction phase of object? The behaviors are:</p>

<ul>
  <li>Destructors should not throw exceptions <em>ever</em></li>
  <li>If exceptions need to throw in constructors, the best way to do it is throw it directly, no better alternatives</li>
  <li>If an exception is thrown from an constructor:
    <ul>
      <li>The destructor of the object being constructed will <em>not</em> be called, since it is not considered an object</li>
      <li>The already constructed base class, members constructors will be called in reverse order of their construction</li>
      <li>If the object is created using <code class="language-plaintext highlighter-rouge">new</code>, the memory will be deallocated by the compiler, so no memory leakage</li>
      <li>If the object is created using placement <code class="language-plaintext highlighter-rouge">new</code>, the memory will <em>not</em> be deallocated</li>
    </ul>
  </li>
</ul>

<p>Since destructors of current object whose constructor throws will not be called, program should <em>always</em> use RAII instead of store a pointer to manage resources such as memory, for example:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">MyClass</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span> <span class="c1">// good, memory will be freed using RAII</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">bad_data</span><span class="p">;</span> <span class="c1">// bad, memory leakage</span>
    <span class="n">MyClass</span><span class="p">()</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">)),</span> <span class="n">bad_data</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">43</span><span class="p">)){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"MyClass constructor</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Error during construction"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">MyClass</span><span class="p">(){</span>
      <span class="k">delete</span> <span class="n">bad_data</span><span class="p">;</span> <span class="c1">// This will not be called if exception is thrown in constructor</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="why-destructors-should-not-throw-exceptions">Why destructors should not throw exceptions?</h3>

<p>It is not that destructors can not throw exceptions. Destructors indeed can throw exceptions and can be catched, as long as at the time the destructor throws there is one corresponding try..catch block waiting to handle this exception. The try..catch blocks can be nested in multiple levels, but there must be only one exception expected inside each tryâ€¦catch block.</p>

<p>If destructors are called during unwinding, which indicates that there is already an exception existing and the runtime is trying to find a try..catch block to handle it. In this case, if the destructor also throw an exception, there is an question that can not be decided by the compiler: when a try..catch block is found, which exception should it handle? The original one, or the new one thrown by the destructor? Instead of doing this decision, the compiler just call std::terminate. Again what if multiple destructors all throws, what the compiler should do about those exceptions?</p>

<p>The situation is not the same if there are nested try..catch blocks. If inside destructor that is new try..catch blocks, then inside this try block if any exception is thrown, it is clear for the compiler that any exception inside it should be handled by this try block, not conflicting with the unwinding exception. In this case, the exception and itâ€™s handler is clear.</p>

<p>So the question of why destructor should not throw is quite simple: one try..catch block can only handle one exception at runtime, if there are two exceptions at the same time, the compiler do not know which one to handle, so it terminate the program, which is reasonable. And the only scenario that this could happen is during the unwinding phase of an exception, during which time the destructors will be called. So destructors should take the burden to not throw exceptions.</p>]]></content><author><name></name></author><category term="c++" /><summary type="html"><![CDATA[Itâ€™s safe to say that one of the most important part of C++ is how an object is created and how it is destructed. Letâ€™s explain it. To understand the runtime behavior and logic, firstly we need to understand the resource model of an C++ object.]]></summary></entry><entry><title type="html">CMake: Best Practice(bp)</title><link href="http://localhost:4000/2024/09/18/cmake-best-practice.html" rel="alternate" type="text/html" title="CMake: Best Practice(bp)" /><published>2024-09-18T09:22:46+08:00</published><updated>2024-09-18T09:22:46+08:00</updated><id>http://localhost:4000/2024/09/18/cmake-best-practice</id><content type="html" xml:base="http://localhost:4000/2024/09/18/cmake-best-practice.html"><![CDATA[<p>It has been a long time since I want to summarize the usage of CMake and give a best practice for using it. Recently I have time to read the book: <a href="https://crascit.com/">Professional CMake: A Practical Guide</a>, and itâ€™s time to do this. CMake is complex and easy at the same time: itâ€™s complex because what it tries to solve is complex; itâ€™s easy because once we know how to use it and familiar with the best practice, itâ€™s basically repitition afterwards. So the key here is to have a model for repetition, which I try to give here.</p>

<p>All code can be found at repo: <a href="https://github.com/shan-weiqiang/cmake/tree/main/best_practice_lib">best_practice_lib</a>.</p>

<p>For easy understanding of the repo, the project composition is like following:</p>

<p><img src="/assets/images/cmake_best_practice.png" alt="alt text" /></p>

<p>After build and installation, the package looks like following:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>âžœ  <span class="nb">install </span>git:<span class="o">(</span>main<span class="o">)</span> tree                                     //&lt;<span class="nb">install </span>folder&gt;
<span class="nb">.</span>
â”œâ”€â”€ bin                                                        //executables folder
â”‚   â”œâ”€â”€ computer -&gt; computer-1.0.0
â”‚   â””â”€â”€ computer-1.0.0
â”œâ”€â”€ include                                                    // header files folder
â”‚   â”œâ”€â”€ caculator
â”‚   â”‚   â””â”€â”€ caculator.h
â”‚   â”œâ”€â”€ divide
â”‚   â”‚   â””â”€â”€ divide.h
â”‚   â”œâ”€â”€ json.hpp
â”‚   â””â”€â”€ multi
â”‚       â””â”€â”€ multi.h
â””â”€â”€ lib
    â”œâ”€â”€ cmake                                                   // folder <span class="k">for </span>cmake scripts
    â”‚   â””â”€â”€ bp
    â”‚       â”œâ”€â”€ bpConfig.cmake                                  // package level cmake
    â”‚       â”œâ”€â”€ bpConfigVersion.cmake                           // package level version cmake<span class="o">(</span>package only<span class="o">)</span>
    â”‚       â”œâ”€â”€ Caculator                                       // Caculator component
    â”‚       â”‚   â”œâ”€â”€ CaculatorConfig.cmake
    â”‚       â”‚   â””â”€â”€ CaculatorConfig-noconfig.cmake
    â”‚       â”œâ”€â”€ Computer                                        // Computer component
    â”‚       â”‚   â”œâ”€â”€ ComputerConfig.cmake
    â”‚       â”‚   â””â”€â”€ ComputerConfig-noconfig.cmake
    â”‚       â”œâ”€â”€ Json                                            // Json component
    â”‚       â”‚   â””â”€â”€ JsonConfig.cmake
    â”‚       â””â”€â”€ Math                                            // Math component
    â”‚           â”œâ”€â”€ MathConfig.cmake
    â”‚           â””â”€â”€ MathConfig-noconfig.cmake
    â”œâ”€â”€ libCaculator.so -&gt; libCaculator.so.3                    // libraries <span class="k">in </span>unix version format  
    â”œâ”€â”€ libCaculator.so.3 -&gt; libCaculator.so.3.2.1
    â”œâ”€â”€ libCaculator.so.3.2.1
    â”œâ”€â”€ libdivide.so -&gt; libdivide.so.3
    â”œâ”€â”€ libdivide.so.3 -&gt; libdivide.so.3.2.1
    â”œâ”€â”€ libdivide.so.3.2.1
    â”œâ”€â”€ libmulti.so -&gt; libmulti.so.3
    â”œâ”€â”€ libmulti.so.3 -&gt; libmulti.so.3.2.1
    â””â”€â”€ libmulti.so.3.2.1
</code></pre></div></div>

<p>Consumers can use above package and components and specify versions like:</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">find_package</span><span class="p">(</span>bp 2.1.0 EXACT COMPONENTS Caculator<span class="p">)</span>
</code></pre></div></div>
<p>Examples can be found at: <a href="https://github.com/shan-weiqiang/cmake/tree/main/best_practice_client">best_practice_client</a></p>

<p>What really matters:</p>

<ul>
  <li>All target dependencies are managed automatically. For example when client use <code class="language-plaintext highlighter-rouge">Math::Caculator</code> component, itâ€™s dependency <code class="language-plaintext highlighter-rouge">Math::divide</code>, <code class="language-plaintext highlighter-rouge">Math::multi</code>, and their dependencies <code class="language-plaintext highlighter-rouge">nlomann::json</code> and <code class="language-plaintext highlighter-rouge">foonathan_memory</code> will be automatically discovered. If the dependencies are not met, error will happen during configuration time and give proper messsages.</li>
  <li>Support <code class="language-plaintext highlighter-rouge">QUIET</code> option for package</li>
</ul>

<p>Detailed usage and their nationale are given inside the repo as comments. The repo will be continously updated in the future, such as <code class="language-plaintext highlighter-rouge">ctest</code>, <code class="language-plaintext highlighter-rouge">cpack</code> will be added.</p>]]></content><author><name></name></author><category term="c++" /><summary type="html"><![CDATA[It has been a long time since I want to summarize the usage of CMake and give a best practice for using it. Recently I have time to read the book: Professional CMake: A Practical Guide, and itâ€™s time to do this. CMake is complex and easy at the same time: itâ€™s complex because what it tries to solve is complex; itâ€™s easy because once we know how to use it and familiar with the best practice, itâ€™s basically repitition afterwards. So the key here is to have a model for repetition, which I try to give here.]]></summary></entry></feed>