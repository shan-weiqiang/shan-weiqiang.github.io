<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>SOME/IP standard keynotes | shanweiqiang’s blog</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="SOME/IP standard keynotes" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="标准链接：SOME/IP(Scalable service-Oriented MiddlewarE over IP)。" />
<meta property="og:description" content="标准链接：SOME/IP(Scalable service-Oriented MiddlewarE over IP)。" />
<link rel="canonical" href="http://localhost:4000/2024/04/19/SOME-IP-%E8%A7%A3%E8%AF%BB.html" />
<meta property="og:url" content="http://localhost:4000/2024/04/19/SOME-IP-%E8%A7%A3%E8%AF%BB.html" />
<meta property="og:site_name" content="shanweiqiang’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-04-19T19:22:46+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="SOME/IP standard keynotes" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-04-19T19:22:46+08:00","datePublished":"2024-04-19T19:22:46+08:00","description":"标准链接：SOME/IP(Scalable service-Oriented MiddlewarE over IP)。","headline":"SOME/IP standard keynotes","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2024/04/19/SOME-IP-%E8%A7%A3%E8%AF%BB.html"},"url":"http://localhost:4000/2024/04/19/SOME-IP-%E8%A7%A3%E8%AF%BB.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="shanweiqiang&apos;s blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">shanweiqiang&#39;s blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/tags/">tags</a><a class="page-link" href="/about/">about</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">SOME/IP standard keynotes</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2024-04-19T19:22:46+08:00" itemprop="datePublished">Apr 19, 2024
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>标准链接：<a href="https://www.autosar.org/fileadmin/standards/R23-11/FO/AUTOSAR_FO_PRS_SOMEIPProtocol.pdf">SOME/IP</a>(Scalable service-Oriented MiddlewarE over IP)。</p>

<ul id="markdown-toc">
  <li><a href="#12-applicability-of-the-protocol" id="markdown-toc-12-applicability-of-the-protocol">1.2 Applicability of the protocol</a></li>
  <li><a href="#4-protocol-specification" id="markdown-toc-4-protocol-specification">4 Protocol Specification</a>    <ul>
      <li><a href="#41-specification-of-someip-message-format-serialization" id="markdown-toc-41-specification-of-someip-message-format-serialization">4.1 Specification of SOME/IP Message Format (Serialization)</a>        <ul>
          <li><a href="#412-header" id="markdown-toc-412-header">4.1.2 Header</a>            <ul>
              <li><a href="#4121-message-id-32-bit" id="markdown-toc-4121-message-id-32-bit">4.1.2.1 Message ID [32 Bit]</a></li>
              <li><a href="#4124-request-id-32-bit" id="markdown-toc-4124-request-id-32-bit">4.1.2.4 Request ID [32 Bit]</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#42-specification-of-someip-protocol" id="markdown-toc-42-specification-of-someip-protocol">4.2 Specification of SOME/IP Protocol</a>        <ul>
          <li><a href="#421-transport-protocol-bindings" id="markdown-toc-421-transport-protocol-bindings">4.2.1 Transport Protocol Bindings</a>            <ul>
              <li><a href="#4211-udp-binding" id="markdown-toc-4211-udp-binding">4.2.1.1 UDP Binding</a></li>
              <li><a href="#4212-tcp-binding" id="markdown-toc-4212-tcp-binding">4.2.1.2 TCP Binding</a></li>
              <li><a href="#4213-multiple-service-instances" id="markdown-toc-4213-multiple-service-instances">4.2.1.3 Multiple Service-Instances</a></li>
              <li><a href="#4214-transporting-large-someip-messages-of-udp-someip-tp" id="markdown-toc-4214-transporting-large-someip-messages-of-udp-someip-tp">4.2.1.4 Transporting large SOME/IP messages of UDP (SOME/IP-TP)</a></li>
            </ul>
          </li>
          <li><a href="#422-requestresponse-communication" id="markdown-toc-422-requestresponse-communication">4.2.2 Request/Response Communication</a></li>
          <li><a href="#423-fireforget-communication" id="markdown-toc-423-fireforget-communication">4.2.3 Fire&amp;Forget Communication</a></li>
          <li><a href="#424-notification-events" id="markdown-toc-424-notification-events">4.2.4 Notification Events</a>            <ul>
              <li><a href="#4241-strategy-for-sending-notifications" id="markdown-toc-4241-strategy-for-sending-notifications">4.2.4.1 Strategy for sending notifications</a></li>
            </ul>
          </li>
          <li><a href="#425-fields" id="markdown-toc-425-fields">4.2.5 Fields</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#6-protocol-usage-and-guidelines" id="markdown-toc-6-protocol-usage-and-guidelines">6 Protocol usage and guidelines</a>    <ul>
      <li><a href="#61-choosing-the-transport-protocol" id="markdown-toc-61-choosing-the-transport-protocol">6.1 Choosing the transport protocol</a></li>
    </ul>
  </li>
</ul>

<h2 id="12-applicability-of-the-protocol">1.2 Applicability of the protocol</h2>

<blockquote>
  <p>SOME/IP shall be used for inter-ECU Client/Server Serialization.</p>
</blockquote>

<hr />
<p><strong>NOTE</strong></p>

<p>SOME/IP协议是为跨主机的Server/Client SOA架构设计的，包括对应的服务发现协议SOME/IP-SD也是只对跨主机的服务发现进行了规定，对主机内的Server/Client通信方式、服务发现都没有定义</p>

<hr />

<h1 id="4-protocol-specification">4 Protocol Specification</h1>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="/assets/images/SOMEIPProtocol.jpg" alt="Alt text" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><em>Server/Client 交互模式；图片来源：<a href="https://github.com/COVESA/vsomeip/wiki/vsomeip-in-10-minutes">vsomeip</a></em></td>
    </tr>
  </tbody>
</table>

<ul>
  <li>Server与Client之间通过TCP/UDP直接建立链接通信</li>
  <li>每个Server可以同时与多个Client建立连接</li>
  <li>Server通过[sourceIP, sourcePort, dstIP, dstPort, Protocol]五元组确定Client，每个Client可以与Server以TCP和UDP建立两个通道</li>
  <li>Client负责发起所有TCP链接；Client负责将TCP链接的随机端口号和UDP的端口号发送给Server</li>
  <li>Server负责主动通过TCP和UDP发送数据给Client</li>
  <li>Server收到eventgroup的订阅后，就会将event数据主动通过已经建立的TCP或者已知的UDP端口号发给Client
    <ul>
      <li>Server发送的Client地址是在SubscribeEventGroup服务发现消息中由Client告知Server的</li>
    </ul>
  </li>
  <li>Server收到method的Request请求，处理请求，原路通过通信链接返回结果</li>
  <li>Server没有Client的概念，它只知道有通信连接和订阅信息
    <ul>
      <li>从Server的角度看，一个Server，即一个Service Instance，对外监听了两个传输层端口(也可以只监听一个)，一个TCP端口，用于接收Client的连接请求；一个UDP端口，用于向Client的UDP端口发送数据</li>
      <li>Server中的每个event，method只能选择TCP或者UDP通道(<a href="https://www.autosar.org/fileadmin/standards/R23-11/FO/AUTOSAR_FO_PRS_SOMEIPServiceDiscoveryProtocol.pdf">SOME/IP-SD 5.1.2.6</a>)</li>
    </ul>
  </li>
</ul>

<hr />
<p><strong>NOTE</strong></p>

<ul>
  <li>具体的实现中Server/Client可以是不同的实体，例如在vsomeip中，一个vsomeip的<em>application</em>类中可以offer多个、request多个服务的实例</li>
  <li>协议只规定<em>服务</em>相关的概念，以及与底层传输层<em>TCP</em>,<em>UDP</em>的绑定关系，具体的实现可以不同；但是都需要对TCP，UDP链接进行管理</li>
</ul>

<hr />

<hr />
<p>Server提供的Service由events、methods、fields组成：</p>

<ul>
  <li>
    <p>event：Client订阅event，Server接收到订阅后，当条件满足会主动将event群发给订阅方；Client只能通过eventgroup的形式订阅event；一个eventgroup可以包含一个或者多个当前Service下的event</p>
  </li>
  <li>
    <p>method：Client向Server发起Request，包含参数；Server收到Request后，接收参数，执行相关逻辑，得到返回结果，将返回结果以Response的形式返回给Client</p>
  </li>
  <li>
    <p>field：event和method的组合。包含一个值，当这个值满足某些条件时Server群发该值给所有订阅者（event）；这个值可以被set，Client可以调用setter方法设定这个值（method）；也可以通过getter方法获取这个值（method）</p>
  </li>
</ul>

<h2 id="41-specification-of-someip-message-format-serialization">4.1 Specification of SOME/IP Message Format (Serialization)</h2>

<h3 id="412-header">4.1.2 Header</h3>

<h4 id="4121-message-id-32-bit">4.1.2.1 Message ID [32 Bit]</h4>

<ul>
  <li>消息ID全局唯一，唯一的确定一个event或者method</li>
  <li>由两部分组成，分别占[16 bits]：
    <ul>
      <li>Service ID：所属的service ID</li>
      <li>Method ID：这里Method ID可以是服务内部的method或者event的ID。</li>
    </ul>
  </li>
</ul>

<hr />
<p><strong>NOTE</strong></p>

<p>注意没有Instance ID</p>

<hr />

<h4 id="4124-request-id-32-bit">4.1.2.4 Request ID [32 Bit]</h4>

<p>这个字段跟method，field中的setter，getter(特殊的methods)相关，用于在client所在的机器上唯一的确定<em>当前client的一次</em>method的调用：</p>

<ul>
  <li>这个字段只有在client的机器上才有意义，server不关心这个字段，server只是将该字段拷贝到response消息头中</li>
  <li>client与server建立TCP/UDP连接后，每一个method都只能在一个通信连接上通信，那么在client这一侧，可能有多个调用方同时在这个连接上发送method请求；在server端，它不关心这个是谁的请求，它只是负责处理这个请求并将结果从收到请求的TCP/UDP链接发送出去；在client这一侧，则需要Request ID来区分收到的来自server的回复是哪一个请求的，这样才能把收到的回复结果放入相应的<em>promise</em>中</li>
</ul>

<p>这个ID由两部分组成，分别占[16 bits]：</p>

<ul>
  <li>Client ID [16 Bits]：这个<em>Client ID</em>不是当前server/client服务中的<em>client</em>，而是服务client中的<em>使用方</em>：
    <ul>
      <li>服务client可以理解为一个TCP/UDP链接通道；Client ID中的client可以理解为向这个TCP/UDP链接发送的一个method请求message的唯一标识符；这个标识符用于把收到的server的response与一次请求唯一对应起来</li>
      <li>每一个服务client下的每一个method（即每一个Message ID)，都有自己独立的Client ID范围：Client ID唯一性的适用范围是Message ID</li>
    </ul>
  </li>
  <li>Session ID [16 Bits]：当前Client ID下当前method请求消息的计数器</li>
</ul>

<hr />
<p><strong>NOTE</strong></p>

<p>这里Client ID<strong>不是</strong>与Service ID对应的Client一方的ID，而是Client的<em>一个用户</em>的ID</p>

<hr />

<h2 id="42-specification-of-someip-protocol">4.2 Specification of SOME/IP Protocol</h2>

<h3 id="421-transport-protocol-bindings">4.2.1 Transport Protocol Bindings</h3>

<blockquote>
  <p>[PRS_SOMEIP_00138] If a server runs different instances of the same service, messages belonging to different service instances shall be mapped to the service instance by the transport protocol port on the server side.c(RS_SOMEIP_00015)</p>
</blockquote>

<ul>
  <li>SOME/IP支持TCP或者UDP传输层协议</li>
  <li>如果一个Machine上同时提供多个同一个Service ID的不同Instance，则这些Instance必须被绑定到不同的Port口，无论是TCP还是UDP，详细原因分析看4.2.1.3</li>
  <li>一个Service Instance可以使用的传输层通信方式：
    <ul>
      <li>TCP单播</li>
      <li>UDP单播</li>
      <li>UDP组播</li>
    </ul>
  </li>
</ul>

<hr />
<p><strong>NOTE</strong></p>

<p>这三个Port口是可以同时存在的，但是每一个最多只能有一个；对于服务下面的Event或者Method，只能同时对应一个TCP单播或者UDP单播，不能同时使用两个，这点在<a href="https://www.autosar.org/fileadmin/standards/R23-11/FO/AUTOSAR_FO_PRS_SOMEIPServiceDiscoveryProtocol.pdf">SOME/IP-SD 5.1.2.6</a>中有规定</p>

<hr />

<h4 id="4211-udp-binding">4.2.1.1 UDP Binding</h4>

<blockquote>
  <p>[PRS_SOMEIP_00943] The client and server shall use a single UDP unicast connection for all methods, events, and notifications of a Service-Instance which are configured to be communicated using UDP unicast.c(RS_SOMEIP_00010)</p>

</blockquote>

<p>server和client之间一旦建立了TCP/UDP的通道（UDP没有connection，但是此处我们认为相互发现后即是<em>链接</em>），TCP通道负责当前服务下所有配置为使用TCP的event，method，field；UDP通道负责当前服务下所有配置为使用UDP的event，method，field</p>

<blockquote>
  <p>[PRS_SOMEIP_00942] The client and server may use a single UDP multicast address per each Service-Instance which are configured to be communicated using UDP multicast.c(RS_SOMEIP_00010)</p>
</blockquote>

<p>如果server/client之间配置了UDP组播通信，则所有的配置为UDP通信方式的event，method，field都<em>可能</em>通过这个组播地址通信, 在<a href="https://www.autosar.org/fileadmin/standards/R23-11/FO/AUTOSAR_FO_PRS_SOMEIPServiceDiscoveryProtocol.pdf">SOME/IP-SD</a>中：</p>

<blockquote>
  <p>[PRS_SOMEIPSD_00134] Unicast/Multicast switching for event and notification event transmission via UDP dFor events and notification events which are configured to be transmitted via UDP (see [PRS_SOMEIPSD_00802]) SOME/IP-SD shall support automated switching from unicast to multicast communication if a configured threshold of the numbers of subscribers was reached.c(RS_SOMEIPSD_00025, RS_-SOMEIPSD_00016)</p>
</blockquote>

<h4 id="4212-tcp-binding">4.2.1.2 TCP Binding</h4>

<blockquote>
  <p>[PRS_SOMEIP_00707] The client and server shall use a single TCP connection for all methods, events, and notifications of a Service-Instance which are configured to be communicated using TCP.c(RS_SOMEIP_00010)</p>
</blockquote>

<p>server和client之间一旦建立了TCP/UDP的通道（UDP没有connection，但是此处我们认为相互发现后即是<em>链接</em>），TCP通道负责当前服务下所有配置为使用TCP的event，method，field；UDP通道负责当前服务下所有配置为使用UDP的event，method，field</p>

<p>在使用TCP传输层协议时，必须关闭Nagle算法，保证每次数据发送都必须马上打包成一个TCP segment发送出去，目的是保证消息消息实时性。</p>

<blockquote>
  <p>Nagle算法将多个TCP发送积累成一个大的TCP segment发送的算法，目的是提高TCP数据包的payload比例；因为一个TCP报文的头部占40-Byte，如果单个segment的payload过小，则发送的数据大部分都是头部信息，降低了报文的利用率，增加了线上阻塞的风险</p>
</blockquote>

<p>TCP的链接发起、重连、关闭都是由client端决定的</p>
<ul>
  <li>当server端调用了StopOfferService接口停止服务后，不能自行终断TCP链接，而应该是client端来操作，否则client端会进行重连，造成资源浪费</li>
</ul>

<h4 id="4213-multiple-service-instances">4.2.1.3 Multiple Service-Instances</h4>

<ul>
  <li>首先一个机器上，可以针对同一个Service提供多个不同的Service Instance，即服务的实例</li>
  <li>每一个Service Instance在一个Service ID下有一个全局唯一的Instance ID</li>
  <li>已知SOME/IP的消息头是不包含Service Instance ID信息的（SOME/IP-SD的消息中是包含Instance ID信息的）</li>
  <li>以上就会导致一个问题：client如何通过SOME/IP消息头来判断这个消息来自同一个机器上的哪一个Instance</li>
</ul>

<p>无论是UDP还是TCP都有一个(srcIP, srcPort, dstIP, dstPort)的tuple来表示一个通信链接：</p>

<ul>
  <li>不同机器上的服务实例，无论是同一个服务还是不同的服务，都可以通过通信链接来区分不同的Instance</li>
  <li>同一个机器上的不同的Service，可以通过其唯一的Service ID来区分</li>
  <li>同一个机器上的相同的Service，因为它们有相同的Service ID，而且SOME/IP消息头不包含Instance ID的信息，只能通过通信链接来区分不同的Instance；从client的视角来看srcIP, dstIP是不能变动的，那么能区分的就只有srcPort或者dstPort，而Instance ID是由服务的提供方，即server侧定义的，所以区分也自然应该由server端来区分：
    <ul>
      <li>同一个Host上相同的Service的不同Instance需要绑定到不同的Port端口</li>
    </ul>
  </li>
</ul>

<h4 id="4214-transporting-large-someip-messages-of-udp-someip-tp">4.2.1.4 Transporting large SOME/IP messages of UDP (SOME/IP-TP)</h4>

<p>针对一个UDP报文放不下的数据，SOME/IP使用SOME/IP-TP（SOME/IP Transport Protocol）来分成多个UDP报文发送，基本的原理就是每一个分割后的UDP报文都自带一个Session ID接收端通过Session ID来进行组装。SOME/IP标准的建议是能使用UDP的地方尽量使用UDP，只有在传输很大的数据，且没有严格的延迟要求的情况下才使用TCP</p>

<h3 id="422-requestresponse-communication">4.2.2 Request/Response Communication</h3>

<ul>
  <li>所有Request的参数必须按照在函数调用中的实际参数位置顺序进行序列化</li>
</ul>

<h3 id="423-fireforget-communication">4.2.3 Fire&amp;Forget Communication</h3>

<ul>
  <li>与普通Request/Response的区别在与不会等待Response</li>
</ul>

<blockquote>
  <p>Fire&amp;Forget不是返回值为<code class="language-plaintext highlighter-rouge">void</code> 的特殊情况，当然Fire&amp;Forget返回值类型是<code class="language-plaintext highlighter-rouge">void</code>，但是与普通Request/Response返回值是<code class="language-plaintext highlighter-rouge">void</code>不同，Fire/Forget不会等待，所以无法确定，其请求的任务是否执行完毕。但是普通的返回<code class="language-plaintext highlighter-rouge">void</code>的情况下，虽然返回值是<code class="language-plaintext highlighter-rouge">void</code>，但是可以通过<code class="language-plaintext highlighter-rouge">std::future</code>的<code class="language-plaintext highlighter-rouge">get()</code>方法来判断服务方是否已经执行完毕，这种情况往往需要服务方发送完成的标志位给到请求方。而Fire&amp;Forget情况下，服务提供方是不会发送任何回复给请求方的，这也是为什么Fire&amp;Forget的请求永远不会返回错误码。</p>

</blockquote>

<h3 id="424-notification-events">4.2.4 Notification Events</h3>

<blockquote>
  <p>[PRS_SOMEIP_00930] When more than one subscribed client on the same ECU exists, the system shall handle the replication of notifications in order to save transmissions on the communication medium.c(RS_SOMEIP_00042) 
This is especially important, when notifications are transported using multicast messages.</p>
</blockquote>

<p>AUTOSAR要求当一个client机器上有多个订阅同一个服务ID的Client时，实现上需要考虑降低网络流量，这其实确定了SOME/IP的实现往往需要一个中心节点。只有通过这个中心节点，做统一的收发管理，才能最大程度的优化网络流量。</p>

<h4 id="4241-strategy-for-sending-notifications">4.2.4.1 Strategy for sending notifications</h4>

<p>订阅发送的三种模式：</p>

<ul>
  <li>周期发送</li>
  <li>事件触发发送</li>
  <li>值变化超过某个范围发送</li>
</ul>

<h3 id="425-fields">4.2.5 Fields</h3>

<p>Fields是Events和Methods的融合体，具体表现在：</p>

<ul>
  <li>一个Fields需要至少包含一个<code class="language-plaintext highlighter-rouge">getter</code>，一个<code class="language-plaintext highlighter-rouge">setter</code>，一个<code class="language-plaintext highlighter-rouge">notifier</code></li>
  <li><code class="language-plaintext highlighter-rouge">getter</code>和<code class="language-plaintext highlighter-rouge">setter</code>，本质就是Methods</li>
  <li><code class="language-plaintext highlighter-rouge">notifier</code>，本质就是Event</li>
</ul>

<h1 id="6-protocol-usage-and-guidelines">6 Protocol usage and guidelines</h1>

<h2 id="61-choosing-the-transport-protocol">6.1 Choosing the transport protocol</h2>

<p>SOME/IP的传输层协议是具体到一个消息的：</p>

<ul>
  <li>每一个Event，Method等都可以配置自己的传输层协议</li>
</ul>

<p>在UDP和TCP的选择上，建议如下：</p>

<ul>
  <li>
    <blockquote>
      <p>1400Bytes，且在错误发生时没有严格实时性要求的，使用TCP</p>
    </blockquote>
  </li>
  <li>如果在错误发生时实时性要求&lt;100ms，使用UDP</li>
  <li>如果错误发生时实时性要求&lt;100ms，且消息&gt;1400 Bytes，使用SOME/IP-TP</li>
</ul>

  </div><a class="u-url" href="/2024/04/19/SOME-IP-%E8%A7%A3%E8%AF%BB.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">shanweiqiang&#39;s blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">shanweiqiang&#39;s blog</li><li><a class="u-email" href="mailto:schmessi@163.com">schmessi@163.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/shan-weiqiang"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">shan-weiqiang</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
