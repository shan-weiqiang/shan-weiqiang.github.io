code generated by colcon build mainly consists of two parts:

- Type binding for different languages: c, cpp, python
- Type support code for c/cpp

## type language bindings

These part or code is generated under folder *rosidl_generator_<language>* folder, where *language* is the specific language binding. Those code complete functionalities as following: 

- Language specific type definition
- Language specific creation/destruction/copy/comparison of messages
- Language specific method for getting `rosidl_message_type_support_t` for this specific message

### rosidl_generator_c

All methods and message definitions are generated in C style. Creation/initialization/copy/.. methods are defined as individual functions, with a unique function name for *each individual message*. This function name includes the package name and the message name in it. For type support, there is a unique function declared for each message, In following form:

```c
ROSIDL_GENERATOR_C_PUBLIC_test_pkg
const rosidl_message_type_support_t *
ROSIDL_TYPESUPPORT_INTERFACE__MESSAGE_SYMBOL_NAME(
  rosidl_typesupport_c,
  test_pkg,
  msg,
  MyMsg
)();
```

### rosidl_generator_cpp

Since cpp has namespace, the message definition is generated using object oriented way as a *struct*. All creation/destruction/copy/comparison functionalities are class member methods. Additionally, cpp binding will generate *traits*, which can print message to yaml form. Besides, cpp binding does not generate a individual function for each message to get it's `rosidl_message_type_support_t` pointer. It is completed using cpp's template feature instead. In type support translation unit a `get_message_type_support_handle` method template specialization will be provided:

```cpp
template<>
ROSIDL_TYPESUPPORT_CPP_PUBLIC
const rosidl_message_type_support_t *
get_message_type_support_handle<test_pkg::msg::MyMsg>()
{
  return &::test_pkg::msg::rosidl_typesupport_cpp::MyMsg_message_type_support_handle;
}
```
It's original declaration is in `rosidl_typesupport_cpp/message_type_support.hpp`:

```cpp
namespace rosidl_typesupport_cpp
{

template<typename T>
const rosidl_message_type_support_t * get_message_type_support_handle();

}  // namespace rosidl_typesupport_cpp
```

Note that both cpp will also expose a symbol name using extern "C", for each message of each support identifier. A support identifier identifies one kind of type support, such as fastrtps support(ser/deser), or introspection support.

### rosidl_generator_py

! todo

## type support

### rosidl_typesupport_c/rosidl_typesupport_cpp

Type support translation unit for c and cpp. Except for naming and obove mentioned `get_message_type_support_handle` method template specialization for cpp, they are essentially the same. This tranlation unit expose a symbol for each message about it's available type support, through, eg:

```cpp
const rosidl_message_type_support_t *
ROSIDL_TYPESUPPORT_INTERFACE__MESSAGE_SYMBOL_NAME(rosidl_typesupport_c, test_pkg, msg, MyMsg)() {
  return &::test_pkg::msg::rosidl_typesupport_c::MyMsg_message_type_support_handle;
}
```
This message specific function returns a `rosidl_message_type_support_t` type, which is at the core of message support of ros2:

```cpp
typedef const rosidl_message_type_support_t * (* rosidl_message_typesupport_handle_function)(
  const rosidl_message_type_support_t *, const char *);

/// Contains rosidl message type support data
struct rosidl_message_type_support_t
{
  /// String identifier for the type_support.
  const char * typesupport_identifier;
  /// Pointer to the message type support library
  const void * data;
  /// Pointer to the message type support handler function
  rosidl_message_typesupport_handle_function func;
};
```

This data structure is used in two situations, as specified by the `typesupport_identifier`:

- Here  `typesupport_identifier` is static `rosidl_typesupport_c__typesupport_identifier` for c and static `::rosidl_typesupport_cpp::typesupport_identifier` for cpp. It indicates that the `rosidl_message_type_support_t` data represents a top level entrance for this message type.
- It can also be used as a specific type support kind. In this scenario, `typesupport_identifier` is a string representing the specific type support kind, such as fastrtps, or introspeciton.


At here the `rosidl_message_type_support_t` is statically initialized for each message as(cpp, similar for c):

```cpp
static const rosidl_message_type_support_t MyMsg_message_type_support_handle = {
  ::rosidl_typesupport_cpp::typesupport_identifier,
  reinterpret_cast<const type_support_map_t *>(&_MyMsg_message_typesupport_map),
  ::rosidl_typesupport_cpp::get_message_typesupport_handle_function,
};
```
, where `_MyMsg_message_typesupport_map` is statically initialized:

```cpp
static const type_support_map_t _MyMsg_message_typesupport_map = {
  2, // number of type support kind
  "test_pkg", // package name
  &_MyMsg_message_typesupport_ids.typesupport_identifier[0], // first pointer of the type support identifier 
  &_MyMsg_message_typesupport_symbol_names.symbol_name[0], // first pointer of the tyep support symbol name
  &_MyMsg_message_typesupport_data.data[0], // stores the address of the function of above symbol in a dynamic library after symbol resolution
};
```
, where `_MyMsg_message_typesupport_ids`  is statically initialized:

```cpp
static const _MyMsg_type_support_ids_t _MyMsg_message_typesupport_ids = {
  {
    "rosidl_typesupport_fastrtps_cpp",  // ::rosidl_typesupport_fastrtps_cpp::typesupport_identifier,
    "rosidl_typesupport_introspection_cpp",  // ::rosidl_typesupport_introspection_cpp::typesupport_identifier,
  }
};
```
and `_MyMsg_message_typesupport_symbol_names` is statically initialized as:

```cpp
static const _MyMsg_type_support_symbol_names_t _MyMsg_message_typesupport_symbol_names = {
  {
    STRINGIFY(ROSIDL_TYPESUPPORT_INTERFACE__MESSAGE_SYMBOL_NAME(rosidl_typesupport_fastrtps_cpp, test_pkg, msg, MyMsg)),
    STRINGIFY(ROSIDL_TYPESUPPORT_INTERFACE__MESSAGE_SYMBOL_NAME(rosidl_typesupport_introspection_cpp, test_pkg, msg, MyMsg)),
  }
};
```

The identifier in `_MyMsg_message_typesupport_ids` and the symbol names `_MyMsg_message_typesupport_symbol_names` can identify one specific type support kind and can be retrieved by calling `::rosidl_typesupport_cpp::get_message_typesupport_handle_function`. This `rosidl_message_type_support_t`  can be seen as a type support entrance for this message and all other type support kind can be retrieved using type support identifier through it. Note that how the `::rosidl_typesupport_cpp::get_message_typesupport_handle_function` retrieve the specific `rosidl_message_type_support_t` is by dynamically loading shared libraries and find symbols in it. This requires that the library name have a unified naming convention, which ros2 does. For example *libtest_pkg__rosidl_typesupport_cpp.so*, which contains the package name and *typesupport* keyword. Ros2 will use these conventions to find shared libraries.

## rosidl_typesupport_fastrtps_c/rosidl_typesupport_fastrtps_cpp

Those folders contains type support for fastrtps serialization and deserialization implementation and expose relevent symbols:

```cpp
static message_type_support_callbacks_t __callbacks_MyMsg = {
  "test_pkg::msg",
  "MyMsg",
  _MyMsg__cdr_serialize,
  _MyMsg__cdr_deserialize,
  _MyMsg__get_serialized_size,
  _MyMsg__max_serialized_size
};

static rosidl_message_type_support_t _MyMsg__type_support = {
  rosidl_typesupport_fastrtps_c__identifier,
  &__callbacks_MyMsg,
  get_message_typesupport_handle_function,
};

const rosidl_message_type_support_t *
ROSIDL_TYPESUPPORT_INTERFACE__MESSAGE_SYMBOL_NAME(rosidl_typesupport_fastrtps_c, test_pkg, msg, MyMsg)() {
  return &_MyMsg__type_support;
}
```

Note that this symbol is stored in `_MyMsg_type_support_symbol_names_t`.

### rosidl_typesupport_introspection_c/rosidl_typesupport_introspection_cpp

Those folders contains type introspection informations and expose relevent symbols:

```cpp
static const ::rosidl_typesupport_introspection_cpp::MessageMembers MyMsg_message_members = {
  "test_pkg::msg",  // message namespace
  "MyMsg",  // message name
  2,  // number of fields
  sizeof(test_pkg::msg::MyMsg),
  MyMsg_message_member_array,  // message members
  MyMsg_init_function,  // function to initialize message memory (memory has to be allocated)
  MyMsg_fini_function  // function to terminate message instance (will not free memory)
};

static const rosidl_message_type_support_t MyMsg_message_type_support_handle = {
  ::rosidl_typesupport_introspection_cpp::typesupport_identifier,
  &MyMsg_message_members,
  get_message_typesupport_handle_function,
};


namespace rosidl_typesupport_introspection_cpp
{

template<>
ROSIDL_TYPESUPPORT_INTROSPECTION_CPP_PUBLIC
const rosidl_message_type_support_t *
get_message_type_support_handle<test_pkg::msg::MyMsg>()
{
  return &::test_pkg::msg::rosidl_typesupport_introspection_cpp::MyMsg_message_type_support_handle;
}

}  // namespace rosidl_typesupport_introspection_cpp

#ifdef __cplusplus
extern "C"
{
#endif

ROSIDL_TYPESUPPORT_INTROSPECTION_CPP_PUBLIC
const rosidl_message_type_support_t *
ROSIDL_TYPESUPPORT_INTERFACE__MESSAGE_SYMBOL_NAME(rosidl_typesupport_introspection_cpp, test_pkg, msg, MyMsg)() {
  return &::test_pkg::msg::rosidl_typesupport_introspection_cpp::MyMsg_message_type_support_handle;
}
```

Note that this symbol is stored in `_MyMsg_type_support_symbol_names_t`.

## ros2 and dynamic data

As we can see above, ros2 does not support dynamic data/type. All codes are statically generated and compiled, even for Python(because of the conversion function is in C and is statically generated and compiled). ros2 only support *introspection*, which means that give a message name, it can load relevent type support for this message, based on the naming convention of the shared libraries and type support functions, then get all the tools to operate on this type of message, such as creation/copy/deserilization/serialization, etc.. All these function relies on that ros2 can find the local statically generated shared libraries. In other words, message types need to be statically generated and compiled for ros2 to work with it.

To work with messages at runtime, without knowing the message code at compile time, dynamic data functionality is required. This is a try: https://github.com/ros2/rosidl_dynamic_typesupport







