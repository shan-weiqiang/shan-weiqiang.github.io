---
layout: post
title:  "Precision Time Protocol Concepts"
date:   2026-02-14 9:00:46 +0800
tags: [autonomous-driving]
---

* toc
{:toc}

## Introduction

Modern autonomous driving systems depend heavily on accurate time
synchronization. Sensors such as cameras, LiDAR, radar, and ECUs
generate massive streams of data that must be fused correctly to
understand the world. Without precise time alignment, perception
algorithms may associate sensor measurements that never actually
occurred at the same moment in real life.

Precision Time Protocol (PTP), defined in IEEE 1588, is the primary
technology used to achieve sub‚Äëmicrosecond synchronization across
distributed systems.

This article introduces:

-   Why time synchronization is critical in autonomous driving
-   The core ideas behind PTP
-   How PTP works internally
-   Hardware timestamping and NIC integration
-   Linux implementation details
-   Differences between in‚Äëcar systems and replay/simulation
    environments

------------------------------------------------------------------------

# Why Time Synchronization Matters in Autonomous Driving

In autonomous driving, perception modules process data from multiple
sensors:

-   Multiple cameras
-   LiDAR
-   Radar
-   IMU
-   GPS
-   Various ECUs

Each sensor:

-   Has its own clock
-   Produces data asynchronously
-   May transmit over Ethernet networks

Perception algorithms assume temporal consistency. For example:

-   A bounding box from camera A and a point cloud from LiDAR must
    represent the same physical moment.
-   Object tracking requires strict ordering of events.

Without accurate synchronization:

-   Sensor fusion errors occur.
-   Motion estimation becomes unstable.
-   Recorded data replay may produce different behavior than real
    vehicles.

This is why **time sync is foundational infrastructure** in autonomous
systems.

------------------------------------------------------------------------

# Real-Time Ordering vs Real-World Time

A key engineering question:

> How do we guarantee that timestamps across different hardware
> represent the same real-world time?

Each device contains its own oscillator, and clocks drift naturally due
to:

-   Temperature
-   Manufacturing variance
-   Network latency
-   CPU scheduling

PTP solves this by continuously measuring:

-   Clock offset
-   Propagation delay

and adjusting slave clocks to match a master reference.

------------------------------------------------------------------------

# Overview of Precision Time Protocol (PTP)

PTP is defined in IEEE 1588 and enables precise clock synchronization
over packet networks.

Unlike traditional NTP, which achieves millisecond-level accuracy, PTP
targets:

-   Microsecond or even nanosecond precision.

The core idea is:

üëâ Measure network delay precisely and compensate for it.

------------------------------------------------------------------------

# PTP Architecture

PTP systems use a hierarchical clock model:

-   Grandmaster clock --- reference time source
-   Boundary clocks --- intermediate network devices
-   Slave clocks --- synchronized devices

Each device exchanges timing messages to estimate:

-   Clock offset
-   Network delay

------------------------------------------------------------------------

# Core PTP Message Exchange

PTP synchronization involves four main timestamps:

1.  Master sends Sync message (timestamp T1).
2.  Slave receives Sync (timestamp T2).
3.  Slave sends Delay Request (timestamp T3).
4.  Master receives Delay Request (timestamp T4).

Using these timestamps:

    offset = ((T2 - T1) - (T4 - T3)) / 2
    delay  = ((T2 - T1) + (T4 - T3)) / 2

The slave then adjusts its clock frequency or phase.

The key insight:

üëâ Assume symmetric network delay and compute time offset
mathematically.

------------------------------------------------------------------------

# Why Hardware Timestamping is Critical

Software timestamps taken in user space suffer from:

-   Scheduling delays
-   Interrupt latency
-   Kernel buffering

These introduce unpredictable errors.

High-precision PTP instead relies on:

üëâ Network Interface Card (NIC) hardware timestamps.

Hardware timestamping records:

-   The exact moment a packet enters or leaves the wire.

Benefits:

-   Nanosecond-level precision
-   Minimal jitter

------------------------------------------------------------------------

# Linux Implementation of PTP

Linux provides strong support for PTP through:

## PTP Hardware Clock (PHC)

**PHC** = **PTP Hardware Clock**. It is the clock inside the **network card (NIC)** that Linux exposes as a device (e.g. `/dev/ptp0`, `/dev/ptp1`). The hardware is the NIC; the PHC is that NIC‚Äôs dedicated clock used for PTP and hardware timestamping.

Many NICs expose a dedicated hardware clock:

    /dev/ptpX

The kernel driver turns the NIC‚Äôs hardware clock into a PTP Hardware Clock and gives you `/dev/ptpX` to read or set it. Because the clock and timestamps are done in the NIC, you get much better accuracy than with the system clock or software timestamps.

Architecture:

    NIC hardware clock
           ‚Üì
    Kernel driver
           ‚Üì
    PHC interface
           ‚Üì
    ptp4l daemon

------------------------------------------------------------------------

## Key Tools

### ptp4l

**ptp4l** is the PTP daemon that runs against the NIC‚Äôs PHC (the hardware clock in the network card).

-   **Role:** Implements the PTP protocol (IEEE 1588) and keeps the **PHC** in sync with the PTP time source (e.g. a grandmaster clock on the network).
-   **What it does:**
    -   Exchanges PTP messages (sync, follow-up, delay request/response)
    -   Computes **offset** and **delay** to the master
    -   **Adjusts the NIC‚Äôs hardware clock** (the PHC), not the system clock
-   **Result:** The clock at `/dev/ptpX` is synchronized to the network‚Äôs PTP time.

In short: **ptp4l = ‚Äúsync the network card‚Äôs clock to the PTP network.‚Äù**

### phc2sys

**phc2sys** is a daemon that **synchronizes the system clock with the PHC** (or between clocks).

-   **Role:** Keeps the **Linux system clock** (e.g. CLOCK_REALTIME) in sync with the **PHC**.
-   **What it does:**
    -   Reads the PHC (e.g. `/dev/ptp0`)
    -   Continuously disciplines the **system clock** so it matches the PHC
-   **Why it‚Äôs needed:** Applications typically use the system clock. After ptp4l has synced the PHC, phc2sys makes the rest of the system see that same time.

In short: **phc2sys = ‚Äúsync the system clock to the NIC‚Äôs PTP-synced clock.‚Äù**

### Typical flow

```
PTP network (grandmaster)
        ‚Üì
   ptp4l  ‚Üí  syncs  ‚Üí  PHC (/dev/ptp0) on the NIC
        ‚Üì
   phc2sys  ‚Üí  syncs  ‚Üí  system clock
        ‚Üì
   Applications see accurate time via gettimeofday() / system clock
```

------------------------------------------------------------------------

# Hardware Timestamping in Socket Programming

Applications can access NIC timestamps using:

    SO_TIMESTAMPING

This is **kernel (and NIC driver) support**: the kernel provides the socket API, and the driver fills in timestamps from the NIC‚Äôs PHC when packets are sent or received. The socket layer does not implement the PTP protocol (ptp4l does that); it exposes the **same PTP-synced hardware clock** to user space, so application timestamps are in the PTP time domain.

Workflow:

1.  Enable timestamping via `setsockopt`.
2.  Receive packets using `recvmsg()`.
3.  Extract timestamps from ancillary control messages.

Hardware timestamps are delivered alongside packets as metadata.

This mechanism is widely used in:

-   Automotive middleware
-   High-frequency trading
-   Industrial automation

------------------------------------------------------------------------


# PTP vs NTP

  Feature               NTP              PTP
  --------------------- ---------------- ---------------------
  Typical accuracy      milliseconds     sub-microseconds
  Hardware support      no               yes
  Network assumptions   internet-scale   controlled networks
  Automotive use        rarely           standard approach

Personal computers typically use NTP rather than PTP.

------------------------------------------------------------------------


# Key Engineering Insights

-   Synchronization is not just about matching clocks --- it is about
    preserving real-world event ordering.
-   Hardware timestamping is essential for high accuracy.
-   Kernel support enables deterministic timestamp delivery.
-   Autonomous driving systems rely on continuous synchronization rather
    than one-time alignment.

------------------------------------------------------------------------

# Conclusion

Precision Time Protocol is foundational infrastructure in modern
distributed real-time systems, especially autonomous driving. By
combining mathematical delay estimation with hardware timestamping and
continuous clock adjustment, PTP enables multiple devices to share a
common timeline.

This shared temporal reference allows perception systems to fuse sensor
data reliably, reproduce real-world behavior during analysis, and
maintain deterministic system behavior across complex distributed
architectures.
